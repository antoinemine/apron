\nwfilename{implementorman.nw}\nwbegindocs{0}% -*- mode: LaTeX -*-% ===> this file was generated automatically by noweave --- better not edit it

%**********************************************************************
\chapter{Implementor manual}
\label{chap:implementorman}
%**********************************************************************

%======================================================================
\section{How to make an existing library conformant ?}
%======================================================================

We briefly describe here how to connect an existing library to the
common interface.

First, the library has to expose an interface which
conforms to the level 0 of the interface (module {\Tt{}abstract0}).
All the functions described in this module should be defined. If a
function is not really implemented, at least it shoulld contain
the code raising the exception {\Tt{}EXC{\_}NOT{\_}IMPLEMENTED}.  The
implementor may use any functions of the modules {\Tt{}coeff},
{\Tt{}expr0} and {\Tt{}manager} to help the job of converting datatypes
of the interface to internal datatypes used inside the library.

Second and last, the library should expose an initialization
function that allocates and initializes properly an object of type
{\Tt{}manager{\_}t}. For this purpose, the module {\Tt{}manager} offers the
utility functions {\Tt{}manager{\_}alloc}. As an example, we give the
definition of the function allocating a manager as implemented in
the \textsc{NewPolka}.

\begin{enumerate}
\item Header of the function:
\nwenddocs{}\nwbegincode{1}\moddef{init1}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
manager_t* pk_manager_alloc(
  bool strict /* specific parameter: do we allow strict constaints ? */
)
\{
\nwendcode{}\nwbegindocs{2}\nwdocspar
\item Allocation et initialisation des données globales
  spécifiques à \textsc{NewPolka}:
\nwenddocs{}\nwbegincode{3}\moddef{init1}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  pk_internal_t* pk = pk_internal_alloc(strict); /* allocation */
  pk_set_approximate_max_coeff_size(pk, 1); 
    /* initialization of specific functions
       (not offered in the common interface) */
\nwendcode{}\nwbegindocs{4}\nwdocspar
\item Allocation of the manager itself:
\nwenddocs{}\nwbegincode{5}\moddef{init1}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  manager_t* man = manager_alloc("polka","2.0",
                                 pk, (void (*)(void*))pk_internal_free);
\nwendcode{}\nwbegindocs{6}\nwdocspar
We provide resp. name, version, internal specific manager, and the
function to free it.

The function {\Tt{}manager{\_}alloc} sets the options of the
commoninterface to their default value (see documentation).
\item Initialization of the ``virtual'' table: we need to connect
  the generic functions of the interface (eg, {\Tt{}abstract{\_}meet},
  \ldots) to the actual functions of the library.  
\nwenddocs{}\nwbegincode{7}\moddef{init1}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  funptr = man->funptr;
  
  funptr[fun_minimize] = &poly_minimize;
  funptr[fun_canonicalize] = &poly_canonicalize;
  funptr[fun_approximate] = &poly_approximate;
  funptr[fun_is_minimal] = &poly_is_minimal;
  funptr[fun_is_canonical] = &poly_is_canonical;
  funptr[fun_fprint] = &poly_fprint;
  funptr[fun_fprintdiff] = &poly_fprintdiff;
  funptr[fun_fdump] = &poly_fdump;
  ...
\nwendcode{}\nwbegindocs{8}\nwdocspar
\item Last, we return the allocated manager:
\nwenddocs{}\nwbegincode{9}\moddef{init1}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  return man;
\}
\nwendcode{}\nwbegindocs{10}\nwdocspar
\end{enumerate}
That's all for the implementor side.

%======================================================================
\section{User side: how to use the common interface}
%======================================================================

From the user point of view, the benefit of using the common
interface is to restrict the place where the user is aware of the
real library in use is located in the
allocation and initialization of the manager.

\nwenddocs{}\nwbegincode{11}\moddef{use1}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
/* Allocating a manager using Polka functions */
manager_t* man = pk_manager_alloc(true);
/* Setting options offered by the common interface, 
   but with meaning possibly specific to the library */
manager_set_abort_if_exception(man,EXC_OVERFLOW,true);
\{
  funopt_t funopt;
  funopt_init(&funopt);
  funopt.algorithm = 1; /* default value is 0 */
  manager_set_funopt(man,fun_widening,&funopt); /* Setting options for widening */
\}
\{
  funopt_t funopt = manager_get_funopt(man,fun_widening);
  funopt.timeout = 30;
  manager_set_funopt(man,fun_widening,&funopt);
\}
/* Obtaining the internal part of the manager and setting specific options */
pk_internal_t* pk = manager_get_internal(man);
pk_set_max_coeff_size(pk,size);
\nwendcode{}\nwbegindocs{12}\nwdocspar

The standard operations can then be used and will have the
semantics defined in the interface. Notice however that some
generic functions are not formally generic: {\Tt{}abstract{\_}fprint},
{\Tt{}abstract{\_}fdump}, {\Tt{}abstract{\_}approximate}.

At any point, options may be modified in the same way as during
the initialization.

\point{Typing issue.}

The use of several libraries at the same time via the common
interface and the managers associated to each library raises the
problem of typing. Look at the following code:

\nwenddocs{}\nwbegincode{13}\moddef{type error}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
manager_t* manpk = pk_manager_alloc(true); /* manager for Polka */
manager_t* manoct = oct_manager_alloc();    /* manager for octagon */

abstract0_t* abs1 = abstract_top(manpk,3,3);
abstract0_t* abs2 = abstract_top(manoct,3,3);
tbool_t tb = abstract0_is_eq(manoct,abs1,abs2);
  /* Problem: the effective function called (octagon_is_eq) expects
     abs1 to be an octagon, and not a polyhedron ! */

abstract0_t* abs3 = abstract_top(manoct,3,3);
abstract0_meet_with(manpk,abs2,abs3);
  /* Problem: the effective function called (pk_meet_with) expects
     abs2 and abs3 to be polyhedra, but they are octagons */
\nwendcode{}\nwbegindocs{14}\nwdocspar

There is actually no typing, as {\Tt{}abstract0{\_}t*}, {\Tt{}abstract1{\_}t}
and {\Tt{}manager{\_}t} are abstract types shared by the different
libraries. Notice that the use of \textsc{C++} and inheritance would not solve
directly the problem, if functions of the interface are methods of
the manager; one would have:

\nwenddocs{}\nwbegincode{15}\moddef{type error2}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
manager_t* manpk = pk_manager_alloc(true); 
  /* manager for Polka, effective type pk_manager_t* */
manager_t* manoct = oct_manager_alloc();   
  /* manager for octagon, effective type oct_manager_t* */

abstract0_t* abs1 = manpk->abstract_top(3,3);
  /* effective type: poly_t */
abstract0_t* abs2 = manoct->abstract_top(3,3);
  /* effective type: oct_t */
tbool_t tb = manoct->abstract0_is_eq(abs1,abs2);
  /* No static typing possible: 
     manpk->abstract0_is_eq and manoct->abstract0_is_eq should have the same
     signature (otherwise one cannot interchange manpk and manoct in the code),
     which means that abs1 and abs2 are supposed to be of type abstract0_t* */
*/
\nwendcode{}\nwbegindocs{16}\nwdocspar

\point{Choices made wrt typing.}

The C interface does not perform any typing check. If one would
wish it, a simple solution would be the one adopted for the
\textsc{OCaml} interface (see below).

The OCaml interface does perform a \emph{dynamic} typing check. An
abstract value of type {\Tt{}Abstract0.t} contain both a C pointer to
an object of type {\Tt{}abstract0{\_}t} and a C pointer to an object of
type {\Tt{}manager{\_}t}.

\begin{enumerate}
\item This was anyway needed to finalize
{\Tt{}Abstract0.t} object, because one need to access to the
effective finalization function, which is done here by calling
{\Tt{}(man->funptr[fun{\_}free])(man,abs)}. 
\item A benefit is that one do not need to always pass explicitly the
manager as an argument to the functions. We just have
\nwenddocs{}\nwbegincode{17}\moddef{<example}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
(* Module Abstract0 *)
type t

val top: Manager.t -> t
  (* Here we need to specify the manager *)
val meet: t -> t -> t
  (* Here we just have to check the compatibility of the managers
     contained in the arguments *)
\nwendcode{}\nwbegindocs{18}\nwdocspar

\item The compatibility of the manager adopted is the following
one: {\Tt{}man1->funptr==man2->funptr}: the virtual table should be
the same.  Checking that {\Tt{}man1==man2} would be too strong,
because one may use two managers created by the same library, to
avoid interference in multithreaded programming.

\end{enumerate}
 
\nwenddocs{}
