% -*- mode: Noweb; noweb-code-mode: c-mode -*-

%**********************************************************************
\chapter{Contexte d'appel et fichier [[manager.h]]}
%**********************************************************************

Ce chapitre définit le fichier [[manager.h]] se rapportant à la
définition du contexte d'appel, ainsi que des types d'usage généraux.

<<*>>=
/* ************************************************************************* */
/* manager.h: global manager passed to all functions */
/* ************************************************************************* */

#ifndef _AP_MANAGER_H_
#define _AP_MANAGER_H_

#include <stdlib.h>
#include <stdio.h>

#include "ap_coeff.h"
@

%======================================================================
\section{Types d'usage général}
%======================================================================

<<*>>=

/* ********************************************************************** */
/* I. Types */
/* ********************************************************************** */

/* ====================================================================== */
/* I.O General usage */
/* ====================================================================== */

/* Boolean with a third value */
typedef enum tbool_t {
  tbool_false=0,
  tbool_true=1,
  tbool_top=2,   /* don't know */
} tbool_t;

static inline tbool_t tbool_of_bool(bool a);
static inline tbool_t tbool_of_int(int n);
static inline tbool_t tbool_or(tbool_t a, tbool_t b);
static inline tbool_t tbool_and(tbool_t a, tbool_t b);

/* For serialization */
typedef struct ap_membuf_t {
  void* ptr;
  size_t size;
} ap_membuf_t;
@ %def tbool_t

%======================================================================
\section{Identification des fonctions}
%======================================================================

\point{Identification des fonctions.}
Chaque fonction de l'interface niveau 0 est identifiée par un
numéro, allant de [[0]] à [[FUNID_SIZE-1]]. Les motivations sont les
suivantes:
\begin{description}
\item [Options associées aux fonctions:] cette solution permet
  d'avoir un tableau d'options pour les options associées à chaque
  fonction; cette solution réduit considérablement le nombre de
  fonctions permettant de consulter et de modifier ces options.
\item [Appels virtuels:] de même, on peut inclure dans le
  gestionnaire un tableau de fonctions, qui permet de se servir du
  gestionnaire pour faire des appels virtuels: c'est le gestionnaire
  qui définit la librairie effectivement appelée (voir plus loin).
\item [Exceptions:] on a également un identifiant ``universel'' des fonctions
  concernées dans les exceptions.
\end{description}

<<*>>=

/* ====================================================================== */
/* I.1 Identifying functions */
/* ====================================================================== */

typedef enum ap_funid_t {
  AP_FUNID_UNKNOWN,
  AP_FUNID_COPY,
  AP_FUNID_FREE,
  AP_FUNID_ASIZE, /* For avoiding name conflict with AP_FUNID_SIZE */
  AP_FUNID_MINIMIZE,
  AP_FUNID_CANONICALIZE,
  AP_FUNID_APPROXIMATE,
  AP_FUNID_IS_MINIMAL,
  AP_FUNID_IS_CANONICAL,
  AP_FUNID_FPRINT,
  AP_FUNID_FPRINTDIFF,
  AP_FUNID_FDUMP,
  AP_FUNID_SERIALIZE_RAW,
  AP_FUNID_DESERIALIZE_RAW,
  AP_FUNID_BOTTOM,
  AP_FUNID_TOP,
  AP_FUNID_OF_BOX,
  AP_FUNID_OF_LINCONS_ARRAY,
  AP_FUNID_DIMENSION,
  AP_FUNID_IS_BOTTOM,
  AP_FUNID_IS_TOP,
  AP_FUNID_IS_LEQ,
  AP_FUNID_IS_EQ,
  AP_FUNID_IS_DIMENSION_UNCONSTRAINED,
  AP_FUNID_SAT_INTERVAL,
  AP_FUNID_SAT_LINCONS,
  AP_FUNID_BOUND_DIMENSION,
  AP_FUNID_BOUND_LINEXPR,
  AP_FUNID_TO_BOX,
  AP_FUNID_TO_LINCONS_ARRAY,
  AP_FUNID_TO_GENERATOR_ARRAY,
  AP_FUNID_MEET,
  AP_FUNID_MEET_ARRAY,
  AP_FUNID_MEET_LINCONS_ARRAY,
  AP_FUNID_JOIN,
  AP_FUNID_JOIN_ARRAY,
  AP_FUNID_ADD_RAY_ARRAY,
  AP_FUNID_ASSIGN_LINEXPR,
  AP_FUNID_ASSIGN_LINEXPR_ARRAY,
  AP_FUNID_SUBSTITUTE_LINEXPR,
  AP_FUNID_SUBSTITUTE_LINEXPR_ARRAY,
  AP_FUNID_ADD_DIMENSIONS,
  AP_FUNID_REMOVE_DIMENSIONS,
  AP_FUNID_PERMUTE_DIMENSIONS,
  AP_FUNID_FORGET_ARRAY,
  AP_FUNID_EXPAND,
  AP_FUNID_FOLD,
  AP_FUNID_WIDENING,
  AP_FUNID_CLOSURE,
  AP_FUNID_SIZE,
  AP_FUNID_CHANGE_ENVIRONMENT,
  AP_FUNID_RENAME_ARRAY,
  AP_FUNID_SIZE2
} ap_funid_t;

extern const char* ap_name_of_funid[AP_FUNID_SIZE2];
/* give the name of a function identifier */

@

%======================================================================
\section{Exceptions}
%======================================================================

%----------------------------------------------------------------------
\point{Type} le type [[exc_t]] est défini comme suit:

<<*>>=

/* ====================================================================== */
/* I.2 Exceptions */
/* ====================================================================== */

/* Exceptions (public type) */
typedef enum ap_exc_t {
  AP_EXC_NONE,           /* no exception detected */
  AP_EXC_TIMEOUT,        /* timeout detected */
  AP_EXC_OUT_OF_SPACE,   /* out of space detected */
  AP_EXC_OVERFLOW,        /* magnitude overflow detected */
  AP_EXC_INVALID_ARGUMENT, /* invalid arguments */
  AP_EXC_NOT_IMPLEMENTED, /* not implemented */
  AP_EXC_SIZE
} ap_exc_t;

extern const char* ap_name_of_exception[AP_EXC_SIZE];

/* Exception log */
typedef struct ap_exclog_t {
  ap_exc_t exn;
  ap_funid_t funid;
  char* msg;                   /* dynamically allocated */
  struct ap_exclog_t* tail;
} ap_exclog_t;

/* Exceptions and other indications (out) (opaque type) */
typedef struct ap_result_t {
  ap_exclog_t* exclog; /* history of exceptions */
  ap_exc_t exn;                /* exception for the last called function */
  tbool_t flag_exact; /* result is mathematically exact or not
			 or don't know */
  tbool_t flag_best;  /* result is best correct approximation or not
			 or don't know */
} ap_result_t;

@ %def ap_exc_t ap_result_t

Remarque importante: dans la précédente proposition, on avait des
flags d'exception (un par exception) et se posait une question non
tranchée: suppose-t-on que les flags d'exceptions sont
implicitement remis à faux au début de chaque appel de fonction,
ou faut-il le faire manuellement ? Ici, l'utilisation d'un type
énuméré résoud le choix en faveur de la première option.

%----------------------------------------------------------------------
\point{Discussion:}
Le CRI souhaite que tout type \myfi{utilisé
comme résultat d'une fonction} inclut une constante {\em
xxx\_undefined}. La discussion n'a pas été terminée lors de la
première réunion sur ce point, l'étude de {\em is\_bottom} ne s'y
prêtant pas.

\myfi{La valeur {\em undefined} n'apparait pas dans les domaines
  abstraits.}

\myfi{Discussion à reprendre:
\begin{itemize}
\item l'information ne devrait-elle pas être portée dans le {\em manager}?
  Non pour le CRI qui se place dans une perspective de mise au point.
\item {\em undefined} n'est-il pas {\em top}? Le CRI doit effectivement
  utiliser parfois {\em undefined} comme {\em top} pour alléger
  l'implémentation. La sémantique d'{\em undefined} est-elle bien définie?
  Top? Not implemented? Exception occured? Utilisation des codes d'exception?
\item {\em fail\_with}?!?
\item Jérôme: utilisation pour des effets de bord détectés mais non
  traités.
\item propagation des erreurs? des exceptions? remises à zéro du {\em manger}?
\end{itemize}
}

%======================================================================
\section{Options}
%======================================================================

On synthétise les décisions prises (ou en cours) avant de refléter
les discussions à ce sujet.

%----------------------------------------------------------------------
\point{Options associées à chaque opération.} À chaque opération (non
triviale) sera associée un objet du type suivant:

<<*>>=

/* ====================================================================== */
/* I.2 Options */
/* ====================================================================== */

/* Option associated to each function (public type) */
typedef struct ap_funopt_t {
  int algorithm;
  /* Algorithm selection:
     - 0 is default algorithm;
     - MAX_INT is most accurate available;
     - MIN_INT is most efficient available;
     - otherwise, no accuracy or speed meaning
  */
  int approx_before;
  int approx_after;
  /* Related to the notion of approximation/reduction.
     Indicates which kind of "approximation" may be performed on the
     argument(s) before the algorithm, and on the result delivered
     by the algorithm. 0 is default behaviour. */
  size_t timeout; /* unit !? */
  /* Above the given computation time, the function may abort with the
     exception flag flag_time_out on.
  */
  size_t max_object_size; /* in abstract object size unit. */
  /* If during the computation, the size of some object reach this limit, the
     function may abort with the exception flag flag_out_of_space on.
  */
  bool flag_exact_wanted;
  /* return information about exactitude if possible
  */
  bool flag_best_wanted;
  /* return information about best correct approximation if possible
  */
} ap_funopt_t;
@ %def ap_funopt_t

On a choisi de spécifier ce type d'options fonction par
fonction, afin d'éviter à avoir à repositionner des options
globales entre chaque appel.

Le retour d'un résultat mathématiquement exact peut être identifié à
la demande de l'utilisateur (projection entière, union vs enveloppe
convexe, test de satisfiabilité en entier,...).

Idem pour un résultat représentant la meilleure approximation
correcte de l'opération dans le domaine abstrait considéré.

%----------------------------------------------------------------------
\point{Taille abstraite.} Une notion de taille abstraite d'objet
est définie.  Disposer d'une taille concrète (en octets) est
envisageable mais potentiellement très coûteux à évaluer
(notamment lors de l'emploi de nombres en multi-précision). or il
est souhaitable que le mécanisme d'``out\_of\_space'' ne pénalise
pas trop les performances.

%----------------------------------------------------------------------
\point{Mécanisme de détection des \emph{timeout}}: threads concurrentes ?
  Exception ? Discussion au sein de la Polylib pour avantages et
  inconvénients. \bj{Apparemment, on a opté pour exception}.

%----------------------------------------------------------------------
\point{Options paramétrées.}
Certaines heuristiques peuvent nécessiter des paramètres. Comment
les passe-t-on? \myfi{En ajoutant des champs dans {\em manager} ou
dans le champs {\em internal} de {\em manager} ?}  \bj{Je suis en
faveur de cette solution: les paramètres des heuristiques
dépendent fortement du domaine abstrait}

%----------------------------------------------------------------------
\point{Ensemble des options.}

<<*>>=
/* Options (in) (opaque type) */
typedef struct ap_option_t {
  ap_funopt_t funopt[AP_FUNID_SIZE];
  bool abort_if_exception[AP_EXC_SIZE];
  ap_scalar_discr_t scalar_discr; /* Preferred type for scalars */
} ap_option_t;
@ %def ap_option_t

\point{Question.} \bj{Dans les deux types précédents, on a choisi
une organisation mémoire à la C, dans laquelle une structure
hiérarchique est mise à plat. Ceci est est plus pratique en C, car
ne nécessite ni constructeur ni manipulation de pointeurs, mais
pour l'interfaçage avec \textsc{OCaml} ou \textsc{Java}, c'est
nettement moins pratique.}


%======================================================================
\section{Contexte d'appel}
%======================================================================

Le type [[manager_t]] est structuré comme suit:
<<*>>=

/* ====================================================================== */
/* I.3 Manager */
/* ====================================================================== */

/* Manager (opaque type) */
typedef struct ap_manager_t {
  char* library;                 /* name of the effective library */
  char* version;                 /* version of the effective library */
  void* internal;                /* library dependent,
				    should be different for each thread
				    (working space) */
  void* funptr[AP_FUNID_SIZE];     /* Array of function pointers,
				   initialized by the effective library */
  struct ap_option_t option;       /* Options (in) */
  struct ap_result_t result;       /* Exceptions and other indications (out) */
  void (*internal_free)(void*); /* deallocation function for internal */
  size_t count;                 /* reference counter */
} ap_manager_t;
@ %def ap_manager_t

On utilise du comptage de référence, car le gestionnaire sera
référencée depuis les valeurs abstraites de niveau 0 (et plus), et
il faut éviter de le désallouer si une de ces valeurs pointe
encore sur lui.

\point{Tableau pour les appels virtuels.} Le champ [[funptr]] du
gestionnaire est un tableau de (pointeurs de) fonctions. Ceci
permet d'implémenter des fonctions abstraites du type:
<<bidon>>=
static inline abstract0_t* abstract0_meet(manager_t* man, const abstract0_t* a1, const abstract0_t* a2){
  abstract0_t* (*ptr)(manager_t*,...) = man->funptr[fun_meet];
  return ptr(man,a1,a2);
}
@

Ceci permet au gestionnaire de jouer le rôle de sélecteur de
librairie. Seules les opérations relatives au gestionnaire
dépendent de la librairies effectivement utilisées, et toutes les
opérations du module [[abstract0]] sont génériques.

\point{Gestion du gestionnaire (allocation,déallocation).}

le chapitre ~\ref{chap:implementorman} donne plus de détail
là-dessus. Sommairement, chaque librairie interfacée doit fournir
une fonction d'alllocation et d'initialisation du
gestionnaire. Cette fonction initialise en particulier la table
virtuelle et le champ [[internal]] si la librairie en a l'usage.

%======================================================================
\section{Fonctions d'accès}
%======================================================================

<<*>>=

/* ********************************************************************** */
/* II. User Functions */
/* ********************************************************************** */

void ap_manager_clear_exclog(ap_manager_t* man);
  /* erase the current log of exception */
void ap_manager_free(ap_manager_t* man);
  /* dereference the counter,
     and possibly free internal field if it is not yet put to NULL */

/* Reading fields */
const char* ap_manager_get_library(ap_manager_t* man);
const char* ap_manager_get_version(ap_manager_t* man);

ap_funopt_t ap_manager_get_funopt(ap_manager_t* man, ap_funid_t funid);
bool ap_manager_get_abort_if_exception(ap_manager_t* man, ap_exc_t exn);

ap_exc_t ap_manager_get_exception(ap_manager_t* man);
  /* Get the last exception raised */
ap_exclog_t* ap_manager_get_exclog(ap_manager_t* man);
  /* Get the full log of exception */
tbool_t ap_manager_get_flag_exact(ap_manager_t* man);
tbool_t ap_manager_get_flag_best(ap_manager_t* man);

/* Settings fields */
void ap_funopt_init(ap_funopt_t* fopt);
void ap_manager_set_funopt(ap_manager_t* man, ap_funid_t funid, ap_funopt_t* funopt);
void ap_manager_set_abort_if_exception(ap_manager_t* man, ap_exc_t exn, bool flag);
@

<<*>>=

/* ********************************************************************** */
/* III. Implementor Functions */
/* ********************************************************************** */

ap_manager_t* ap_manager_alloc(char* library, char* version,
			       void* internal,
			       void (*internal_free)(void*));
static inline
ap_manager_t* ap_manager_copy(ap_manager_t* man);
  /* Increment the reference counter and return its argument */
void ap_manager_raise_exception(ap_manager_t* man,
			     ap_exc_t exn, ap_funid_t funid, const char* msg);
  /* raise an exception and put fiels
     man->result.flag_exact et man->result.flag_best to
     tbool_false
  */
ap_exclog_t* ap_exc_cons(ap_exc_t exn,
			 ap_funid_t funid, const char* msg,
			 ap_exclog_t* tail);
void ap_exclog_free(ap_exclog_t* head);
@

%======================================================================
\section{Définition des fonctions en-ligne}
%======================================================================

<<*>>=

/* ********************************************************************** */
/* IV. Definition of previously declared inline functions */
/* ********************************************************************** */

static inline tbool_t tbool_of_int(int n)
{ return ((n) ? tbool_true : tbool_false); }
static inline tbool_t tbool_of_bool(bool a)
  { return ((a) ? tbool_true : tbool_false); }
static inline tbool_t tbool_or(tbool_t a, tbool_t b)
{
  return
    ( (a==tbool_true || b==tbool_true) ? tbool_true :
      ( (a==tbool_top || b==tbool_top) ? tbool_top :
	tbool_false ) );
}
static inline tbool_t tbool_and(tbool_t a, tbool_t b)
{
  return
    ( (a==tbool_false || b==tbool_false) ? tbool_false :
      ( (a==tbool_top || b==tbool_top) ? tbool_top :
	tbool_true ) );
}
static inline
ap_manager_t* ap_manager_copy(ap_manager_t* man)
{ man->count++; return man; }
@

<<*>>=
#endif
@
