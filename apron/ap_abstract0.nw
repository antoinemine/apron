% -*- mode: Noweb; noweb-code-mode: c-mode -*-

%**********************************************************************
\chapter{Interface du domaine abstrait: fichier [[ap_abstract0.h]]}
\label{chap:abstract0}
%**********************************************************************

<<*>>=
/* ************************************************************************* */
/* ap_abstract0.h: generic operations on numerical abstract values */
/* ************************************************************************* */

/* GENERATED FROM abstract0.nw: DOT NOT MODIFY ! */


#ifndef _AP_ABSTRACT0_H_
#define _AP_ABSTRACT0_H_

#include "ap_manager.h"
#include "ap_expr0.h"

/* Generic abstract value at level 0 */
typedef struct ap_abstract0_t {
  void* value;    /* Abstract value of the underlying library */
  ap_manager_t* man; /* Used to identify the effective type of value */
} ap_abstract0_t;
@

%======================================================================
\section{Gestion mémoire, Représentations, Entrées/Sorties}
\label{sec:abstract0:management}
%======================================================================

<<*>>=

/* ********************************************************************** */
/* I. General management */
/* ********************************************************************** */
@

%----------------------------------------------------------------------
\point{Initialisation.} Elle se fait en allouant un manager.

%----------------------------------------------------------------------
\point{Gestion mémoire}

<<*>>=

/* ============================================================ */
/* I.1 Memory */
/* ============================================================ */

ap_abstract0_t* ap_abstract0_copy(ap_manager_t* man, const ap_abstract0_t* a);
  /* Return a copy of an abstract value, on
     which destructive update does not affect the initial value. */

void ap_abstract0_free(ap_manager_t* man, ap_abstract0_t* a);
  /* Free all the memory used by the abstract value */

size_t ap_abstract0_size(ap_manager_t* man, const ap_abstract0_t* a);
  /* Return the abstract size of an abstract value (see ap_manager_t) */

@

%----------------------------------------------------------------------
\point{Control of internal representation}

<<*>>=

/* ============================================================ */
/* I.2 Control of internal representation */
/* ============================================================ */


void ap_abstract0_minimize(ap_manager_t* man, const ap_abstract0_t* a);
  /* Minimize the size of the representation of a.
     This may result in a later recomputation of internal information.
  */


void ap_abstract0_canonicalize(ap_manager_t* man, const ap_abstract0_t* a);
  /* Put the abstract value in canonical form. (not yet clear definition) */


void ap_abstract0_approximate(ap_manager_t* man, ap_abstract0_t* a, int algorithm);
  /* Perform some transformation on the abstract value, guided by the
     field algorithm.

     The transformation may lose information.  The argument "algorithm"
     overrides the field algorithm of the structure of type ap_funopt_t
     associated to ap_abstract0_approximate (commodity feature). */


tbool_t ap_abstract0_is_minimal(ap_manager_t* man, const ap_abstract0_t* a);

tbool_t ap_abstract0_is_canonical(ap_manager_t* man, const ap_abstract0_t* a);
@

Les propriétés de la forme canonique ne sont pas encore bien
claires (\cf \sref{sec:normal}). On aimerait que par exemple la
sérialisation en binaire d'un objet canonique soit aussi
canonique.

%----------------------------------------------------------------------
\point{Impression.}

<<*>>=

/* ============================================================ */
/* I.3 Printing */
/* ============================================================ */


void ap_abstract0_fprint(FILE* stream,
                    ap_manager_t* man,
                    const ap_abstract0_t* a,
                    char** name_of_dim);
  /* Print the abstract value in a pretty way, using function
     name_of_dim to name dimensions */


void ap_abstract0_fprintdiff(FILE* stream,
                        ap_manager_t* man,
                        const ap_abstract0_t* a1, const ap_abstract0_t* a2,
                        char** name_of_dim);
  /* Print the difference between a1 (old value) and a2 (new value),
     using function name_of_dim to name dimensions.
     The meaning of difference is library dependent. */


void ap_abstract0_fdump(FILE* stream, ap_manager_t* man, const ap_abstract0_t* a);
  /* Dump the internal representation of an abstract value,
     for debugging purposes */
@

%----------------------------------------------------------------------
\point{Précisions sur les fonctions d'impressions.}  Le format des
fonctions d'impression est propre à chaque librairie: aucune
syntaxe n'est imposée, ne serait-ce que parce que la
représentation interne des nombres n'est pas unifiée.

Si l'on désire une syntaxe uniforme, il faut d'abord convertir en
contraintes/générateurs utilisateur.

\ref{super-treillis}

%----------------------------------------------------------------------
\point{Sérialisation}

La sérialisation/désérialisation en binaire, comme déjà mentionné,
ne fonctionne que pour la même librairie, compilée avec les mêmes
options de représentation interne des nombres.

Antoine Miné, dans ses octogones, a des fonctions de sérialisation
vers des zones mémoires (au lieu d'un fichier). C'est plus
général, et nécessaire, par exemple pour interfacer avec OCaml. On
ne propose donc que la sérialisation vers des zones mémoires,
l'utilisateur C pourra ensuite utiliser les fonctions [[fwrite]]
et [[fread]] pour transférer des zones mémoire de et vers un flux
entrée/sortie..

<<*>>=

/* ============================================================ */
/* I.4 Serialization */
/* ============================================================ */


ap_membuf_t ap_abstract0_serialize_raw(ap_manager_t* man, const ap_abstract0_t* a);
/* Allocate a memory buffer (with malloc), output the abstract value in raw
   binary format to it and return a pointer on the memory buffer and the size
   of bytes written.  It is the user responsability to free the memory
   afterwards (with free). */


ap_abstract0_t* ap_abstract0_deserialize_raw(ap_manager_t* man, void* ptr, size_t* size);
/* Return the abstract value read in raw binary format from the input stream
   and store in size the number of bytes read */
@


%======================================================================
\section{Constructeurs, accesseurs, tests et extraction de propriétés}
\label{sec:constructor}
%======================================================================

%----------------------------------------------------------------------
\point{Basic constructors}

<<*>>=

/* ********************************************************************** */
/* II. Constructor, accessors, tests and property extraction */
/* ********************************************************************** */

/* ============================================================ */
/* II.1 Basic constructors */
/* ============================================================ */

/* We assume that dimensions [0..intdim-1] correspond to integer variables, and
   dimensions [intdim..intdim+realdim-1] to real variables */

ap_abstract0_t* ap_abstract0_bottom(ap_manager_t* man, size_t intdim, size_t realdim);
  /* Create a bottom (empty) value */


ap_abstract0_t* ap_abstract0_top(ap_manager_t* man, size_t intdim, size_t realdim);
  /* Create a top (universe) value */
@

On pourrait aussi rajouter les deux fonctions suivantes (qui
peuvent être vues comme des fonctions de conversion).

<<*>>=

ap_abstract0_t* ap_abstract0_of_box(ap_manager_t* man,
                              size_t intdim, size_t realdim,
                              const ap_interval_t*const* tinterval);
  /* Abstract an hypercube defined by the array of intervals
     of size intdim+realdim */


ap_abstract0_t* ap_abstract0_of_lincons_array(ap_manager_t* man,
                                        size_t intdim, size_t realdim,
                                        const ap_lincons0_array_t* array);
  /* Abstract a convex polyhedra defined by the array of (interval) linear
     constraints of size size */
@

[[ap_abstract0_of_box]] permet d'abstraire assez aisément un point de
l'espace.

[[ap_abstract0_of_lincons_array]] est redondant si l'on dispose de
[[ap_abstract0_meet_lincons_array]] (ou autre nom,
[[ap_abstract0_meet_polyhedra]]), puisqu'il suffit alors de créer la
valeur top puis d'appeler [[ap_abstract0_meet_lincons_array]] avec
l'ensemble des contraintes.

%----------------------------------------------------------------------
\point{Accessors}

<<*>>=

/* ============================================================ */
/* II.2 Accessors */
/* ============================================================ */

ap_dimension_t ap_abstract0_dimension(ap_manager_t* man, const ap_abstract0_t* a);
  /* Return the dimensionality of the abstract values */
@


%----------------------------------------------------------------------
\point{Tests}

<<*>>=

/* ============================================================ */
/* II.3 Tests */
/* ============================================================ */

/* If any of the following functions returns tbool_top, this means that
   an exception has occured, or that the exact computation was
   considered too expensive to be performed (according to the options).
   The flag exact and best should be cleared in such a case. */


tbool_t ap_abstract0_is_bottom(ap_manager_t* man, const ap_abstract0_t* a);

tbool_t ap_abstract0_is_top(ap_manager_t* man, const ap_abstract0_t* a);


tbool_t ap_abstract0_is_leq(ap_manager_t* man, const ap_abstract0_t* a1, const ap_abstract0_t* a2);
  /* inclusion check */


tbool_t ap_abstract0_is_eq(ap_manager_t* man, const ap_abstract0_t* a1, const ap_abstract0_t* a2);
  /* equality check */


tbool_t ap_abstract0_sat_lincons(ap_manager_t* man, const ap_abstract0_t* a, const ap_lincons0_t* lincons);
  /* does the abstract value satisfy the (interval) linear constraint ? */


tbool_t ap_abstract0_sat_interval(ap_manager_t* man, const ap_abstract0_t* a,
                              ap_dim_t dim, const ap_interval_t* interval);
  /* is the dimension included in the interval in the abstract value ? */


tbool_t ap_abstract0_is_dimension_unconstrained(ap_manager_t* man, const ap_abstract0_t*
                                             a, ap_dim_t dim); /* is the dimension
                                             unconstrained in the abstract
                                             value ?  If it is the case, we
                                             have forget(man,a,dim) == a */
@

\point{Le problème du test du vide avec les entiers.}
Que doit retourner [[ap_abstract0_is_bottom]] si les entiers
ne sont que partiellement pris en compte ? Si un polyèdre n'est
pas vide en rationnel, on peut retourner:
\begin{itemize}
\item [[tbool_false]] avec le flag [[flag_exact]] à
  [[tbool_false]] ou [[tbool_top]];
\item [[tbool_true]] avec le flag [[flag_exact]] à [[tbool_false]]
  ou [[tbool_top]];
\item [[tbool_top]] avec le flag [[flag_exact]] à n'importe quelle
  valeur
\item \ldots
\end{itemize}

En fait, la redondance illustrée ci-dessus entre la valeur
retournée et le flag [[flag_exact]] est générale à tous les tests.

Comment faire si on veut juste savoir si un polyèdre sur des
dimensions déclarées entières est vide ou non au sens des
rationnels ? Dans \textsc{NewPolka}, on utilise quand-même le
typage des dimensions pour nier les contraintes, mais pour le
reste on ne considère que des rationnels. Bref, sur les
expressions, on type en entier, mais sur les polyèdres, on type en
réel.


%----------------------------------------------------------------------
\point{Extraction de propriétés}

<<*>>=

/* ============================================================ */
/* II.4 Extraction of properties */
/* ============================================================ */


ap_interval_t* ap_abstract0_bound_linexpr(ap_manager_t* man,
                                    const ap_abstract0_t* a, const ap_linexpr0_t* expr);
  /* Returns the interval taken by a linear expression
     over the abstract value */


ap_interval_t* ap_abstract0_bound_dimension(ap_manager_t* man,
                                      const ap_abstract0_t* a, ap_dim_t dim);
  /* Returns the interval taken by the dimension
     over the abstract value */


ap_lincons0_array_t ap_abstract0_to_lincons_array(ap_manager_t* man, const ap_abstract0_t* a);
  /* Converts an abstract value to a polyhedra
     (conjunction of linear constraints).

     The constraints are normally guaranteed to be really linear (without intervals) */


ap_interval_t** ap_abstract0_to_box(ap_manager_t* man, const ap_abstract0_t* a);
  /* Converts an abstract value to an interval/hypercube.
     The size of the resulting array is ap_abstract0_dimension(man,a).  This
     function can be reimplemented by using ap_abstract0_bound_linexpr */


ap_generator0_array_t ap_abstract0_to_generator_array(ap_manager_t* man, const ap_abstract0_t* a);
  /* Converts an abstract value to a system of generators. */

@

%======================================================================
\section{Opérations}
\label{sec:operationfun}
%======================================================================

La plupart des opérations sont offertes en 2 versions:
fonctionnelle ou destructrice.  On utilise un booléen por
distinguer les 2 sémantiques. La sémantique destructrice est la
suivante: après l'appel, la première valeur abstraite de la
fonction est détruite, et ne doit plus être manipulée ni
référencée. Il est possible que la valeur retournée par la
fonction soit la même que l'argument, mais il faut la manipuler
via la valeur retournée.

%----------------------------------------------------------------------
\point{Bornes supérieures et inférieures}

<<*>>=

/* ********************************************************************** */
/* III. Operations: functional version */
/* ********************************************************************** */

/* ============================================================ */
/* III.1 Meet and Join */
/* ============================================================ */


ap_abstract0_t* ap_abstract0_meet(ap_manager_t* man, bool destructive, ap_abstract0_t* a1, const ap_abstract0_t* a2);

ap_abstract0_t* ap_abstract0_join(ap_manager_t* man, bool destructive, ap_abstract0_t* a1, const ap_abstract0_t* a2);
  /* Meet and Join of 2 abstract values */


ap_abstract0_t* ap_abstract0_meet_array(ap_manager_t* man, const ap_abstract0_t*const* tab, size_t size);

ap_abstract0_t* ap_abstract0_join_array(ap_manager_t* man, const ap_abstract0_t*const* tab, size_t size);
  /* Meet and Join of an array of abstract values.
     Raises an [[exc_invalid_argument]] exception if [[size==0]]
     (no way to define the dimensionality of the result in such a case */


ap_abstract0_t* ap_abstract0_meet_lincons_array(ap_manager_t* man,
                                          bool destructive,
                                          ap_abstract0_t* a,
                                          const ap_lincons0_array_t* array);
  /* Meet of an abstract value with a set of constraints */


ap_abstract0_t* ap_abstract0_add_ray_array(ap_manager_t* man,
                                     bool destructive,
                                     ap_abstract0_t* a,
                                     const ap_generator0_array_t* array);
  /* Generalized time elapse operator */
@

Discussion sur [[ap_abstract0_meet_lincons_array]]:
\begin{itemize}
\item Plus général que [[ap_abstract0_of_lincons_array]], \cf
\sref{sec:constructor}.
\item Même si implanté par appel successifs à
[[ap_abstract0_meet_lincons]], les appels intermédiaires peuvent
utiliser des effets de bord.
\item Dans le cas des polyèdres, plus efficace que des appels
successifs, et plus efficace qu'appeler
[[ap_abstract0_of_lincons_array]] et faire l'intersection.
\end{itemize}

%----------------------------------------------------------------------
\point{Affectations et Substitutions.}

Il a été décidé de ne pas implanter les \emph{weak
update}. D'après Antoine Miné, cela ne va pas assez loin. D'apères
Bertrand Jeannet,, Reps, Sagiv \& al ne l'utilise pas. Les
\emph{weak update} peuvent par ailleurs être implantés à partir
des opérations ci-dessus.  En revanche, l'expansion et le pliage
de dimension est fourni pour autoriser la notion de \emph{weak
update} à un niveau supérieur, voir la suite.

<<*>>=

/* ============================================================ */
/* III.2 Assignement and Substitutions */
/* ============================================================ */


ap_abstract0_t* ap_abstract0_assign_linexpr(ap_manager_t* man,
                                      bool destructive,
                                      ap_abstract0_t* org,
                                      ap_dim_t dim, const ap_linexpr0_t* expr,
                                      const ap_abstract0_t* dest);

ap_abstract0_t* ap_abstract0_substitute_linexpr(ap_manager_t* man,
                                          bool destructive,
                                          ap_abstract0_t* org,
                                          ap_dim_t dim, const ap_linexpr0_t* expr,
                                          const ap_abstract0_t* dest);
  /* Assignement and Substitution of a single dimension by a (interval)
     linear expression in abstract value org. 
     
     dest is an optional argument. If not NULL, semantically speaking,
     the result of the transformation is intersected with dest. This is
     useful for precise backward transformations in lattices like intervals or 
     octagons.
 */


ap_abstract0_t* ap_abstract0_assign_linexpr_array(ap_manager_t* man,
                                            bool destructive,
                                            ap_abstract0_t* org,
                                            const ap_dim_t* tdim,
                                            const ap_linexpr0_t*const* texpr,
                                            size_t size,
                                            const ap_abstract0_t* dest);

ap_abstract0_t* ap_abstract0_substitute_linexpr_array(ap_manager_t* man,
                                                bool destructive,
                                                ap_abstract0_t* org,
                                                const ap_dim_t* tdim,
                                                const ap_linexpr0_t*const* texpr,
                                                size_t size,
                                                const ap_abstract0_t* dest);
  /* Parallel Assignement and Substitution of several dimensions by
     linear expressions in abstract value org. 
     
     dest is an optional argument. If not NULL, semantically speaking,
     the result of the transformation is intersected with dest. This is
     useful for precise backward transformations in lattices like intervals or 
     octagons. */
@

%----------------------------------------------------------------------
\point{Projections et Quantifications existentielles.}

<<*>>=

/* ============================================================ */
/* III.3 Projections */
/* ============================================================ */

ap_abstract0_t* ap_abstract0_forget_array(ap_manager_t* man,
                                    bool destructive,
                                    ap_abstract0_t* a, const ap_dim_t* tdim, size_t size,
                                    bool project);
@
Questions:
\begin{itemize}
\item Peut-on distinguer [[projet]] de [[forget]] juste avec un flag histoire de diminuer le nombre de fonctions ? + voir remarque suivante.
\item Dans tous les treillis envisagés, [[project]] peut
s'implanter à partir de [[forget]] suivi d'une affectation à
zéro. La réciproque est vraie, en utilisant [[add_ray_array]],
mais c'est sans doute plus compliqué pour pas mal de treillis.
\item Nommage de [[forget]]: on peut aussi l'appeler [[exist]]. De
manière générale, doit-on utiliser un vocabulaire mathématique
([[exist]], [[least upper bound]], \ldots) ou le vocabulaire
d'usage, notamment outre-atlantique ([[forget]], [[join]], \ldots)
?
\end{itemize}

%----------------------------------------------------------------------
\point{Changement et Permutations de dimensions.}

On fournit seulement des fonctions générales, permettant d'effectuer des
permutations et nécessaires pour le niveau 1 de l'interface.

On pourra éventuellement ajouter des fonctions plus simples, mais
peut-on espérer un gain en efficacité réel ? Sinon, comme on ne se
préoccupe pas du confort à ce niveau, autant en rester là.

Question identique à celle du paragraphe précédent: utilise-t-on
un flag pour distinguer [[project]] de [[forget]] ou [[embed]] ?

<<*>>=

/* ============================================================ */
/* III.4 Change and permutation of dimensions */
/* ============================================================ */

ap_abstract0_t* ap_abstract0_add_dimensions(ap_manager_t* man,
                                      bool destructive,
                                      ap_abstract0_t* a,
                                      ap_dimchange_t* dimchange);
ap_abstract0_t* ap_abstract0_remove_dimensions(ap_manager_t* man,
                                         bool destructive,
                                         ap_abstract0_t* a,
                                         ap_dimchange_t* dimchange);
/* Size of the permutation is supposed to be equal to
   the dimension of the abstract value */
ap_abstract0_t* ap_abstract0_permute_dimensions(ap_manager_t* man,
                                          bool destructive,
                                          ap_abstract0_t* a,
                                          const ap_dimperm_t* perm);
@

%----------------------------------------------------------------------
\point{Expansion et pliage}

Il a été décidé de fournir au niveau 0 un support pour l'expansion
et le pliage de dimensions.

Formellement, la sémantique concrète est la suivante (sachant que
ces opérations sont associatives, et que $z$ est expansé en $z$ et
$w$, puis $z$ et $w$ plié sur $z$):
\begin{eqnarray}
  \mathsf{expand}\bigl(P(x,y,z),z,w\bigr) &=& P(x,y,z) \wedge P(x,y,w) \\
  \mathsf{fold}\bigl((Q(x,y,z,w),z,w\bigr) &=& \bigl(\exists w:Q(x,y,z,w)\bigr) \vee \bigl(\exists z:Q(x,y,z,w)\bigr)[z\leftarrow w]
\end{eqnarray}

Là encore, ces opérations ne sont pas minimales, mais pour des
raisons de performances il semble que ça vaille le coup de fournir
des opérations spécifiques.

<<*>>=

/* ============================================================ */
/* III.5 Expansion and folding of dimensions */
/* ============================================================ */


ap_abstract0_t* ap_abstract0_expand(ap_manager_t* man,
                              bool destructive,
                              ap_abstract0_t* a,
                              ap_dim_t dim,
                              size_t n);
  /* Expand the dimension dim into itself + n additional dimensions.
     It results in (n+1) unrelated dimensions having same
     relations with other dimensions. The (n+1) dimensions are put as follows:

     - original dimension dim

     - if the dimension is integer, the n additional dimensions are put at the
       end of integer dimensions; if it is real, at the end of the real
       dimensions.
  */


ap_abstract0_t* ap_abstract0_fold(ap_manager_t* man,
                            bool destructive,
                            ap_abstract0_t* a,
                            const ap_dim_t* tdim,
                            size_t size);
  /* Fold the dimensions in the array tdim of size n>=1 and put the result
     in the first dimension in the array. The other dimensions of the array
     are then removed (using ap_abstract0_permute_remove_dimensions). */
@

%----------------------------------------------------------------------
\point{Élargissement.}

<<*>>=

/* ============================================================ */
/* III.6 Widening */
/* ============================================================ */

ap_abstract0_t* ap_abstract0_widening(ap_manager_t* man,
                                const ap_abstract0_t* a1, const ap_abstract0_t* a2);
@

%----------------------------------------------------------------------
\point{Clôture topologique.}

Il faut décider si l'on traite les contraintes strictes.
\bj{Ça ne mange pas de pain, il reste toujours la possibilité
d'ignorer le caractère stricte d'une contrainte pour une
implantation particulière}.

<<*>>=

/* ============================================================ */
/* III.7 Closure operation */
/* ============================================================ */

/* Returns the topological closure of a possibly opened abstract value */


ap_abstract0_t* ap_abstract0_closure(ap_manager_t* man, bool destructive, ap_abstract0_t* a);
@

%======================================================================
\section{Fonctions communes aux niveau 0}
%======================================================================

On définit ici les fonctions qui n'ont pas d'équivalent dans les
librairies sous-jacentes, et qui sont factorisées entre ces librairies.


<<*>>=
/* ********************************************************************** */
/* ********************************************************************** */
/* Additional functions */
/* ********************************************************************** */
/* ********************************************************************** */
static inline 
ap_manager_t* ap_abstract0_manager(const ap_abstract0_t* a)
  { return a->man; }
  /* Return a reference to the manager contained in the abstract value.
     The reference should not be freed */

/* Widening with threshold */

ap_abstract0_t* ap_abstract0_widening_threshold(ap_manager_t* man,
                                const ap_abstract0_t* a1, const ap_abstract0_t* a2,
                                ap_lincons0_array_t* array);

ap_linexpr0_t* ap_abstract0_quasilinear_of_intervallinear(ap_manager_t* man,
                                                    const ap_abstract0_t* a,
                                                    ap_linexpr0_t* expr);
  /* Evaluate a interval linear expression on the abstract 
     value such as to transform it into a quasilinear expression. 

     This implies calls to ap_abstract0_bound_dimension.

     NOT YET IMPLEMENTED
  */
@

%======================================================================
\section{Fonctions internes pour le niveau 1}
%======================================================================

On définit ici des fonctions utiles pour le niveau 1.

<<*>>=
/* ********************************************************************** */
/* ********************************************************************** */
/* Internal functions */
/* ********************************************************************** */
/* ********************************************************************** */

ap_abstract0_t* ap_abstract0_meetjoin(ap_funid_t funid,
                                ap_manager_t* man, bool destructive, 
                                ap_abstract0_t* a1, const ap_abstract0_t* a2);
ap_abstract0_t* ap_abstract0_asssub_linexpr(ap_funid_t funid, 
                                      /* either assign or substitute */
                                      ap_manager_t* man,
                                      bool destructive,
                                      ap_abstract0_t* a,
                                      ap_dim_t dim, const ap_linexpr0_t* expr,
                                      const ap_abstract0_t* dest);
ap_abstract0_t* ap_abstract0_asssub_linexpr_array(ap_funid_t funid,
                                            ap_manager_t* man,
                                            bool destructive,
                                            ap_abstract0_t* a,
                                            const ap_dim_t* tdim,
                                            const ap_linexpr0_t*const* texpr,
                                            size_t size,
                                            const ap_abstract0_t* dest);
@


<<*>>=
#endif
@
