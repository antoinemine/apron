/* -*- mode: c -*- */

/* ************************************************************************* */
/* ap_coeff.c: coefficients, that are either scalars or intervals */
/* ************************************************************************* */

/* This file is part of the APRON Library, released under LGPL license.  Please
   read the COPYING file packaged in the distribution */

#include <stdlib.h>
#include <math.h>
#include <limits.h>
#include <assert.h>

#include "ap_coeff.h"
#include "eitv_all.h"
#include "num_conv.h"

/* ====================================================================== */
/* Basics */
/* ====================================================================== */

void ap_coeff_init(ap_coeff_t a, ap_scalar_discr_t discr)
{
  a->discr = discr;
  MACRO_SWITCH(discr) XXX
    a->eitv.XXX = eitvXXX_alloc();
  ENDMACRO;
}

void ap_coeff_init_set(ap_coeff_t a, ap_coeff_t b)
{
  a->discr = b->discr;
  MACRO_SWITCH(b->discr) XXX
    a->eitv.XXX = eitvXXX_alloc_set(b->eitv.XXX);
  ENDMACRO;
}

MACRO_FOREACH ZZZ @MainNum
void ap_coeff_init_set_eitvZZZ(ap_coeff_t a, eitvZZZ_t eitv)
{
  a->discr = AP_SCALAR_ZZZ;
  eitvZZZ_init_set(a->eitv.ZZZ,eitv);
}
ENDMACRO

void ap_coeff_clear(ap_coeff_t a)
{
  MACRO_SWITCH(a->discr) XXX
    eitvXXX_clear(a->eitv.XXX);
  ENDMACRO;
}
void ap_coeff_fprint(FILE* stream, ap_coeff_t a)
{
  MACRO_SWITCH(a->discr) XXX
    eitvXXX_fprint(stream,a->eitv.XXX);
  ENDMACRO;
}
void ap_coeff_set_int(ap_coeff_t a, int b)
{
  MACRO_SWITCH(a->discr) XXX
    eitvXXX_set_int(a->eitv.XXX,b);
  ENDMACRO;
}
bool ap_coeff_set(ap_coeff_t a, ap_coeff_t b, num_internal_t intern)
{
  bool res;
  if (a->discr==b->discr){
    MACRO_SWITCH(a->discr) XXX
      eitvXXX_set(a->eitv.XXX,b->eitv.XXX);
    ENDMACRO;
    return true;
  }
  else {
    MACRO_SWITCH(a->discr) XXX
      res = eitvXXX_set_ap_coeff(a->eitv.XXX,b,intern);
    ENDMACRO;
    return res;
  }
}
void ap_coeff_set_top(ap_coeff_t a)
{
  MACRO_SWITCH(a->discr) XXX
    eitvXXX_set_top(a->eitv.XXX);
  ENDMACRO;
}
void ap_coeff_set_bottom(ap_coeff_t a)
{
  MACRO_SWITCH(a->discr) XXX
    eitvXXX_set_bottom(a->eitv.XXX);
  ENDMACRO;
}

/* ====================================================================== */
/* Conversions */
/* ====================================================================== */

MACRO_FOREACH XXX @AllNum
bool ap_coeff_set_eitvXXX(ap_coeff_t a, eitvXXX_t b, num_internal_t intern)
{
  MACRO_SWITCH(a->discr) ZZZ
    return eitvZZZ_set_eitvXXX(a->eitv.ZZZ,b,intern);
  ENDMACRO
}
bool eitvXXX_set_ap_coeff(eitvXXX_t a, ap_coeff_t b, num_internal_t intern)
{
  MACRO_SWITCH(b->discr) ZZZ
    return eitvXXX_set_eitvZZZ(a,b->eitv.ZZZ,intern);
  ENDMACRO
}
ENDMACRO

bool ap_coeff_set_generic(num_internal_t intern,
			  ap_coeff_t a, ap_coeff_tag_t tag, va_list* va)
{
  bool res;
  if (tag<AP_COEFF || tag>=AP_CST){
    fprintf(stderr,
	    "ap_coeff_set_generic: unknown tag\n");
    abort();
  }
  if (tag==AP_COEFF){
    ap_coeff_ptr b = va_arg(*va,ap_coeff_ptr);
    res = ap_coeff_set(a,b,intern);
  }
  else {
    MACRO_SWITCH(a->discr) XXX
      res = eitvXXX_set_generic(intern,a->eitv.XXX,(eitv_tag_t)tag,va);
    ENDMACRO;
  }
  return res;
}
bool ap_coeff_set_val(num_internal_t intern,
		      ap_coeff_t a, ap_coeff_tag_t tag, ...)
{
  va_list va;
  bool res;
  va_start(va,tag);
  res = ap_coeff_set_generic(intern,a,tag,&va);
  va_end(va);
  return res;
}
/* ====================================================================== */
/* Tests */
/* ====================================================================== */

bool ap_coeff_is_point(ap_coeff_t a)
{
  bool res;
  MACRO_SWITCH(a->discr) XXX
    res = eitvXXX_is_point(a->eitv.XXX);
  ENDMACRO;
  return res;
}
bool ap_coeff_is_zero(ap_coeff_t a)
{
  bool res;
  MACRO_SWITCH(a->discr) XXX
    res = eitvXXX_is_zero(a->eitv.XXX);
  ENDMACRO;
  return res;
}
bool ap_coeff_is_pos(ap_coeff_t a)
{
  bool res;
  MACRO_SWITCH(a->discr) XXX
    res = eitvXXX_is_pos(a->eitv.XXX);
  ENDMACRO;
  return res;
}
bool ap_coeff_is_neg(ap_coeff_t a)
{
  bool res;
  MACRO_SWITCH(a->discr) XXX
    res = eitvXXX_is_neg(a->eitv.XXX);
  ENDMACRO;
  return res;
}
bool ap_coeff_is_top(ap_coeff_t a)
{
  bool res;
  MACRO_SWITCH(a->discr) XXX
    res = eitvXXX_is_top(a->eitv.XXX);
  ENDMACRO;
  return res;
}
bool ap_coeff_is_bottom(ap_coeff_t a, num_internal_t num)
{
  bool res;
  MACRO_SWITCH(a->discr) XXX
    res = eitvXXX_is_bottom(a->eitv.XXX,num);
  ENDMACRO;
  return res;
}
bool ap_coeff_is_eq(ap_coeff_t a, ap_coeff_t b)
{
  bool res;
  if (a==b) return true;
  if (a->discr==b->discr){
    MACRO_SWITCH(a->discr) XXX
      res = eitvXXX_is_eq(a->eitv.XXX,b->eitv.XXX);
    ENDMACRO;
    return res;
  }
  else {
    return false;
  }
}
int ap_coeff_cmp(ap_coeff_t a, ap_coeff_t b)
{
  bool res;
  if (a==b) return 0;
  if (a->discr==b->discr){
    MACRO_SWITCH(a->discr) XXX
      res = eitvXXX_cmp(a->eitv.XXX,b->eitv.XXX);
    ENDMACRO;
    return res;
  }
  else {
    return a>b ? 3 : -3;
  }
}

/* ====================================================================== */
/* Other operations */
/* ====================================================================== */

/* Hash */
long ap_coeff_hash(ap_coeff_t a)
{
  long res;
  MACRO_SWITCH(a->discr) XXX
    res = eitvXXX_hash(a->eitv.XXX);
  ENDMACRO;
  return res;
}
