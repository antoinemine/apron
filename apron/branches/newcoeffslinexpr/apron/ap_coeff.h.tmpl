/* -*- mode: c -*- */

/* ************************************************************************* */
/* ap_coeff.h: coefficients, that are either scalars or intervals */
/* ************************************************************************* */

/* This file is part of the APRON Library, released under LGPL license.  Please
   read the COPYING file packaged in the distribution */

#ifndef _AP_COEFF_H_
#define _AP_COEFF_H_

#include <assert.h>
#include <math.h>
#include <stdio.h>

#include "ap_config.h"
#include "itv_types.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef enum ap_scalar_discr_t {
  AP_SCALAR_D,      /* double-precision floating-point number */
  AP_SCALAR_MPQ,    /* GMP arbitrary precision rational */
  AP_SCALAR_MPFR,   /* MPFR floating-point number */
} ap_scalar_discr_t;

typedef struct ap_coeff_struct {
  ap_scalar_discr_t discr; /* discriminant for coefficient */
  union {
    eitvD_ptr    D;
    eitvMPQ_ptr  MPQ;
    eitvMPFR_ptr MPFR;
  } eitv;
} ap_coeff_struct;

typedef ap_coeff_struct* ap_coeff_ptr;
typedef ap_coeff_struct ap_coeff_t[1];

typedef enum ap_coeff_tag_t {
  ITV_COEFF,    /* waiting for 1 ap_coeff_t* and a dimension */
  ITV_EITVD,    /* waiting for 1 eitvD_t and a dimension */
  ITV_EITVMPQ,  /* waiting for 1 eitvMPQ_t and a dimension */
  ITV_EITVMPFR, /* waiting for 1 eitvMPFR_t and a dimension */
  ITV_NUMD,     /* waiting for 1 numD_t and a dimension */
  ITV_NUMMPQ,   /* waiting for 1 numMPQ_t and a dimension */
  ITV_NUMMPFR,  /* waiting for 1 numMPFR_t and a dimension */
  ITV_NUMD2,    /* waiting for 2 numD_t and a dimension */
  ITV_NUMMPQ2,  /* waiting for 2 numMPQ_t and a dimension */
  ITV_NUMMPFR2, /* waiting for 2 numMPFR_t and a dimension */
  ITV_LINT,     /* waiting for 1 long int and a dimension */
  ITV_LINT2,    /* waiting for 2 long int and a dimension */
  ITV_LLINT,    /* waiting for 1 long long int and a dimension */
  ITV_LLINT2,   /* waiting for 2 long long int and a dimension */
  ITV_MPZ,      /* waiting for 1 mpz_t and a dimension */
  ITV_MPZ2,     /* waiting for 2 mpz_t and a dimension */
  ITV_LFRAC,    /* waiting for 2 long int and a dimension */
  ITV_LFRAC2,   /* waiting for 4 long int and a dimension */
  ITV_LLFRAC,   /* waiting for 2 long long int and a dimension */
  ITV_LLFRAC2,  /* waiting for 4 long long int and a dimension */
  ITV_MPQ,      /* waiting for 1 mpq_t and a dimension */
  ITV_MPQ2,     /* waiting for 2 mpq_t and a dimension */
  ITV_DOUBLE,   /* waiting for 1 double and a dimension */
  ITV_DOUBLE2,  /* waiting for 2 double and a dimension */
  ITV_LDOUBLE,  /* waiting for 1 long double and a dimension */
  ITV_LDOUBLE2, /* waiting for 2 long double and a dimension */
  ITV_MPFR,     /* waiting for 1 mpfr_t and a dimension */
  ITV_MPFR2,    /* waiting for 2 mpfr_t double and a dimension */
  ITV_END
} ap_coeff_tag_t;

/* ====================================================================== */
/* Basics */
/* ====================================================================== */

void ap_coeff_init(ap_coeff_t coeff, ap_scalar_discr_t discr);
void ap_coeff_init_set(ap_coeff_t coeff, ap_coeff_t coeff2);
MACRO_MAINZ
void ap_coeff_init_set_eitvZZZ(ap_coeff_t coeff, eitvZZZ_t eitv);
ENDMACRO
void ap_coeff_clear(ap_coeff_t coeff);
void ap_coeff_fprint(FILE* stream, ap_coeff_t a);
static inline void ap_coeff_print(ap_coeff_t a);

bool ap_coeff_set(ap_coeff_t a, ap_coeff_t b, num_internal_t intern);
void ap_coeff_set_int(ap_coeff_t a, int b);
void ap_coeff_set_bottom(ap_coeff_t coeff);
void ap_coeff_set_top(ap_coeff_t coeff);

static inline void ap_coeff_swap(ap_coeff_t a, ap_coeff_t b)
{ ap_coeff_struct t = *a; *a = *b; *b = t; }
  /* Exchange */

/* ====================================================================== */
/* Conversions */
/* ====================================================================== */

MACRO_ALLZ
bool ap_coeff_set_eitvZZZ(ap_coeff_t a, eitvZZZ_t b, num_internal_t intern);
bool eitvZZZ_set_ap_coeff(eitvZZZ_t a, ap_coeff_t b, num_internal_t intern);
ENDMACRO
  /* Return true if conversion is exact */

/* ====================================================================== */
/* Tests */
/* ====================================================================== */
bool ap_coeff_is_point(ap_coeff_t a);
  /* Return true iff the interval is a single point */
bool ap_coeff_is_zero(ap_coeff_t a);
  /* Return true iff the interval is a single zero point */
bool ap_coeff_is_pos(ap_coeff_t a);
bool ap_coeff_is_neg(ap_coeff_t a);
  /* Included in [0;+oo], [-oo;0], or any of those */
bool ap_coeff_is_top(ap_coeff_t a);
  /* Return true iff the interval is resp. [-oo,+oo] */
bool ap_coeff_is_eq(ap_coeff_t a, ap_coeff_t b);

/* ====================================================================== */
/* Other operations */
/* ====================================================================== */

long ap_coeff_hash(ap_coeff_t coeff);
  /* Hash code */

/* ====================================================================== */
/* FOR INTERNAL USE ONLY */
/* ====================================================================== */

static inline void ap_coeff_print(ap_coeff_t a)
{ ap_coeff_fprint(stdout,a); }
  /* Printing */

MACRO_MAINZ
static inline void ap_coeff_cons_ZZZ(ap_coeff_t res, eitvZZZ_t e)
{ res->discr = AP_SCALAR_ZZZ; res->eitv.ZZZ = e; };
ENDMACRO

#ifdef __cplusplus
}
#endif

#endif
