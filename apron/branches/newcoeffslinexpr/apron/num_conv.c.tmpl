/* -*- mode: c -*- */
/* ********************************************************************** */
/* num_conv.c */
/* ********************************************************************** */

#include "num_conv.h"
#include "eitv_all.h"
#include <float.h>

#define NUM_CONTINUED_FRACTION_SIZE 10
#define NUM_CONTINUED_FRACTION_RATIO 2

  /* For conversions from double to rationals */

/* ********************************************************************** */
/* I. numXXX */
/* ********************************************************************** */

/* ====================================================================== */
/* 1. numIyyy_t */
/* ====================================================================== */

MACRO_FOREACH yyy ("l","ll")
extern inline bool numIl_fits_numIyyy(numIl_t a, num_internal_t intern)
{ return true; }
extern inline bool numRl_fits_numIyyy(numRl_t a, num_internal_t intern)
{ return true; }
bool numMPQ_fits_numIyyy(numMPQ_t a, num_internal_t intern)
{
  size_t n = mpz_sizeinbase(mpq_numref(a),2);
  size_t d = mpz_sizeinbase(mpq_denref(a),2);
  return ((int)n - (int)d) <= (int)(sizeof(numIyyy_t)*8-3);
}
extern inline bool numD_fits_numIyyy(numD_t a, num_internal_t intern)
{
  return isfinite(*a) && *a>=(double)(-NUMIyyy_MAX) && *a<=(double)NUMIyyy_MAX;
}
extern inline bool numDl_fits_numIyyy(numDl_t a, num_internal_t intern)
{
  return isfinite(*a) && *a>=(long double)(-NUMIyyy_MAX) && *a<=(long double)NUMIyyy_MAX;
}
ENDMACRO

extern inline bool numIll_fits_numIl(numIll_t a, num_internal_t intern)
{ return *a>=-NUMIl_MAX && *a<=NUMIl_MAX; }
extern inline bool numMPZ_fits_numIl(mpz_t a, num_internal_t intern)
{ return mpz_fits_slong_p(a); }
extern inline bool numRll_fits_numIl(numRll_t a, num_internal_t intern)
{
  long long int i = *a->n;
  long long int j = *a->d;
  long long int n = i>=0 ? (i+j-1)/j : i/j;
  return numIll_fits_numIl(&n,intern);
}
extern inline bool numMPFR_fits_numIl(numMPFR_t a, num_internal_t intern)
{
  return mpfr_number_p(a) && mpfr_fits_slong_p(a,GMP_RNDU);
}

extern inline bool numIll_fits_numIll(numIll_t a, num_internal_t intern)
{ return true; }
extern inline bool numMPZ_fits_numIll(numMPZ_t a, num_internal_t intern)
{
  size_t size = mpz_sizeinbase(a,2);
  return (size <= sizeof(numIll_t)*8-1);
}
extern inline bool numRll_fits_numIll(numRll_t a, num_internal_t intern)
{ return true; }
extern inline bool numMPFR_fits_numIll(numMPFR_t a, num_internal_t intern)
{
  return mpfr_number_p(a) && mpfr_fits_intmax_p(a,GMP_RNDU);
}

MACRO_FOREACH yyy ("l","ll")
extern inline bool numIyyy_fits_numMPZ(numIyyy_t a, num_internal_t intern)
{ return true; }
extern inline bool numIyyy_fits_numRl(numIyyy_t a, num_internal_t intern)
{ return numIyyy_fits_numIl(a,intern); }
extern inline bool numIyyy_fits_numRll(numIyyy_t a, num_internal_t intern)
{ return true; }
extern inline bool numIyyy_fits_numMPQ(numIyyy_t a, num_internal_t intern)
{ return true; }
extern inline bool numIyyy_fits_numD(numIyyy_t a, num_internal_t intern)
{ return true; }
extern inline bool numIyyy_fits_numDl(numIyyy_t a, num_internal_t intern)
{ return true; }
extern inline bool numIyyy_fits_numMPFR(numIyyy_t a, num_internal_t intern)
{ return true; }

extern inline bool numIyyy_set_numIl(numIyyy_t a, numIl_t b, num_internal_t intern)
{ *a = *b; return true; }
extern inline bool numIyyy_set_numIll(numIyyy_t a, numIll_t b, num_internal_t intern)
{ *a = *b; return true; }
extern inline bool numIyyy_set_numRl(numIyyy_t a, numRl_t b, num_internal_t intern)
{
  long int i = *b->n;
  long int j = *b->d;
  assert(j>0);
  if (i>=0) *a = (i+j-1)/j;
  else *a = i/j;
  return (i%j==0);
}
extern inline bool numIyyy_set_numRll(numIyyy_t a, numRll_t b, num_internal_t intern)
{
  long long int i = *b->n;
  long long int j = *b->d;
  long long int t;
  assert(j>0);
  t = i>=0 ? (i+j-1)/j : i/j;
  return numIyyy_set_numIll(a,&t,intern) && i%j==0;
}
ENDMACRO

extern inline bool numIl_set_numMPZ(numIl_t a, numMPZ_t b, num_internal_t intern)
{
  *a = mpz_get_si(b);
  return true;
}
bool numIll_set_numMPZ(numIll_t a, numMPZ_t b, num_internal_t intern)
{
  int sgn;
  size_t count;
  unsigned long int tab[2];
  bool res;

  sgn = mpz_sgn(b);
  mpz_export(&tab,&count,1,sizeof(long int),0,0,b);
  if (count==0){
    *a = 0;
    res = true;
  }
  else {
    const int dec =
      (sizeof(long int) == sizeof(long long int)) ?
      0 :
      sizeof(long int)*8;

    *a = tab[0];
    if (count==2){
      assert(dec!=0);
      *a = *a << dec;
      *a = *a + (long long int)(tab[1]);
      assert(*a>=0LL);
      count = mpz_sizeinbase(b,2);
      res = count <= sizeof(numIll_t)*8-1;
    }
    else {
      res = true;
    }
    if (sgn<0) *a = -(*a);
  }
  return res;
}
MACRO_FOREACH yyy ("l","ll")
extern inline bool numIyyy_set_numMPQ(numIyyy_t a, numMPQ_t b, num_internal_t intern)
{
  mpz_cdiv_qr(intern->q, intern->r, mpq_numref(b),mpq_denref(b));
  numIyyy_set_numMPZ(a,intern->q,intern);
  return mpz_sgn(intern->r)==0;
}
extern inline bool numIyyy_set_numD(numIyyy_t a, numD_t b, num_internal_t intern)
{
  double c = ceil(*b);
  if (!isfinite(c)) { DEBUG_SPECIAL; *a = 0; return false; }
  *a = c;
  return *b==c;
}
extern inline bool numIyyy_set_numDl(numIyyy_t a, numDl_t b, num_internal_t intern)
{
  long double c = ceill(*b);
  if (!isfinite(c)) { DEBUG_SPECIAL; *a = 0; return false; }
  *a = c;
  return *b==c;
}
ENDMACRO
extern inline bool numIl_set_numMPFR(numIl_t a, numMPFR_t b, num_internal_t intern)
{
  if (!mpfr_number_p(b)) { DEBUG_SPECIAL; numIl_set_int(a,0); return false; }
  *a = mpfr_get_si(b,GMP_RNDU);
  return mpfr_integer_p(b);
}
extern inline bool numIll_set_numMPFR(numIll_t a, numMPFR_t b, num_internal_t intern)
{
  if (!mpfr_number_p(b)) { DEBUG_SPECIAL; numIll_set_int(a,0); return false; }
  *a = mpfr_get_sj(b,GMP_RNDU);
  return mpfr_integer_p(b);
}

extern inline bool numMPZ_set_numIl(numMPZ_t a, numIl_t b, num_internal_t intern)
{ mpz_set_si(a,*b); return true; }
bool numMPZ_set_numIll(numMPZ_t a, numIll_t b, num_internal_t intern)
{
  unsigned long long int n;
  unsigned long int rep[2];
  const int dec =
    (sizeof(long int) == sizeof(long long int)) ?
    0 :
    sizeof(long int)*8;

  n = llabs(*b);
  if (dec==0){
    rep[0] = n & ULONG_MAX;
    mpz_import(a,1,1,sizeof(unsigned long int),0,0,rep);
  }
  else {
    rep[1] = n & ULONG_MAX;
    rep[0] = n >> dec;
    mpz_import(a,2,1,sizeof(unsigned long int),0,0,rep);
  }
  if (*b<0)
    mpz_neg(a,a);
  return true;
}
MACRO_FOREACH yyy ("l","ll")
extern inline bool numRl_set_numIyyy(numRl_t a, numIyyy_t b, num_internal_t intern)
{
  *a->n = *b;
  *a->d = 1L;
  return true;
}
extern inline bool numRll_set_numIyyy(numRll_t a, numIyyy_t b, num_internal_t intern)
{
  *a->n = *b;
  *a->d = 1LL;
  return true;
}
extern inline bool numMPQ_set_numIyyy(numMPQ_t a, numIyyy_t b, num_internal_t intern)
{
  numMPZ_set_numIyyy(mpq_numref(a),b,intern);
  mpz_set_ui(mpq_denref(a),1);
  return true;
}
extern inline bool numD_set_numIyyy(numD_t a, numIyyy_t b, num_internal_t intern)
{
  *a = (double)(*b);
  double aa = -((double)(-(*b)));
  return (*a==aa);
}
extern inline bool numDl_set_numIyyy(numDl_t a, numIyyy_t b, num_internal_t intern)
{
  *a = (long double)(*b);
  long double aa = -((long double)(-(*b)));
  return (*a==aa);
}
ENDMACRO
extern inline bool numMPFR_set_numIl(numMPFR_t a, numIl_t b, num_internal_t intern)
{
  return !mpfr_set_si(a,*b,GMP_RNDU);
}
extern inline bool numMPFR_set_numIll(numMPFR_t a, numIll_t b, num_internal_t intern)
{
  return !mpfr_set_sj(a,*b,GMP_RNDU);
}

/* ====================================================================== */
/* 2. numMPZ_t */
/* ====================================================================== */

extern inline bool numMPZ_fits_numMPZ(numMPZ_t a, num_internal_t intern)
{ return true; }
extern inline bool numRl_fits_numMPZ(numRl_t a, num_internal_t intern)
{ return true; }
extern inline bool numRll_fits_numMPZ(numRll_t a, num_internal_t intern)
{ return true; }
extern inline bool numMPQ_fits_numMPZ(numMPQ_t a, num_internal_t intern)
{ return true; }
extern inline bool numD_fits_numMPZ(numD_t a, num_internal_t intern)
{ return isfinite(*a); }
extern inline bool numDl_fits_numMPZ(numDl_t a, num_internal_t intern)
{ return isfinite(*a); }
extern inline bool numMPFR_fits_numMPZ(numMPFR_t a, num_internal_t intern)
{ return mpfr_number_p(a); }

extern inline bool numMPZ_fits_numRl(numMPZ_t a, num_internal_t intern)
{ return numMPZ_fits_numIl(a,intern); }
extern inline bool numMPZ_fits_numRll(numMPZ_t a, num_internal_t intern)
{ return numMPZ_fits_numIll(a,intern); }
extern inline bool numMPZ_fits_numMPQ(numMPZ_t a, num_internal_t intern)
{ return true; }
extern inline bool numMPZ_fits_numD(numMPZ_t a, num_internal_t intern)
{ return (mpz_sizeinbase(a,2)<DBL_MAX_EXP-1); }
extern inline bool numMPZ_fits_numDl(numMPZ_t a, num_internal_t intern)
{ return (mpz_sizeinbase(a,2)<LDBL_MAX_EXP-1); }
extern inline bool numMPZ_fits_numMPFR(numMPZ_t a, num_internal_t intern)
{ return (mpz_sizeinbase(a,2)+1<(size_t)mpfr_get_emax()); }

extern inline bool numMPZ_set_numMPZ(numMPZ_t a, mpz_t b, num_internal_t intern)
{ mpz_set(a,b); return true; }
extern inline bool numMPZ_set_numRl(numMPZ_t a, numRl_t b, num_internal_t intern)
{
  long int i = *b->n;
  long int j = *b->d;
  long int q = (i>=0) ? (i+j-1)/j : i/j;
  mpz_set_si(a,q);
  return (i%j==0);
}
extern inline bool numMPZ_set_numRll(numMPZ_t a, numRll_t b, num_internal_t intern)
{
  long long int i = *b->n;
  long long int j = *b->d;
  long long int q = (i>=0) ? (i+j-1)/j : i/j;
  return numMPZ_set_numIll(a,&q,intern) && (i%j==0);
}
extern inline bool numMPZ_set_numMPQ(numMPZ_t a, numMPQ_t b, num_internal_t intern)
{
  mpz_cdiv_qr(a, intern->r, mpq_numref(b),mpq_denref(b));
  return mpz_sgn(intern->r)==0;
}
extern inline bool numMPZ_set_numD(numMPZ_t a, numD_t b, num_internal_t intern)
{
  double c = ceil(*b);
  if (!isfinite(c)) { DEBUG_SPECIAL; mpz_set_si(a,0); return false; }
  mpz_set_d(a,c);
  return (*b==c);
}
/* mpfr is supposed to have exactly the IEEE754 double precision of NUMFLTDL_MANT_DIG bits */
extern inline bool numMPZ_set_numDl(numMPZ_t a, numDl_t b, num_internal_t intern)
{
  long double c = ceill(*b);
  if (!isfinite(c)) { DEBUG_SPECIAL; mpz_set_si(a,0); return false; }
  int res = mpfr_set_ld(intern->ldbl,*b,GMP_RNDU);
  mpfr_get_z(a,intern->ldbl,GMP_RNDU);
  return (res==0) && (*b==c);
}
extern inline bool numMPZ_set_numMPFR(numMPZ_t a, numMPFR_t b, num_internal_t intern)
{
  if (!mpfr_number_p(b)) { DEBUG_SPECIAL; numMPZ_set_int(a,0); return false; }
  mpfr_get_z(a,b,GMP_RNDU);
  return mpfr_integer_p(b);
}

extern inline bool numRl_set_numMPZ(numRl_t a, numMPZ_t b, num_internal_t intern)
{ *a->d = 1L; return numIl_set_numMPZ(a->n,b,intern); }
extern inline bool numRll_set_numMPZ(numRll_t a, numMPZ_t b, num_internal_t intern)
{ *a->d = 1LL; return numIll_set_numMPZ(a->n,b,intern); }
extern inline bool numMPQ_set_numMPZ(numMPQ_t a, numMPZ_t b, num_internal_t intern)
{
  mpz_set(mpq_numref(a),b);
  mpz_set_ui(mpq_denref(a),1);
  return true;
}
/* mpfr is supposed to have exactly the IEEE754 double precision of 53 bits */
extern inline bool numD_set_numMPZ(numD_t a, numMPZ_t b, num_internal_t intern)
{
  int res = mpfr_set_z(intern->dbl,b,GMP_RNDU);
  *a = mpfr_get_d(intern->dbl,GMP_RNDU);/* Normally, exact conversion here (unless overflow) */
  return (res==0);
}
/* mpfr is supposed to have exactly the IEEE754 double precision of NUMFLTDL_MANT_DIG bits */
extern inline bool numDl_set_numMPZ(numDl_t a, numMPZ_t b, num_internal_t intern)
{
  int res = mpfr_set_z(intern->ldbl,b,GMP_RNDU);
  *a = mpfr_get_ld(intern->ldbl,GMP_RNDU);/* Normally, exact conversion here (unless overflow) */
  return (res==0);
}
extern inline bool numMPFR_set_numMPZ(numMPFR_t a, numMPZ_t b, num_internal_t intern)
{ return (mpfr_set_z(a,b,GMP_RNDU)==0); }

/* ====================================================================== */
/* 3. numRyyy */
/* ====================================================================== */

MACRO_FOREACH yyy ("l","ll")

extern inline bool numRl_fits_numRyyy(numRl_t a, num_internal_t intern)
{ return numIl_fits_numIyyy(a->n,intern) && numIl_fits_numIyyy(a->d,intern); }
extern inline bool numRll_fits_numRyyy(numRll_t a, num_internal_t intern)
{ return true; }
extern inline bool numMPQ_fits_numRyyy(mpq_t a, num_internal_t intern)
{ return numMPZ_fits_numIyyy(mpq_numref(a),intern) && numMPZ_fits_numIyyy(mpq_denref(a),intern); }
bool numD_fits_numRyyy(numD_t a, num_internal_t intern)
{
  double mant;
  int e;
  if (!isfinite(*a)) return false;
  mant = frexp(*a,&e);
  return e < (int)sizeof(numIyyy_t)*8-1;
}
bool numDl_fits_numRyyy(numDl_t a, num_internal_t intern)
{
  long double mant;
  int e;
  if (!isfinite(*a)) return false;
  mant = frexpl(*a,&e);
  return e < (int)sizeof(numIyyy_t)*8-1;
}
bool numMPFR_fits_numRyyy(numMPFR_t a, num_internal_t intern)
{
  mp_exp_t e;
  if (!mpfr_number_p(a)) return false;
  if (mpfr_sgn(a)==0) return true;
  e = mpfr_get_exp(a);
  return e < (mp_exp_t)sizeof(numIyyy_t)*8-1;
}
extern inline bool numRyyy_fits_numMPQ(numRyyy_t a, num_internal_t intern)
{ return true; }
extern inline bool numRyyy_fits_numD(numRyyy_t a, num_internal_t intern)
{ return true; }
extern inline bool numRyyy_fits_numDl(numRyyy_t a, num_internal_t intern)
{ return true; }
extern inline bool numRyyy_fits_numMPFR(numRyyy_t a, num_internal_t intern)
{ return true; }

extern inline bool numRyyy_set_numRl(numRyyy_t a, numRl_t b, num_internal_t intern)
{
  assert(*b->d>0);
  numIyyy_set_numIl(a->n,b->n,intern);
  numIyyy_set_numIl(a->d,b->d,intern);
  numRyyy_canonicalize(a);
  return true;
}
extern inline bool numRyyy_set_numRll(numRyyy_t a, numRll_t b, num_internal_t intern)
{
  assert(*b->d>0);
  numIyyy_set_numIll(a->n,b->n,intern);
  numIyyy_set_numIll(a->d,b->d,intern);
  numRyyy_canonicalize(a);
  return true;
}
extern inline bool numRyyy_set_numMPQ(numRyyy_t a, numMPQ_t b, num_internal_t intern)
{
  numIyyy_set_numMPZ(a->n,mpq_numref(b),intern);
  numIyyy_set_numMPZ(a->d,mpq_denref(b),intern);
  numRyyy_canonicalize(a);
  return true;
}
MACRO_FOREACH zzz ("","l")
#define MARKZ_zzz
bool numRyyy_set_numDzzz(numRyyy_t a, numDzzz_t b, num_internal_t intern)
{
#if defined(MARKZ_)
  double k = *b;
  double t;
#else
  long double k = *b;
  long double t;
#endif
  int e;
  const int longintsize = sizeof(long int)*8-2;

  if (!isfinite(k)) { DEBUG_SPECIAL; numRyyy_set_int(a,0); return false; }
  if (k==0.0){
    numRyyy_set_int(a,0);
    return true;
  }
  frexpzzz(k,&e);
  if (e < -longintsize){
    if (k>0.0){
      *a->n = NUMIyyy_ONE;
      *a->d = NUMIyyy_MAX;
    }
    else {
      numRyyy_set_int(a,0);
    }
    return false;
  }
  else {
    long int tab[NUM_CONTINUED_FRACTION_SIZE];
    int i,last,size;
    bool neg,stop,exact;
    numRyyy_t acc;

    if (k<0.0){
      neg = true;
      k = -k;
    }
    else {
      neg = false;
    }
    stop = false;
    size = 0;
    for(i=0; i<NUM_CONTINUED_FRACTION_SIZE; i++){
      frexpzzz(k,&e);
      size += e;
      if (size>=longintsize/NUM_CONTINUED_FRACTION_RATIO){
	last = i-1;
	stop = true;
	break;
      }
      t = floorzzz(k);
      tab[i] = (long int)t;
      last = i;
      k = k-t;
      if (k==0.0)
	break;
      k = 1.0/k;
    }
    if (stop || i==NUM_CONTINUED_FRACTION_SIZE){
      exact = false;
      if (last<0){
	*a->d = 1;
	if (size>=longintsize)
	  *a->n = 0; /* Out of range, we put something really wrong ! */
	else {
	  *a->n = neg ? -floorzzz(k) : ceilzzz(k);
	}
	return false;
      }
      else {
	if (last % 2 == 0){
	  if (!neg) tab[last]++;
	}
	else {
	  if (neg) tab[last]++;
	}
      }
    }
    else {
      exact = true;
    }
    numRyyy_set_int(a,tab[last]);
    for (i=last-1;i>=0;i--){
      numRyyy_inv(acc,a);
      numRyyy_set_int(a,tab[i]);
      numRyyy_add(a,a,acc);
    }
    if (neg) numRyyy_neg(a,a);
    return exact;
  }
}
#undef MARKZ_zzz
ENDMACRO
extern inline bool numRyyy_set_numMPFR(numRyyy_t a, numMPFR_t b, num_internal_t intern)
{
  long double k = mpfr_get_ld(b, GMP_RNDU);
  return numRyyy_set_numDl(a,&k,intern) && (mpfr_cmp_ld(b,k)==0);
}
extern inline bool numMPQ_set_numRyyy(numMPQ_t a, numRyyy_t b, num_internal_t intern)
{
  numMPZ_set_numIyyy(mpq_numref(a), numRyyy_numref(b),intern);
  numMPZ_set_numIyyy(mpq_denref(a), numRyyy_denref(b),intern);
  mpq_canonicalize(a);
  return true;
}
extern inline bool numD_set_numRyyy(numD_t a, numRyyy_t b, num_internal_t intern)
{
  *a = (double)(*b->n)/(double)(*b->d);
  return (-*a==(double)(-*b->n)/(double)(*b->d));
}
extern inline bool numDl_set_numRyyy(numDl_t a, numRyyy_t b, num_internal_t intern)
{
  *a = (long double)(*b->n)/(long double)(*b->d);
  return (-*a==(long double)(-*b->n)/(long double)(*b->d));
}
extern inline bool numMPFR_set_numRyyy(numMPFR_t a, numRyyy_t b, num_internal_t intern)
{
  int r = mpfr_set_si(a,*numRyyy_numref(b),GMP_RNDU);
  return !mpfr_div_si(a,a,*numRyyy_denref(b),GMP_RNDU) && !r;
}

ENDMACRO

/* ====================================================================== */
/* 4. numMPQ_t */
/* ====================================================================== */

extern inline bool numMPQ_fits_numMPQ(mpq_t a, num_internal_t intern)
{ return true; }
extern inline bool numD_fits_numMPQ(numD_t a, num_internal_t intern)
{ return isfinite(*a); }
extern inline bool numDl_fits_numMPQ(numDl_t a, num_internal_t intern)
{ return isfinite(*a); }
extern inline bool numMPFR_fits_numMPQ(numMPFR_t a, num_internal_t intern)
{ return mpfr_number_p(a); }

extern inline bool numMPQ_fits_numD(numMPQ_t a, num_internal_t intern)
{
  return ((int)mpz_sizeinbase(numMPQ_numref(a),2)-
	  (int)mpz_sizeinbase(numMPQ_denref(a),2)<DBL_MAX_EXP-2);
}
extern inline bool numMPQ_fits_numDl(numMPQ_t a, num_internal_t intern)
{
  return ((int)mpz_sizeinbase(numMPQ_numref(a),2)-
	  (int)mpz_sizeinbase(numMPQ_denref(a),2)<LDBL_MAX_EXP-2);
}
extern inline bool numMPQ_fits_numMPFR(numMPQ_t a, num_internal_t intern)
{
  return ((int)mpz_sizeinbase(numMPQ_numref(a),2)-
	  (int)mpz_sizeinbase(numMPQ_denref(a),2)+1<mpfr_get_emax());
}

extern inline bool numMPQ_set_numMPQ(numMPQ_t a, numMPQ_t b, num_internal_t intern)
{ mpq_set(a,b); return true; }
extern inline bool numMPQ_set_numD(numMPQ_t a, numD_t b, num_internal_t intern)
{
  if (!isfinite(*b)) { DEBUG_SPECIAL; numMPQ_set_int(a,0); return false; }
  mpq_set_d(a,*b);
  return true;
}
bool numMPQ_set_numMPFR(numMPQ_t a, numMPFR_t b, num_internal_t intern)
{
  mp_exp_t e;
  if (!mpfr_number_p(b)) { DEBUG_SPECIAL; numMPQ_set_int(a,0); return false; }
  /* XXX might fail if scaled exponent not representable in mp_exp_t */
  e = mpfr_get_z_exp(mpq_numref(a),b);
  mpz_set_si(mpq_denref(a),1);
  if (e>0) mpq_mul_2exp(a,a,e);
  if (e<0) mpq_div_2exp(a,a,-e);
  return true;
}
bool numMPQ_set_numDl(numMPQ_t a, numDl_t b, num_internal_t intern)
{
  mp_exp_t e;
  if (!isfinite(*b)) { DEBUG_SPECIAL; mpq_set_si(a,0,1); return false; }
  int res = mpfr_set_ld(intern->ldbl,*b,GMP_RNDU);
  numMPQ_set_numMPFR(a,intern->ldbl,intern);
  return (res==0);
}
/* mpfr should have exactly a precision of 53 bits */
extern inline bool numD_set_numMPQ(numD_t a, numMPQ_t b, num_internal_t intern)
{
  int res = mpfr_set_q(intern->dbl,b,GMP_RNDU);
  *a = mpfr_get_d(intern->dbl,GMP_RNDU); /* should be exact */
  return (res==0);
}
extern inline bool numDl_set_numMPQ(numDl_t a, numMPQ_t b, num_internal_t intern)
{
  int res = mpfr_set_q(intern->ldbl,b,GMP_RNDU);
  *a = mpfr_get_ld(intern->ldbl,GMP_RNDU); /* should be exact */
  return (res==0);
}
extern inline bool numMPFR_set_numMPQ(numMPFR_t a, numMPQ_t b, num_internal_t intern)
{ return !mpfr_set_q(a,b,GMP_RNDU); }

/* ====================================================================== */
/* 5. numDyyy */
/* ====================================================================== */

extern inline bool numDl_fits_numD(numDl_t a, num_internal_t intern)
{ return isfinite(*a) && *a>=-DBL_MAX && *a<=DBL_MAX; }
extern inline bool numDl_fits_numDl(numDl_t a, num_internal_t intern)
{ return true; }
extern inline bool numD_set_numD(numD_t a, numD_t b, num_internal_t intern)
{ *a = *b; return true; }
extern inline bool numD_set_numDl(numD_t a, numDl_t b, num_internal_t intern)
{ *a = *b; return (long double)(*a)==*b; }

MACRO_FOREACH yyy ("","l")
extern inline bool numD_fits_numDyyy(numD_t a, num_internal_t intern)
{ return isfinite(*a); }
bool numMPFR_fits_numDyyy(mpfr_t a, num_internal_t intern)
{
  if (mpfr_number_p(a)){
    if (mpfr_sgn(a)==0) return true;
    else {
      mp_exp_t e = mpfr_get_exp(a);
      return e<NUMDyyy_MAX_EXP-1;
    }
  }
  else
    return false;
}
extern inline bool numDyyy_fits_numMPFR(numDyyy_t a, num_internal_t intern)
{
  int e;
  frexpyyy(*a,&e);
  return (e<mpfr_get_emax());
}
extern inline bool numDyyy_set_numMPFR(numDyyy_t a, numMPFR_t b, num_internal_t intern)
{
  *a = mpfr_get_yyyd(b,GMP_RNDU);
  return !mpfr_cmp_yyyd(b,*a);
}
extern inline bool numDl_set_numDyyy(numDl_t a, numDyyy_t b, num_internal_t intern)
{ *a = *b; return true; }
extern inline bool numMPFR_set_numDyyy(numMPFR_t a, numDyyy_t b, num_internal_t intern)
{ return (mpfr_set_yyyd(a,*b,GMP_RNDU)==0); }
ENDMACRO

/* ====================================================================== */
/* 6. numMPFR */
/* ====================================================================== */

extern inline bool numMPFR_fits_numMPFR(mpfr_t a, num_internal_t intern)
{ return true; }
extern inline bool numMPFR_set_numMPFR(numMPFR_t a, mpfr_t b, num_internal_t intern)
{ return !mpfr_set(a,b,GMP_RNDU); }

/* ********************************************************************** */
/* II. boundXXX, itvXXX, eitvXXX */
/* ********************************************************************** */

MACRO_FOREACH XXX @AllNum
MACRO_FOREACH YYY @AllNum
#define MARK_XXX_YYY

#if defined(MARK_XXX_XXX)
MACRO_FOREACH ttt ("bound","itv","eitv")
extern inline bool tttXXX_set_tttYYY(tttXXX_t a, tttYYY_t b, num_internal_t intern)
{ tttXXX_set(a,b); return true; }
ENDMACRO
#endif

#if !defined(MARK_XXX_XXX)
extern inline bool boundXXX_set_boundYYY(boundXXX_t a, boundYYY_t b, num_internal_t intern)
{
  if (boundYYY_infty(b)){
    boundXXX_set_infty(a,boundYYY_sgn(b));
    return true;
  }
  else {
    return boundXXX_set_numYYY(a,boundYYY_numref(b),intern);
  }
}
#endif

extern inline bool boundXXX_set_numYYY(boundXXX_t a, numYYY_t b, num_internal_t intern)
{
  if (numYYY_fits_numXXX(b,intern)){
    _boundXXX_set_finite(a);
    return numXXX_set_numYYY(boundXXX_numref(a),b,intern);
  }
  else {
    boundXXX_set_infty(a,numYYY_sgn(b));
    return false;
  }
}
bool itvXXX_set_numYYY2(itvXXX_t a, numYYY_t b, numYYY_t c, num_internal_t intern)
{
#if defined(MARK_XXX_XXX)
  assert(boundXXX_numref(a->neginf)!=b && boundXXX_numref(a->neginf)!=c);
#endif
  numYYY_neg(b,b);
  bool exact1 = boundXXX_set_numYYY(a->neginf,b,intern);
  numYYY_neg(b,b);
  bool exact2 = boundXXX_set_numYYY(a->sup,c,intern);
  return exact1 && exact2;
}
bool itvXXX_set_boundYYY2(itvXXX_t a, boundYYY_t b, boundYYY_t c, num_internal_t intern)
{
#if defined(MARK_XXX_XXX)
  assert(a->neginf!=b && a->neginf!=c);
#endif
  boundYYY_neg(b,b);
  bool exact1 = boundXXX_set_boundYYY(a->neginf,b,intern);
  boundYYY_neg(b,b);
  bool exact2 = boundXXX_set_boundYYY(a->sup,c,intern);
  return exact1 && exact2;
}
extern inline bool itvXXX_set_numYYY(itvXXX_t a, numYYY_t b, num_internal_t intern)
{
#if defined(MARK_XXX_XXX)
  assert(boundXXX_numref(a->neginf)!=b);
#endif
  bool exact1 = boundXXX_set_numYYY(a->sup,b,intern);
  if (exact1){
    boundXXX_neg(a->neginf,a->sup);
    return true;
  } else {
    numYYY_neg(b,b);
    bool exact2 = boundXXX_set_numYYY(a->neginf,b,intern);
    numYYY_neg(b,b);
    return exact1 && exact2;
  }
}
extern inline bool itvXXX_set_boundYYY(itvXXX_t a, boundYYY_t b, num_internal_t intern)
{
  assert(!boundYYY_infty(b));
  return itvXXX_set_numYYY(a,boundYYY_numref(b),intern);
}
extern inline bool eitvXXX_set_numYYY2(eitvXXX_t a, numYYY_t b, numYYY_t c, num_internal_t intern)
{
  bool exact = itvXXX_set_numYYY2(a->itv,b,c,intern);
  a->eq = exact && numYYY_equal(b,c);
  return exact;
}
extern inline bool eitvXXX_set_boundYYY2(eitvXXX_t a, boundYYY_t b, boundYYY_t c, num_internal_t intern)
{
  bool exact = itvXXX_set_boundYYY2(a->itv,b,c,intern);
  a->eq = exact && boundYYY_equal(b,c);
  return exact;
}
extern inline bool eitvXXX_set_numYYY(eitvXXX_t a, numYYY_t b, num_internal_t intern)
{ a->eq = itvXXX_set_numYYY(a->itv,b,intern); return a->eq; }
extern inline bool eitvXXX_set_boundYYY(eitvXXX_t a, boundYYY_t b, num_internal_t intern)
{ a->eq = itvXXX_set_boundYYY(a->itv,b,intern); return a->eq; }

#if !defined(MARK_XXX_XXX)
extern inline bool itvXXX_set_itvYYY(itvXXX_t a, itvYYY_t b, num_internal_t intern)
{
  bool exact1 = boundXXX_set_boundYYY(a->neginf,b->neginf,intern);
  bool exact2 = boundXXX_set_boundYYY(a->sup,b->sup,intern);
  return exact1 && exact2;
}
bool eitvXXX_set_eitvYYY(eitvXXX_t a, eitvYYY_t b, num_internal_t intern)
{
  if (b->eq){
    assert(!boundYYY_infty(b->itv->sup));
    bool exact1 = boundXXX_set_boundYYY(a->itv->sup,b->itv->sup,intern);
    if (exact1){
      boundXXX_neg(a->itv->neginf,a->itv->sup);
      a->eq = true;
      return true;
    }
    else {
      boundXXX_set_boundYYY(a->itv->neginf,b->itv->neginf,intern);
      a->eq = false;
      return false;
    }
  }
  else {
    a->eq = false;
    return itvXXX_set_itvYYY(a->itv,b->itv,intern);
  }
}
#endif

#undef MARK_XXX_YYY
ENDMACRO
ENDMACRO

/* ********************************************************************** */
/* III. set_generic, set_val */
/* ********************************************************************** */

MACRO_FOREACH XXX @AllNum
bool itvXXX_set_generic(num_internal_t intern,
			itvXXX_t a, itv_tag_t tag, va_list* va)
{
  bool res;
  switch (tag){
  case ITV_NUM:
    { numXXX_ptr b = va_arg(*va,numXXX_ptr);
      itvXXX_set_num(a,b);
      res = true; }
    break;
  case ITV_NUM2:
    { numXXX_ptr b = va_arg(*va,numXXX_ptr);
      numXXX_ptr c = va_arg(*va,numXXX_ptr);
      itvXXX_set_num2(a,b,c);
      res = true; }
    break;
  case ITV_ITV:
    { itvXXX_ptr b = va_arg(*va,itvXXX_ptr);
      itvXXX_set(a,b);
      res = true; }
    break;
MACRO_FOREACH ZZZ @AllNum
  case ITV_NUMZZZ:
    { numZZZ_ptr b = va_arg(*va,numZZZ_ptr);
      res = itvXXX_set_numZZZ(a,b,intern); }
    break;
  case ITV_NUMZZZ2:
    { numZZZ_ptr b = va_arg(*va,numZZZ_ptr);
      numZZZ_ptr c = va_arg(*va,numZZZ_ptr);
      res = itvXXX_set_numZZZ2(a,b,c,intern); }
     break;
  case ITV_ITVZZZ:
    { itvZZZ_ptr b = va_arg(*va,itvZZZ_ptr);
       res = itvXXX_set_itvZZZ(a,b,intern); }
    break;
ENDMACRO
  case ITV_LINT:
    { long int b = va_arg(*va,long int);
      res = itvXXX_set_lint(a,b,intern); }
    break;
  case ITV_LINT2:
    { long int b = va_arg(*va,long int);
      long int c = va_arg(*va,long int);
      res = itvXXX_set_lint2(a,b,c,intern); }
    break;
  case ITV_MPZ:
    { mpz_ptr b = va_arg(*va,mpz_ptr);
      res = itvXXX_set_mpz(a,b,intern); }
    break;
  case ITV_MPZ2:
    { mpz_ptr b = va_arg(*va,mpz_ptr);
      mpz_ptr c = va_arg(*va,mpz_ptr);
      res = itvXXX_set_mpz2(a,b,c,intern); }
    break;
  case ITV_LFRAC:
    { long int i = va_arg(*va,long int);
      long int j = va_arg(*va,long int);
      res = itvXXX_set_lfrac(a,i,j,intern); }
    break;
  case ITV_LFRAC2:
    { long int i = va_arg(*va,long int);
      long int j = va_arg(*va,long int);
      long int k = va_arg(*va,long int);
      long int l = va_arg(*va,long int);
      res = itvXXX_set_lfrac2(a,i,j,k,l,intern); }
    break;
  case ITV_MPQ:
    { mpq_ptr b = va_arg(*va,mpq_ptr);
      res = itvXXX_set_mpq(a,b,intern); }
    break;
  case ITV_MPQ2:
    { mpq_ptr b = va_arg(*va,mpq_ptr);
      mpq_ptr c = va_arg(*va,mpq_ptr);
      res = itvXXX_set_mpq2(a,b,c,intern); }
    break;
  case ITV_DOUBLE:
    { double b = va_arg(*va,double);
      res = itvXXX_set_double(a,b,intern); }
    break;
  case ITV_DOUBLE2:
    { double b = va_arg(*va,double);
      double c = va_arg(*va,double);
      res = itvXXX_set_double2(a,b,c,intern); }
    break;
  case ITV_MPFR:
    { mpfr_ptr b = va_arg(*va,mpfr_ptr);
      res = itvXXX_set_mpfr(a,b,intern); }
    break;
  case ITV_MPFR2:
    { mpfr_ptr b = va_arg(*va,mpfr_ptr);
      mpfr_ptr c = va_arg(*va,mpfr_ptr);
      res = itvXXX_set_mpfr2(a,b,c,intern); }
    break;
  default:
    fprintf(stderr,
	    "itvXXX_set_generic: unknown tag\n");
    abort();
  }
  return res;
}
bool itvXXX_set_val(num_internal_t intern,
		    itvXXX_t a, itv_tag_t tag, ...)
{
  va_list va;
  bool res;
  va_start(va,tag);
  res = itvXXX_set_generic(intern,a,tag,&va);
  va_end(va);
  return res;
}
bool eitvXXX_set_generic(num_internal_t intern,
			 eitvXXX_t a, eitv_tag_t tag, va_list* va)
{
  bool res;
  switch (tag){
  case EITV_NUM:
    { numXXX_ptr b = va_arg(*va,numXXX_ptr);
      eitvXXX_set_num(a,b);
      res = true; }
    break;
  case EITV_NUM2:
    { numXXX_ptr b = va_arg(*va,numXXX_ptr);
      numXXX_ptr c = va_arg(*va,numXXX_ptr);
      eitvXXX_set_num2(a,b,c);
      res = true; }
    break;
  case EITV_EITV:
    { eitvXXX_ptr b = va_arg(*va,eitvXXX_ptr);
      eitvXXX_set(a,b);
      res = true; }
    break;
MACRO_FOREACH ZZZ @AllNum
  case EITV_NUMZZZ:
    { numZZZ_ptr b = va_arg(*va,numZZZ_ptr);
      res = eitvXXX_set_numZZZ(a,b,intern); }
    break;
  case EITV_NUMZZZ2:
    { numZZZ_ptr b = va_arg(*va,numZZZ_ptr);
      numZZZ_ptr c = va_arg(*va,numZZZ_ptr);
      res = eitvXXX_set_numZZZ2(a,b,c,intern); }
     break;
  case EITV_EITVZZZ:
    { eitvZZZ_ptr b = va_arg(*va,eitvZZZ_ptr);
	res = eitvXXX_set_eitvZZZ(a,b,intern); }
    break;
ENDMACRO
  case EITV_LINT:
    { long int b = va_arg(*va,long int);
      res = eitvXXX_set_lint(a,b,intern); }
    break;
  case EITV_LINT2:
    { long int b = va_arg(*va,long int);
      long int c = va_arg(*va,long int);
      res = eitvXXX_set_lint2(a,b,c,intern); }
    break;
  case EITV_MPZ:
    { mpz_ptr b = va_arg(*va,mpz_ptr);
      res = eitvXXX_set_mpz(a,b,intern); }
    break;
  case EITV_MPZ2:
    { mpz_ptr b = va_arg(*va,mpz_ptr);
      mpz_ptr c = va_arg(*va,mpz_ptr);
      res = eitvXXX_set_mpz2(a,b,c,intern); }
    break;
  case EITV_LFRAC:
    { long int i = va_arg(*va,long int);
      long int j = va_arg(*va,long int);
      res = eitvXXX_set_lfrac(a,i,j,intern); }
    break;
  case EITV_LFRAC2:
    { long int i = va_arg(*va,long int);
      long int j = va_arg(*va,long int);
      long int k = va_arg(*va,long int);
      long int l = va_arg(*va,long int);
      res = eitvXXX_set_lfrac2(a,i,j,k,l,intern); }
    break;
  case EITV_MPQ:
    { mpq_ptr b = va_arg(*va,mpq_ptr);
      res = eitvXXX_set_mpq(a,b,intern); }
    break;
  case EITV_MPQ2:
    { mpq_ptr b = va_arg(*va,mpq_ptr);
      mpq_ptr c = va_arg(*va,mpq_ptr);
      res = eitvXXX_set_mpq2(a,b,c,intern); }
    break;
  case EITV_DOUBLE:
    { double b = va_arg(*va,double);
      res = eitvXXX_set_double(a,b,intern); }
    break;
  case EITV_DOUBLE2:
    { double b = va_arg(*va,double);
      double c = va_arg(*va,double);
      res = eitvXXX_set_double2(a,b,c,intern); }
    break;
  case EITV_MPFR:
    { mpfr_ptr b = va_arg(*va,mpfr_ptr);
      res = eitvXXX_set_mpfr(a,b,intern); }
    break;
  case EITV_MPFR2:
    { mpfr_ptr b = va_arg(*va,mpfr_ptr);
      mpfr_ptr c = va_arg(*va,mpfr_ptr);
      res = eitvXXX_set_mpfr2(a,b,c,intern); }
    break;
  default:
    fprintf(stderr,
	    "eitvXXX_set_generic: unknown tag\n");
    abort();
  }
  return res;
}
bool eitvXXX_set_val(num_internal_t intern, eitvXXX_t a, eitv_tag_t tag, ...)
{
  va_list va;
  bool res;
  va_start(va,tag);
  res = eitvXXX_set_generic(intern,a,tag,&va);
  va_end(va);
  return res;
}
ENDMACRO

/* ********************************************************************** */
/* IV. to_float, to_double */
/* ********************************************************************** */

MACRO_FOREACH yyy ("l","ll")
extern inline bool numIyyy_fits_float(numIyyy_t a)
{ return true; }
extern inline bool numRyyy_fits_float(numRyyy_t a)
{ return true; }
ENDMACRO
extern inline bool numMPZ_fits_float(numMPZ_t a)
{
  return ((int)mpz_sizeinbase(a,2)<FLT_MAX_EXP-1);
}
extern inline bool numMPQ_fits_float(numMPQ_t a)
{
  return ((int)mpz_sizeinbase(numMPQ_numref(a),2)-
	  (int)mpz_sizeinbase(numMPQ_denref(a),2)<FLT_MAX_EXP-2);
}
MACRO_FOREACH yyy ("","l")
extern inline bool numDyyy_fits_float(numDyyy_t a)
{
  int e;
  frexpyyy(*a,&e);
  return (e<FLT_MAX_EXP-1);
}
ENDMACRO
extern inline bool numMPFR_fits_float(numMPFR_t a)
{
  int e;
  e = mpfr_get_exp(a);
  return (e<FLT_MAX_EXP-1);
}

MACRO_FOREACH XXX @AllNum
void boundXXX_to_float(boundXXX_t a, boundXXX_t b, num_internal_t intern)
{
  if (boundXXX_infty(b) || !numXXX_fits_float(boundXXX_numref(b)))
    boundXXX_set_infty(a,boundXXX_sgn(b));
  else {
    double d;
    numD_set_numXXX(&d,boundXXX_numref(b),intern);
    d = (double)((float)d);
    numXXX_set_numD(boundXXX_numref(a),&d,intern);
    _boundXXX_set_finite(a);
  }
}
void boundXXX_to_double(boundXXX_t a, boundXXX_t b, num_internal_t intern)
{
  if (boundXXX_infty(b) || !numXXX_fits_numD(boundXXX_numref(b),intern))
    boundXXX_set_infty(a,boundXXX_sgn(b));
  else {
    double d;
    numD_set_numXXX(&d,boundXXX_numref(b),intern);
    numXXX_set_numD(boundXXX_numref(a),&d,intern);
    _boundXXX_set_finite(a);
  }
}
void itvXXX_to_float(itvXXX_t a, itvXXX_t b, num_internal_t intern)
{
  boundXXX_to_float(a->sup,b->sup,intern);
  boundXXX_to_float(a->neginf,b->neginf,intern);
}
void itvXXX_to_double(itvXXX_t a, itvXXX_t b, num_internal_t intern)
{
  boundXXX_to_double(a->sup,b->sup,intern);
  boundXXX_to_double(a->neginf,b->neginf,intern);
}
void eitvXXX_to_float(eitvXXX_t a, eitvXXX_t b, num_internal_t intern)
{
  itvXXX_to_float(a->itv,b->itv,intern);
  a->eq = itvXXX_is_point(a->itv);
}
void eitvXXX_to_double(eitvXXX_t a, eitvXXX_t b, num_internal_t intern)
{
  itvXXX_to_double(a->itv,b->itv,intern);
  a->eq = itvXXX_is_point(a->itv);
}
ENDMACRO
