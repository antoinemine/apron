/* -*- mode: c -*- */

/* ************************************************************************* */
/* ap_check0.h: checks for level 0 */
/* ************************************************************************* */

/* This file is part of the APRON Library, released under LGPL license.  Please
   read the COPYING file packaged in the distribution */

#include "ap_abstract0.h"

/* ********************************************************************** */
/* 2 Checking typing w.r.t. manager */
/* ********************************************************************** */

/*
  These functions return true if everything is OK, otherwise they raise an
  exception in the manager and return false.
*/

/* One abstract value */
void ap_check0_man1_raise(ap_funid_t funid, ap_manager_t* man, ap_abstract0_t* a);
static inline
bool ap_check0_man1(ap_funid_t funid, ap_manager_t* man, ap_abstract0_t* a);

/* Two abstract values */
bool ap_check0_man2(ap_funid_t funid,
		    ap_manager_t* man, ap_abstract0_t* a1, ap_abstract0_t* a2);

/* Array of abstract values */
bool ap_check0_man_array(ap_funid_t funid,
			 ap_manager_t* man, ap_abstract0_t** tab, size_t size);

/* ********************************************************************** */
/* 3. Checking compatibility of arguments: abstract values */
/* ********************************************************************** */

/* Getting dimensions without checks */
static inline
ap_dimension_t _ap_abstract0_dimension(ap_abstract0_t* a);

/* Check that the 2 abstract values have the same dimensionality */
bool ap_check0_abstract2(ap_funid_t funid, ap_manager_t* man,
			 ap_abstract0_t* a1, ap_abstract0_t* a2);

/* Check that the array of abstract values have the same dimensionality.*/
bool ap_check0_abstract_array(ap_funid_t funid, ap_manager_t* man,
			      ap_abstract0_t** tab, size_t size);

/* ********************************************************************** */
/* 4. Checking compatibility of arguments: dimensions */
/* ********************************************************************** */

/* Check that the dimension makes sense in the given dimensionality */
void ap_check0_dim_raise(ap_funid_t funid, ap_manager_t* man,
			 ap_dimension_t dimension, ap_dim_t dim,
			 char* prefix);
static inline
bool ap_check0_dim(ap_funid_t funid, ap_manager_t* man,
		   ap_dimension_t dimension, ap_dim_t dim);

/* Check that the array of dimensions make sense in the given dimensionality */
bool ap_check0_dim_array(ap_funid_t funid, ap_manager_t* man,
			 ap_dimension_t dimension, ap_dim_t* tdim, size_t size);

/* ********************************************************************** */
/* 5. Checking compatibility of arguments: expressions */
/* ********************************************************************** */

void ap_check0_expr_raise(ap_funid_t funid, ap_manager_t* man,
			  ap_dimension_t dimension,
			  ap_dim_t dim,
			  char* prefix);

/* Check that the linear expression makes sense in the given dimensionality */
MACRO_FOREACH XXX @MainNum;
ap_dim_t ap_check0_linexprXXX_dim(ap_dimension_t dimension,
				  ap_linexprXXX_t expr);
MACRO_FOREACH TTT ("cons","gen")
static inline
ap_dim_t ap_check0_linTTTXXX_dim(ap_dimension_t dimension,
				 ap_linTTTXXX_t a)
{
  return ap_check0_linexprXXX_dim(dimension,a->linexpr);
}
ENDMACRO
ENDMACRO

MACRO_FOREACH TTT ("expr","cons");
bool ap_check0_linTTT(ap_funid_t funid, ap_manager_t* man,
		      ap_dimension_t dimension,
		      ap_linTTT0_t a);
bool ap_check0_tTTT(ap_funid_t funid, ap_manager_t* man,
		    ap_dimension_t dimension,
		    ap_tTTT0_t* expr);
ENDMACRO

/* ********************************************************************** */
/* 6. Checking compatibility of arguments: array of expressions/constraints/generators */
/* ********************************************************************** */

/* Check that array of linear expressions/constraints/generators makes sense
   in the given dimensionality */
MACRO_FOREACH TTT ("expr","cons","gen");
bool ap_check0_linTTT_array(ap_funid_t funid, ap_manager_t* man,
			     ap_dimension_t dimension,
			     ap_linTTT0_array_t array);
ENDMACRO

/* Check that array of tree expressions/constraints makes sense
   in the given dimensionality */
MACRO_FOREACH TTT ("expr","cons");
bool ap_check0_tTTT_array(ap_funid_t funid, ap_manager_t* man,
			  ap_dimension_t dimension,
			  ap_tTTT0_array_t* array);
ENDMACRO
/* ********************************************************************** */
/* 7. Checking compatibility of arguments: dimchange */
/* ********************************************************************** */

bool ap_check0_dimchange_add(ap_funid_t funid, ap_manager_t* man,
			     ap_dimension_t dimension, ap_dimchange_t* dimchange);
bool ap_check0_dimchange_remove(ap_funid_t funid, ap_manager_t* man,
				ap_dimension_t dimension, ap_dimchange_t* dimchange);
bool ap_check0_dimperm(ap_funid_t funid, ap_manager_t* man,
		       ap_dimension_t dimension, ap_dimperm_t* perm);

static inline
bool ap_check0_man1(ap_funid_t funid, ap_manager_t* man, ap_abstract0_t* a)
{
  if (man->library != a->man->library){
    ap_check0_man1_raise(funid,man,a);
    return false;
  }
  else
    return true;
}
static inline
bool ap_check0_dim(ap_funid_t funid, ap_manager_t* man,
		   ap_dimension_t dimension, ap_dim_t dim)
{
  if (dim>=dimension.intd+dimension.reald){
      ap_check0_dim_raise(funid,man,dimension,dim,"incompatible dimension");
      return false;
  }
  return true;
}
/* Getting dimensions without checks */
static inline
ap_dimension_t _ap_abstract0_dimension(ap_abstract0_t* a)
{
  ap_dimension_t (*ptr)(ap_manager_t*,...) = (ap_dimension_t (*) (ap_manager_t*,...))(a->man->funptr[AP_FUNID_DIMENSION]);
  return ptr(a->man,a->value);
}
