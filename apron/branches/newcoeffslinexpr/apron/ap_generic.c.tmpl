/* -*- mode: c -*- */
/* ************************************************************************* */
/* ap_generic: generic functions for library implementors */
/* ************************************************************************* */

/* This file is part of the APRON Library, released under LGPL license.  Please
   read the COPYING file packaged in the distribution */

#include "ap_generic.h"
/* These functions are dedicated to implementors of domains. They offer generic
   default implementations for some of the operations required by the APRON
   API, when there is no more specific and efficient implementation for the
   domain being implemented.

   To use them, the function allocating manager, which is specific to the domain,
   should put the corresponding pointers in the virtual table to them.

   They manipulated "unboxed" abstract values, which are native to the
   underlying library: they are not yet boxed with the manager in the type
   ap_abstract0_t.
*/

/* ********************************************************************** */
/* I. Constructors */
/* ********************************************************************** */

bool ap_generic_sat_tcons(ap_manager_t* man, void* abs, ap_tcons0_t* cons,
			  ap_scalar_discr_t discr,
			  bool quasilinearize)
{
  bool (*is_bottom)(ap_manager_t*,...) = man->funptr[AP_FUNID_IS_BOTTOM];
  bool (*sat_lincons)(ap_manager_t*,...) = man->funptr[AP_FUNID_SAT_LINCONS];
  void (*to_box)(ap_manager_t*,...) = man->funptr[AP_FUNID_TO_BOX];
  ap_dimension_t (*dimension)(ap_manager_t*,...) = man->funptr[AP_FUNID_DIMENSION];
  bool error;
  ap_dimension_t dim;
  ap_linexpr0_t env;
  ap_lincons0_t lincons0;
  bool exact,res;

  if (is_bottom(man,abs)){
    man->result.flag_exact = man->result.flag_best = true;
    return true;
  }
  MACRO_SWITCH(discr) XXX {
    ap_linconsXXX_t lincons;
    ap_linconsXXX_init(lincons,0);
    exact = ap_linconsXXX_set_tcons0(lincons,&error,cons,man->num);
    if (error){
      dim = dimension(man,abs);
      ap_linexpr0_init(env,discr,0);
      to_box(man,env,abs);
      exact = false;
      ap_linconsXXX_intlinearize_tcons0(lincons,cons,
					env->linexpr.XXX,dim.intd,
					man->num);
    }
    if (quasilinearize){
      bool is_quasilinear = ap_linconsXXX_is_quasilinear(lincons);
      if (!is_quasilinear){
	if (!error){
	  error = true;
	  dim = dimension(man,abs);
	  ap_linexpr0_init(env,discr,0);
	  to_box(man,env,abs);
	}
	exact =
	  ap_linconsXXX_quasilinearize(
	      lincons,
	      env->linexpr.XXX,false,man->num
	  ) && exact;
      }
    }
    ap_lincons0_cons_XXX(lincons0,lincons);
    res = sat_lincons(man,abs,lincons0);
    ap_linconsXXX_clear(lincons);
    if (error){
      ap_linexpr0_clear(env);
    }
  }
  ENDMACRO;
  man->result.flag_exact &= exact;
  return res;
}

/*
   This function implements a generic bound_texpr operation using linearisation
   and bound_linexpr
*/
void
ap_generic_bound_texpr(ap_manager_t* man, ap_coeff_t interval,
		       void* abs, ap_texpr0_t* expr,
		       ap_scalar_discr_t discr, bool quasilinearize)
{
  bool (*is_bottom)(ap_manager_t*,...) = man->funptr[AP_FUNID_IS_BOTTOM];
  void (*bound_linexpr)(ap_manager_t*,...) = man->funptr[AP_FUNID_BOUND_LINEXPR];
  void (*to_box)(ap_manager_t*,...) = man->funptr[AP_FUNID_TO_BOX];
  ap_dimension_t (*dimension)(ap_manager_t*,...) = man->funptr[AP_FUNID_DIMENSION];
  bool error,exact;
  ap_dimension_t dim;
  ap_linexpr0_t env;
  ap_linexpr0_t linexpr0;

  man->result.flag_exact = man->result.flag_best = true;
  if (is_bottom(man,abs)){
    ap_coeff_set_bottom(interval);
    return;
  }
  MACRO_SWITCH(discr) XXX {
    ap_linexprXXX_t linexpr;
    ap_linexprXXX_init(linexpr,0);
    exact = ap_linexprXXX_set_texpr0(linexpr,&error,expr,man->num);
    if (error){
      dim = dimension(man,abs);
      ap_linexpr0_init(env,discr,0);
      to_box(man,env,abs);
      exact = false;
      ap_linexprXXX_intlinearize_texpr0(linexpr,expr,
					env->linexpr.XXX,dim.intd,
					man->num);
    }
    if (quasilinearize){
      bool is_quasilinear = ap_linexprXXX_is_quasilinear(linexpr);
      if (!is_quasilinear){
	if (!error){
	  error = true;
	  dim = dimension(man,abs);
	  ap_linexpr0_init(env,discr,0);
	  to_box(man,env,abs);
	}
	exact = ap_linexprXXX_quasilinearize(linexpr,env->linexpr.XXX,false,man->num) && exact;
      }
    }
    ap_linexpr0_cons_XXX(linexpr0,linexpr);
    bound_linexpr(man,interval,abs,linexpr0);
    ap_linexprXXX_clear(linexpr);
    if (error) ap_linexpr0_clear(env);
  }
  ENDMACRO;
  man->result.flag_exact &= exact;
  return;
}

ap_tcons0_array_t
ap_generic_to_tcons_array(ap_manager_t* man,
			  void* abs,
			  ap_scalar_discr_t discr)
{
  void (*to_lincons_array)(ap_manager_t*,...) = man->funptr[AP_FUNID_TO_LINCONS_ARRAY];
  ap_lincons0_array_t linarray;
  ap_tcons0_array_t array;

  ap_lincons0_array_init(linarray,discr,0);
  to_lincons_array(man,linarray,abs);
  array = ap_tcons0_array_from_lincons0_array(linarray);
  ap_lincons0_array_clear(linarray);
  return array;
}


/* ********************************************************************** */
/* II. Operations */
/* ********************************************************************** */

/* ============================================================ */
/*  Meet/Join on arrays of abstract values */
/* ============================================================ */

/*
   This function implements a generic meet/join_array operation using copy and meet
   operations.
*/
void* ap_generic_meetjoin_array(bool meet,
				ap_manager_t* man,
				void** tab, size_t size)
{
  void* (*copy)(ap_manager_t*,...) = man->funptr[AP_FUNID_COPY];
  void* (*meetjoin)(ap_manager_t*,...) = man->funptr[meet ? AP_FUNID_MEET : AP_FUNID_JOIN];
  size_t i;
  void* res;
  bool exact,best;
  if (size==1){
    return copy(man,tab[0]);
  }
  else {
    res = meetjoin(man,false,tab[0],tab[1]);
    exact = man->result.flag_exact;
    best =  man->result.flag_best;
    for (i=2; i<size; i++){
      res = meetjoin(man,true,res,tab[i]);
      exact = exact && man->result.flag_exact;
      best =  best && man->result.flag_best;
    }
    man->result.flag_exact = exact;
    man->result.flag_best = best;
    return res;
  }
}

/* ============================================================ */
/*  Meet with array of constraints */
/* ============================================================ */

void*
ap_generic_meet_quasilinearize_lincons_array(ap_manager_t* man,
					     bool destructive,
					     void* abs,
					     ap_lincons0_array_t array,
					     ap_scalar_discr_t discr,
					     bool linearize,
					     void* (*meet_lincons_array)(ap_manager_t*,
									 bool, void*,
									 ap_lincons0_array_t))
{
  void* (*copy)(ap_manager_t*,...) = man->funptr[AP_FUNID_COPY];
  bool (*is_bottom)(ap_manager_t*,...) = man->funptr[AP_FUNID_IS_BOTTOM];
  void (*to_box)(ap_manager_t*,...) = man->funptr[AP_FUNID_TO_BOX];
  ap_dimension_t (*dimension)(ap_manager_t*,...) = man->funptr[AP_FUNID_DIMENSION];
  size_t size;
  ap_dimension_t dim;
  ap_linexpr0_t env;
  bool exact;
  void* res;

  man->result.flag_exact = man->result.flag_best = true;

  size = ap_lincons0_array_size(array);
  if (is_bottom(man,abs) || size==0){
    res = destructive ? abs : copy(abs);
  }
  else {
    ap_linexpr_type_t typ = ap_lincons0_array_type(array);
    if (typ==AP_LINEXPR_LINEAR || (!linearize && typ==AP_LINEXPR_QUASILINEAR)){
      res = meet_lincons_array(man,destructive,abs,array);
    }
    else {
      dim = dimension(man,abs);
      ap_linexpr0_init(env,discr,0);
      to_box(man,env,abs);
      MACRO_SWITCH(discr) XXX {
	ap_linconsXXX_array_t arrayX;
	ap_lincons0_array_t array0;
	ap_linconsXXX_array_init(arrayX,0);
	exact = ap_linconsXXX_array_set_lincons0_array(arrayX,array,man->num);
	exact = ap_linconsXXX_array_quasilinearize(arrayX,
						   env->linexpr.XXX,true,
						   man->num) && exact;
	ap_lincons0_array_cons_XXX(array0,arrayX);
	res = meet_lincons_array(man,destructive,abs,array0);
	ap_linconsXXX_array_clear(arrayX);
	ap_linexpr0_clear(env);
      }
      ENDMACRO;
      man->result.flag_exact &= exact;
    }
  }
  return res;
}

void*
ap_generic_meet_intlinearize_tcons_array(ap_manager_t* man,
					 bool destructive,
					 void* abs,
					 ap_tcons0_array_t* array,
					 ap_scalar_discr_t discr,
					 ap_linexpr_type_t linearize,
					 void* (*meet_lincons_array)(ap_manager_t*,
								     bool, void*,
								     ap_lincons0_array_t))
{
  void* (*copy)(ap_manager_t*,...) = man->funptr[AP_FUNID_COPY];
  bool (*is_bottom)(ap_manager_t*,...) = man->funptr[AP_FUNID_IS_BOTTOM];
  void (*to_box)(ap_manager_t*,...) = man->funptr[AP_FUNID_TO_BOX];
  ap_dimension_t (*dimension)(ap_manager_t*,...) = man->funptr[AP_FUNID_DIMENSION];
  size_t size;
  ap_dimension_t dim;
  ap_linexpr0_t env;
  bool exact;
  void* res;

  exact = true;
  man->result.flag_exact = man->result.flag_best = true;

  if (is_bottom(man,abs) || array->size==0){
    res = destructive ? abs : copy(man,abs);
  }
  else {
    ap_dimension_t dim = dimension(man,abs);
    MACRO_SWITCH(discr) XXX {
      bool error,exact;
      ap_linconsXXX_array_t arrayX;
      ap_lincons0_array_t array0;

      ap_linconsXXX_array_init(arrayX,0);
      exact = ap_linconsXXX_array_set_tcons0_array(arrayX,&error,array,man->num);
      if (error){
	ap_linexpr0_init(env,discr,0);
	to_box(man,env,abs);
	exact = false;
	ap_linconsXXX_array_intlinearize_tcons0_array(arrayX,array,
						      env->linexpr.XXX,dim.intd,
						      man->num);
      }
      ap_linexpr_type_t typ = ap_linconsXXX_array_type(arrayX);
      while (typ<linearize){
	switch (typ){
	case AP_LINEXPR_INTLINEAR:
	  if (!error){
	    error = true;
	    ap_linexpr0_init(env,discr,0);
	    to_box(man,env,abs);
	  }
	  exact = ap_linconsXXX_array_quasilinearize(arrayX,
						     env->linexpr.XXX,true,
						     man->num) && exact;
	  typ = AP_LINEXPR_QUASILINEAR;
	  break;
	case AP_LINEXPR_QUASILINEAR:
	  ap_linconsXXX_array_linearize(arrayX,true,man->num);
	  typ = AP_LINEXPR_LINEAR;
	  break;
	default:
	  assert(false);
	}
      }
      tbool_t tb =
	ap_linconsXXX_array_reduce_integer(arrayX,dim.intd,man->num);
      if (tb==tbool_false){
	if (destructive){
	  void* (*afree)(ap_manager_t*, void*) = man->funptr[AP_FUNID_FREE];
	  afree(abs,abs);
	}
	void* (*bottom)(ap_manager_t*, ap_dimension_t) = man->funptr[AP_FUNID_BOTTOM];
	res = bottom(man,dim);
	exact = true;
      }
      else if (tb==tbool_true){
	res = destructive ? abs : copy(man,abs);
      }
      else {
	ap_lincons0_array_cons_XXX(array0,arrayX);
	res = meet_lincons_array(man,destructive,abs,array0);
      }
      ap_linconsXXX_array_clear(arrayX);
      if (error) ap_linexpr0_clear(env);
    }
    ENDMACRO;
    man->result.flag_exact &= exact;
  }
  return res;
}

/* ============================================================ */
/*  Assignments/Substitutions */
/* ============================================================ */

/*
   This function implements generic parallel assignment/substitution
   operations by:
   1. introducing primed dimensions
   2. transforming linear expressions into equality constraints relating the
      assigned primed dimension and the linear expression
   If dest!=NULL
     3. introducing primed dimensions in dest
     4. exchanging primed and unprimed dimensions in dest
     5. intersecting the abstract value with the modified dest
   6. intersecting the obtained abstract value with the constraints
   7. exchanging primed and unprimed dimensions
   8. removing the introduced (primed) dimensions

   It relies on: is_bottom, copy, dimension, add_dimensions,
   permute_dimensions, remove_dimensions, meet_lincons_array, meet and free
   abstract operations.

   Meaning of parameters:
   - assign selects the operation: true means assignment, false substitution
   - The other parameters have the meaning they have for parallel
     assignment/substitution
*/

void*
ap_generic_asssub_linexpr_array(bool assign,
				ap_scalar_discr_t discr,
				ap_manager_t* man,
				bool destructive, void* abs,
				ap_dim_t* tdim, ap_linexpr0_array_t texpr,
				void* dest)
{
  bool (*is_bottom)(ap_manager_t*,...) = man->funptr[AP_FUNID_IS_BOTTOM];
  void* (*copy)(ap_manager_t*,...) = man->funptr[AP_FUNID_COPY];
  void* (*add_dimensions)(ap_manager_t*,...) = man->funptr[AP_FUNID_ADD_DIMENSIONS];
  void* (*permute_dimensions)(ap_manager_t*,...) = man->funptr[AP_FUNID_PERMUTE_DIMENSIONS];
  void* (*remove_dimensions)(ap_manager_t*,...) = man->funptr[AP_FUNID_REMOVE_DIMENSIONS];
  void* (*meet_lincons_array)(ap_manager_t*,...) = man->funptr[AP_FUNID_MEET_LINCONS_ARRAY];
  void* (*meet)(ap_manager_t*,...) = man->funptr[AP_FUNID_MEET];
  void (*ap_free)(ap_manager_t*,...) = man->funptr[AP_FUNID_FREE];
  ap_dimension_t (*dimension)(ap_manager_t*,...) = man->funptr[AP_FUNID_DIMENSION];
  size_t i,size;
  ap_dimension_t d, dsup;
  ap_dimchange_t dimchange;
  ap_dimperm_t permutation;
  ap_lincons0_array_t array;
  void* abs2;
  bool exact,best;

  if (is_bottom(man,abs)){
    man->result.flag_exact = man->result.flag_best = true;
    return destructive ? abs : copy(man,abs);
  }
  size = ap_linexpr0_array_size(texpr);
  /* 1. Compute the number of integer and real dimensions assigned */
  d = dimension(man,abs);
  dsup = ap_dimension_make(0,0);
  for (i=0; i<size; i++){
    if (tdim[i]<d.intd)
      dsup.intd++;
    else
      dsup.reald++;
  }
  /* 2. Build dimchange (for addition of primed dimensions) */
  ap_dimchange_init(&dimchange,dsup);
  for (i=0;i<dsup.intd;i++)
    dimchange.p[i]=d.intd;
  for (i=dsup.intd;i<dsup.intd+dsup.reald;i++)
    dimchange.p[i]=d.intd+d.reald;

  /* 3. Build permutation (exchanging primed and unprimed dimensions) */
  ap_dimperm_init(&permutation,d.intd+d.reald+dsup.intd+dsup.reald);
  ap_dimperm_set_id(&permutation);
  {
    int index_int = 0;
    int index_real = 0;
    for (i=0; i<size; i++){
      ap_dim_t dim = tdim[i];
      ap_dim_t dimp;
      if (dim<d.intd){
	dimp = d.intd+index_int;
	index_int++;
      } else {
	dim += dsup.intd;
	dimp = d.intd+dsup.intd+d.reald+index_real;
	index_real++;
      }
      permutation.p[dim] = dimp;
      permutation.p[dimp] = dim;
    }
  }
  /* 4. Add primed dimensions to abstract value */
  abs2 = add_dimensions(man,destructive,abs,&dimchange,false);
  exact = man->result.flag_exact;
  best =  man->result.flag_best;
  /* From now, work by side-effect on abs2 */

  /* 5. Build constraints system
     An assignment x'_i := a_ij x_j + b_i becomes
     an equality constraint -x'_i + a_ij x_j + b_i = 0
     Primed and unprimed dimensiosn permuted if dest!=NULL
  */
  MACRO_SWITCH(discr) XXX {
    ap_linconsXXX_array_t arrayXXX;
    ap_linexpr0_t linexpr0;
    eitvXXX_t eitv;
    ap_linconsXXX_array_init(arrayXXX,size);
    eitvXXX_init(eitv);
    eitvXXX_set_int(eitv,-1);
    for (i=0; i<size; i++){
      ap_dim_t dim = tdim[i];
      ap_dim_t dimp = permutation.p[dim];
      ap_linexpr0_array_ref_index(linexpr0,texpr,i);
      exact = ap_linexprXXX_set_linexpr0(arrayXXX->p[i]->linexpr,linexpr0,man->num) && exact;
      ap_linexprXXX_add_dimensions(arrayXXX->p[i]->linexpr,
				   arrayXXX->p[i]->linexpr,&dimchange);
      ap_linexprXXX_set_eitv0(arrayXXX->p[i]->linexpr,dimp,eitv);
      arrayXXX->p[i]->constyp = AP_CONS_EQ;
    }
    eitvXXX_clear(eitv);
    ap_lincons0_array_cons_XXX(array,arrayXXX);
  }
  ENDMACRO;
  /* 6. Permute unprimed and primed dimensions if !assign */
  if (!assign){
    abs2 = permute_dimensions(man,true,abs2,&permutation);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;
  }
  /* 7. If dest!=NULL, perform intersection */
  if (dest!=NULL){
    void* dest2 = add_dimensions(man,false,dest,&dimchange,false);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;

    if (assign){
      dest2 = permute_dimensions(man,true,dest2,&permutation);
      exact = exact && man->result.flag_exact;
      best =  best && man->result.flag_best;
    }
    abs2 = meet(man,true,abs2,dest2);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;

    ap_free(man,dest2);
  }
  /* 8. Perform meet of abs2 with constraints */
  abs2 = meet_lincons_array(man,true,abs2,array);
  exact = exact && man->result.flag_exact;
  best =  best && man->result.flag_best;

  /* 9. Permute unprimed and primed dimensions if assign */
  if (assign){
    abs2 = permute_dimensions(man,true,abs2,&permutation);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;
  }
  /* 10. Remove extra dimensions */
  ap_dimchange_add_invert(&dimchange);
  abs2 = remove_dimensions(man,true,abs2,&dimchange);
  exact = exact && man->result.flag_exact;
  best =  best && man->result.flag_best;

  /* 11. Free allocated objects */
  ap_dimperm_clear(&permutation);
  ap_dimchange_clear(&dimchange);
  MACRO_SWITCH(discr) XXX {
    ap_linconsXXX_array_clear(array->lincons_array.XXX);
  }
  ENDMACRO;
  man->result.flag_exact = exact;
  man->result.flag_best = best;
  return abs2;
}

void* ap_generic_asssub_texpr_array(bool assign,
				    ap_manager_t* man,
				    bool destructive, void* abs,
				    ap_dim_t* tdim, ap_texpr0_array_t* texpr,
				    void* dest)
{
  bool (*is_bottom)(ap_manager_t*,...) = man->funptr[AP_FUNID_IS_BOTTOM];
  void* (*copy)(ap_manager_t*,...) = man->funptr[AP_FUNID_COPY];
  void* (*add_dimensions)(ap_manager_t*,...) = man->funptr[AP_FUNID_ADD_DIMENSIONS];
  void* (*permute_dimensions)(ap_manager_t*,...) = man->funptr[AP_FUNID_PERMUTE_DIMENSIONS];
  void* (*remove_dimensions)(ap_manager_t*,...) = man->funptr[AP_FUNID_REMOVE_DIMENSIONS];
  void* (*meet_tcons_array)(ap_manager_t*,...) = man->funptr[AP_FUNID_MEET_TCONS_ARRAY];
  void* (*meet)(ap_manager_t*,...) = man->funptr[AP_FUNID_MEET];
  void (*ap_free)(ap_manager_t*,...) = man->funptr[AP_FUNID_FREE];
  ap_dimension_t (*dimension)(ap_manager_t*,...) = man->funptr[AP_FUNID_DIMENSION];
  size_t i,size;
  ap_dimension_t d, dsup;
  ap_dimchange_t dimchange;
  ap_dimperm_t permutation;
  ap_tcons0_array_t array;
  void* abs2;
  bool exact,best;

  if (is_bottom(man,abs)){
    man->result.flag_exact = man->result.flag_best = true;
    return destructive ? abs : copy(man,abs);
  }
  size = ap_texpr0_array_size(texpr);
  /* 1. Compute the number of integer and real dimensions assigned */
  d = dimension(man,abs);
  dsup.intd = 0;
  dsup.reald = 0;
  for (i=0; i<size; i++){
    if (tdim[i]<d.intd)
      dsup.intd++;
    else
      dsup.reald++;
  }
  /* 2. Build dimchange (for addition of primed dimensions) */
  ap_dimchange_init(&dimchange,dsup);
  for (i=0;i<dsup.intd;i++)
    dimchange.p[i]=d.intd;
  for (i=dsup.intd;i<dsup.intd+dsup.reald;i++)
    dimchange.p[i]=d.intd+d.reald;

  /* 3. Build permutation (exchanging primed and unprimed dimensions) */
  ap_dimperm_init(&permutation,d.intd+d.reald+dsup.intd+dsup.reald);
  ap_dimperm_set_id(&permutation);
  {
    int index_int = 0;
    int index_real = 0;
    for (i=0; i<size; i++){
      ap_dim_t dim = tdim[i];
      ap_dim_t dimp;
      if (dim<d.intd){
	dimp = d.intd+index_int;
	index_int++;
      } else {
	dim += dsup.intd;
	dimp = d.intd+dsup.intd+d.reald+index_real;
	index_real++;
      }
      permutation.p[dim] = dimp;
      permutation.p[dimp] = dim;
    }
  }

  /* 4. Add primed dimensions to abstract value */
  abs2 = add_dimensions(man,destructive,abs,&dimchange,false);
  exact = man->result.flag_exact;
  best =  man->result.flag_best;
  /* From now, work by side-effect on abs2 */

  /* 5. Build constraints system
     An assignment x'_i := a_ij x_j + b_i becomes
     an equality constraint -x'_i + a_ij x_j + b_i = 0
  */
  array = ap_tcons0_array_make(size);
  for (i=0; i<size; i++){
    ap_dim_t dim = tdim[i];
    ap_dim_t dimp = permutation.p[dim];
    ap_texpr0_t* expr = ap_texpr0_add_dimensions(texpr->p[i],&dimchange);
    expr = ap_texpr0_binop(AP_TEXPR_SUB, expr, ap_texpr0_dim(dimp),
			   AP_RTYPE_REAL, AP_RDIR_RND);
    ap_tcons0_t* cons = ap_tcons0_make(expr,AP_CONS_EQ,NULL);
    array.p[i] = cons;
  }
  /* 6. Permute unprimed and primed dimensions if !assign */
  if (!assign){
    abs2 = permute_dimensions(man,true,abs2,&permutation);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;
  }
  /* 7. If dest!=NULL, perform intersection */
  if (dest!=NULL){
    void* dest2 = add_dimensions(man,false,dest,&dimchange,false);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;

    if (assign){
      dest2 = permute_dimensions(man,true,dest2,&permutation);
      exact = exact && man->result.flag_exact;
      best =  best && man->result.flag_best;
    }
    abs2 = meet(man,true,abs2,dest2);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;

    ap_free(man,dest2);
  }
  /* 8. Perform meet of abs2 with constraints */
  abs2 = meet_tcons_array(man,true,abs2,&array);
  exact = exact && man->result.flag_exact;
  best =  best && man->result.flag_best;

  /* 9. Permute unprimed and primed dimensions if assign */
  if (assign){
    abs2 = permute_dimensions(man,true,abs2,&permutation);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;
  }
  /* 10. Remove extra dimensions */
  ap_dimchange_add_invert(&dimchange);
  abs2 = remove_dimensions(man,true,abs2,&dimchange);
  exact = exact && man->result.flag_exact;
  best =  best && man->result.flag_best;

  /* 11. Free allocated objects */
  ap_dimperm_clear(&permutation);
  ap_dimchange_clear(&dimchange);
  ap_tcons0_array_clear(&array);

  man->result.flag_exact = exact;
  man->result.flag_best = best;
  return abs2;
}
