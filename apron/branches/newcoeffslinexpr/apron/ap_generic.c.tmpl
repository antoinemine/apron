/* -*- mode: c -*- */
/* ************************************************************************* */
/* ap_generic: generic functions for library implementors */
/* ************************************************************************* */

/* This file is part of the APRON Library, released under LGPL license.  Please
   read the COPYING file packaged in the distribution */

#include "ap_generic.h"
/* These functions are dedicated to implementors of domains. They offer generic
   default implementations for some of the operations required by the APRON
   API, when there is no more specific and efficient implementation for the
   domain being implemented.

   To use them, the function allocating manager, which is specific to the
   domain, should put the corresponding pointers in the virtual table to
   them.

   They manipulated "unboxed" abstract values, which are native to the
   underlying library: they are not yet boxed with the manager in the type
   ap_abstract0_t.
*/

/* ********************************************************************** */
/* I. Constructors */
/* ********************************************************************** */

void ap_generic_bound_support(
    ap_manager_t* man,
    ap_linexpr0_t env, /* out*/
    void* a,
    ap_dim_t* support,
    size_t size
)
{
  void (*bound_dimension)(ap_manager_t*,ap_coeff_t,void*,ap_dim_t) = man->funptr[AP_FUNID_BOUND_DIMENSION];
  size_t i;
  ap_coeff_t coeff;

  ap_linexpr0_set_zero(env);
  for (i=0;i<size;i++){
    ap_linexpr0_coeffref(coeff,env,support[i]);
    bound_dimension(man,coeff,a,support[i]);
  }
}

MACRO_FOREACH SSS ("","_array")
MACRO_FOREACH TTT ("expr","cons")
MACRO_FOREACH ZZZ @MainNum
MACRO_FOREACH III ("","interval")
void ap_generic_bound_supportIII_linTTTZZZSSS(
    ap_manager_t* man, ap_linexpr0_t env, /*out */
    void* a, ap_linTTTZZZSSS_t expr
)
{
  size_t i,size,size_support;
  ap_dim_t* support;

  size = ap_linTTTZZZSSS_max_dim(expr);
  support = malloc(size*sizeof(ap_dim_t));
  size_support = ap_linTTTZZZSSS_supportIII(expr,support,size);
  ap_generic_bound_support(man,env,a,support,size_support);
  free(support);
}
ENDMACRO
ENDMACRO
void ap_generic_bound_support_tTTT0SSS(
    ap_manager_t* man, ap_linexpr0_t env, /* out */
    void* a, ap_tTTT0SSS_t* expr
)
{
  size_t i,size,size_support;
  ap_dim_t* support;

  size = ap_tTTT0SSS_max_dim(expr);
  support = malloc(size*sizeof(ap_dim_t));
  size_support = ap_tTTT0SSS_support(expr,support,size);
  ap_generic_bound_support(man,env,a,support,size_support);
  free(support);
}
ENDMACRO
ENDMACRO

MACRO_FOREACH XXX @MainNum
bool
ap_generic_sat_linconsXXX_array_internal(
    ap_manager_t* man, void* abs, ap_linconsXXX_array_t arrayX, /* mutable: be careful ! */
    ap_linexpr_type_t linearize,
    ap_linexpr0_ptr penv, /* may be null */
    ap_linexpr_type_t boxize,
    bool* exact,
    bool (*sat_lincons)(ap_manager_t*,void*,ap_lincons0_t)
)
{
  ap_dimension_t (*dimension)(ap_manager_t*,void*) = man->funptr[AP_FUNID_DIMENSION];
  if (sat_lincons==NULL) sat_lincons = man->funptr[AP_FUNID_SAT_LINCONS];
  ap_linexpr0_t env;
  unsigned int i;
  ap_dim_t d;
  eitvXXX_t eitv0;
  bool res;
  bool best;
  ap_linexpr_type_t typ = ap_linconsXXX_array_type(arrayX);

  if (typ<=boxize){
    eitvXXX_init(eitv0);
    if (!penv){
      ap_linexpr0_init(env,AP_SCALAR_XXX,0);
      penv = env;
      ap_generic_bound_support_linconsXXX_array(man,penv,abs,arrayX);
    } else {
      if (penv->discr!=AP_SCALAR_XXX) abort();
    }
    res = true;
    for (i=0;i<arrayX->size;i++){
      *exact = ap_linexprXXX_eval(eitv0,arrayX->p[i]->linexpr,penv->linexpr.XXX,man->num) && *exact;
      switch (arrayX->p[i]->constyp){
      case AP_CONS_EQ:
	if (!eitvXXX_is_zero(eitv0)) res = false;
	break;
      case AP_CONS_SUP:
	if (boundXXX_sgn(eitv0->itv->neginf)>=0) res = false;
	break;
      case AP_CONS_SUPEQ:
	if (boundXXX_sgn(eitv0->itv->neginf)>0) res = false;
	break;
      default:
	res = false;
      }
      if (res==false) break;
    }
    eitvXXX_clear(eitv0);
    if (res){
      if (penv==env) ap_linexpr0_clear(env);
      return res;
    }
  }
  while (typ<linearize){
    switch (typ){
    case AP_LINEXPR_INTLINEAR:
      if (!penv){
	ap_linexpr0_init(env,AP_SCALAR_XXX,0);
	penv = env;
	ap_generic_bound_support_linconsXXX_array(man,penv,abs,arrayX);
      }
      *exact = false;
      ap_linconsXXX_array_quasilinearize(arrayX, penv->linexpr.XXX,false,
					 man->num);
      typ = AP_LINEXPR_QUASILINEAR;
      break;
    case AP_LINEXPR_QUASILINEAR:
      ap_linconsXXX_array_linearize(arrayX,false,man->num);
      typ = AP_LINEXPR_LINEAR;
      break;
    default:
      assert(false);
    }
  }
  res = true;
  best = true;
  for (i=0;i<arrayX->size;i++){
    ap_lincons0_t cons0;
    ap_lincons0_cons_XXX(cons0,arrayX->p[i]);
    bool res0 = sat_lincons(man,abs,cons0);
    best = best && man->result.flag_best;
    if (res0==false){
      res = false;
      break;
    }
  }
  if (penv==env) ap_linexpr0_clear(env);
  man->result.flag_best = best;
  man->result.flag_exact = exact;
  return res;
}
bool
ap_generic_bound_linexprXXX_internal(
    ap_manager_t* man, eitvXXX_t eitv, void* abs,
    ap_linexprXXX_t exprX, /* mutable: be careful ! */
    bool quasilinearize,
    ap_linexpr0_ptr penv, /* may be null */
    ap_linexpr_type_t boxize,
    bool* exact,
    void (*bound_linexpr)(ap_manager_t*,ap_coeff_t,void*,ap_linexpr0_t)
)
{
  ap_dimension_t (*dimension)(ap_manager_t*,...) = man->funptr[AP_FUNID_DIMENSION];
  if (bound_linexpr==NULL) bound_linexpr = man->funptr[AP_FUNID_BOUND_LINEXPR];
  ap_linexpr0_t env;
  unsigned int i;
  ap_dim_t d;
  eitvXXX_t eitv0;
  bool res;
  ap_linexpr_type_t typ = ap_linexprXXX_type(exprX);

  if (typ<=boxize){
    eitvXXX_init(eitv0);
    if (!penv){
      ap_linexpr0_init(env,AP_SCALAR_XXX,0);
      penv = env;
      ap_generic_bound_support_linexprXXX(man,penv,abs,exprX);
    } else {
      if (penv->discr!=AP_SCALAR_XXX) abort();
    }
    res = true;
    *exact = ap_linexprXXX_eval(eitv0,exprX,penv->linexpr.XXX,man->num) && *exact;
  }
  if (typ==AP_LINEXPR_INTLINEAR){
    if (!penv){
      ap_linexpr0_init(env,AP_SCALAR_XXX,0);
      penv = env;
      ap_generic_bound_support_linexprXXX(man,penv,abs,exprX);
    }
    *exact = false;
    ap_linexprXXX_quasilinearize(exprX, penv->linexpr.XXX,false,
				 man->num);
  }
  ap_coeff_t coeff;
  ap_linexpr0_t expr0;
  ap_coeff_cons_eitvXXX(coeff,eitv);
  ap_linexpr0_cons_XXX(expr0,exprX);
  bound_linexpr(man,coeff,abs,expr0);
  if (penv==env) ap_linexpr0_clear(env);
  if (typ<=boxize){
    eitvXXX_meet(eitv,eitv,eitv0);
    eitvXXX_clear(eitv0);
  }
  man->result.flag_exact = man->result.flag_exact && exact;
  return res;
}
ENDMACRO
bool ap_generic_sat_lincons(
    ap_manager_t* man, void* abs, ap_lincons0_t cons,
    ap_scalar_discr_t discr,
    ap_linexpr_type_t linearize, ap_linexpr_type_t boxize,
    bool (*sat_lincons)(ap_manager_t*,void*,ap_lincons0_t)
)
{
  ap_dimension_t (*dimension)(ap_manager_t*,void*) = man->funptr[AP_FUNID_DIMENSION];
  bool (*is_bottom)(ap_manager_t*,void*) = man->funptr[AP_FUNID_IS_BOTTOM];
  if (sat_lincons==NULL) sat_lincons = man->funptr[AP_FUNID_SAT_LINCONS];
  ap_dimension_t dim;
  bool error;
  ap_linexpr0_t env;
  ap_linexpr0_ptr penv;
  ap_lincons0_t lincons0;
  bool exact,res;

  if (is_bottom(man,abs)){
    man->result.flag_exact = man->result.flag_best = true;
    return true;
  }
  MACRO_SWITCH(discr) XXX {
    ap_linconsXXX_array_t arrayX;

    ap_linconsXXX_array_init(arrayX,1);
    exact = ap_linconsXXX_set_lincons0(arrayX->p[0],cons,man->num);
    res = ap_generic_sat_linconsXXX_array_internal(
	man,abs,arrayX,linearize,NULL,boxize,&exact,
	sat_lincons
    );
    ap_linconsXXX_array_clear(arrayX);
  }
  ENDMACRO;
  man->result.flag_exact =  man->result.flag_exact && exact;
  return res;
}
bool ap_generic_sat_tcons(
    ap_manager_t* man, void* abs, ap_tcons0_t* cons,
    ap_scalar_discr_t discr,
    ap_linexpr_type_t linearize, ap_linexpr_type_t boxize,
    bool (*sat_lincons)(ap_manager_t*,void*,ap_lincons0_t)
)
{
  ap_dimension_t (*dimension)(ap_manager_t*,void*) = man->funptr[AP_FUNID_DIMENSION];
  bool (*is_bottom)(ap_manager_t*,void*) = man->funptr[AP_FUNID_IS_BOTTOM];
  if (sat_lincons==NULL) sat_lincons = man->funptr[AP_FUNID_SAT_LINCONS];
  ap_dimension_t dim;
  bool error;
  ap_linexpr0_t env;
  ap_linexpr0_ptr penv;
  ap_lincons0_t lincons0;
  bool exact,res;

  if (is_bottom(man,abs)){
    man->result.flag_exact = man->result.flag_best = true;
    return true;
  }
  MACRO_SWITCH(discr) XXX {
    ap_linconsXXX_array_t arrayX;

    ap_linconsXXX_array_init(arrayX,1);
    exact = ap_linconsXXX_set_tcons0(arrayX->p[0],&error,cons,man->num);
    if (error){
      ap_linexpr0_init(env,discr,0);
      ap_generic_bound_support_tcons0(man,env,abs,cons);
      dim = dimension(man,abs);
      penv = env;
      exact = false;
      ap_linconsXXX_intlinearize_tcons0(arrayX->p[0],cons,
					env->linexpr.XXX,dim.intd,
					man->num);
    } else {
      penv = NULL;
    }
    res =
      ap_generic_sat_linconsXXX_array_internal(
	  man,abs,arrayX,linearize,penv,boxize,&exact,
	  sat_lincons);
    ap_linconsXXX_array_clear(arrayX);
  }
  ENDMACRO;
  if (penv) ap_linexpr0_clear(env);
  man->result.flag_exact =  man->result.flag_exact && exact;
  return res;
}

/*
   This function implements a generic bound_texpr operation using linearisation
   and bound_linexpr
*/
void
ap_generic_bound_linexpr(
    ap_manager_t* man, ap_coeff_t interval,
    void* abs, ap_linexpr0_t linexpr,
    ap_scalar_discr_t discr, bool quasilinearize, ap_linexpr_type_t boxize,
    void (*bound_linexpr)(ap_manager_t*,ap_coeff_t,void*,ap_linexpr0_t)
)
{
  bool (*is_bottom)(ap_manager_t*,void*) = man->funptr[AP_FUNID_IS_BOTTOM];
  if (bound_linexpr==NULL) bound_linexpr = man->funptr[AP_FUNID_BOUND_LINEXPR];
  ap_dimension_t (*dimension)(ap_manager_t*,void*) = man->funptr[AP_FUNID_DIMENSION];
  bool error,exact;
  ap_dimension_t dim;

  man->result.flag_exact = man->result.flag_best = true;
  if (is_bottom(man,abs)){
    ap_coeff_set_bottom(interval);
    return;
  }
  MACRO_SWITCH(discr) XXX {
    ap_linexprXXX_t linexprX;
    eitvXXX_t eitv,eitv0;
    eitvXXX_ptr peitv;
    ap_linexprXXX_init(linexprX,0);
    ap_linexprXXX_set_linexpr0(linexprX,linexpr,man->num);
    if (interval->discr==discr){
      peitv = interval->eitv.XXX;
    } else {
      eitvXXX_init(eitv);
      peitv = eitv;
    }
    exact = true;
    ap_generic_bound_linexprXXX_internal(
	man,peitv,abs,linexprX,
	quasilinearize,NULL,boxize,&exact,
	bound_linexpr
    );
    if (interval->discr!=discr){
      ap_coeff_set_eitvXXX(interval,eitv,man->num);
      eitvXXX_clear(eitv);
    }
    ap_linexprXXX_clear(linexprX);
  }
  ENDMACRO;
  man->result.flag_exact = man->result.flag_exact && exact;
  return;
}
void
ap_generic_bound_texpr(
    ap_manager_t* man, ap_coeff_t interval,
    void* abs, ap_texpr0_t* expr,
    ap_scalar_discr_t discr, bool quasilinearize, ap_linexpr_type_t boxize,
    void (*bound_linexpr)(ap_manager_t*,ap_coeff_t,void*,ap_linexpr0_t)
)
{
  bool (*is_bottom)(ap_manager_t*,void*) = man->funptr[AP_FUNID_IS_BOTTOM];
  if (bound_linexpr==NULL) bound_linexpr = man->funptr[AP_FUNID_BOUND_LINEXPR];
  ap_dimension_t (*dimension)(ap_manager_t*,void*) = man->funptr[AP_FUNID_DIMENSION];
  bool error,exact;
  ap_dimension_t dim;
  ap_linexpr0_t env;
  ap_linexpr0_ptr penv;

  man->result.flag_exact = man->result.flag_best = true;
  if (is_bottom(man,abs)){
    ap_coeff_set_bottom(interval);
    return;
  }
  MACRO_SWITCH(discr) XXX {
    ap_linexprXXX_t linexprX;
    eitvXXX_t eitv,eitv0;
    eitvXXX_ptr peitv;
    ap_linexprXXX_init(linexprX,0);
    exact = ap_linexprXXX_set_texpr0(linexprX,&error,expr,man->num);
    if (error){
      ap_linexpr0_init(env,discr,0);
      ap_generic_bound_support_texpr0(man,env,abs,expr);
      dim = dimension(man,abs);
      penv = env;
      exact = false;
      ap_linexprXXX_intlinearize_texpr0(linexprX,expr,
					env->linexpr.XXX,dim.intd,
					man->num);
      eitvXXX_init(eitv0);
      eitvXXX_eval_ap_texpr0(eitv0,expr,penv->linexpr.XXX,man->num);
    } else {
      penv = NULL;
    }
    if (eitvXXX_is_bottom(linexprX->cst)){
      ap_linexprXXX_clear(linexprX);
      if (penv) ap_linexpr0_clear(env);
      if (error) eitvXXX_clear(eitv0);
      ap_coeff_set_bottom(interval);
      return;
    }
    if (interval->discr==discr){
      peitv = interval->eitv.XXX;
    } else {
      eitvXXX_init(eitv);
      peitv = eitv;
    }
    ap_generic_bound_linexprXXX_internal(
	man,peitv,abs,linexprX,
	quasilinearize,penv,boxize,&exact,
	bound_linexpr
    );
    if (error){
      eitvXXX_meet(peitv,peitv,eitv0);
      eitvXXX_clear(eitv0);
    }
    if (interval->discr!=discr){
      ap_coeff_set_eitvXXX(interval,eitv,man->num);
      eitvXXX_clear(eitv);
    }
    ap_linexprXXX_clear(linexprX);
  }
  ENDMACRO;
  if (penv) ap_linexpr0_clear(env);
  man->result.flag_exact = man->result.flag_exact && exact;
  return;
}

ap_tcons0_array_t
ap_generic_to_tcons_array(ap_manager_t* man,
			  void* abs,
			  ap_scalar_discr_t discr)
{
  void (*to_lincons_array)(ap_manager_t*,ap_lincons0_array_t,void*) = man->funptr[AP_FUNID_TO_LINCONS_ARRAY];
  ap_lincons0_array_t linarray;
  ap_tcons0_array_t array;

  ap_lincons0_array_init(linarray,discr,0);
  to_lincons_array(man,linarray,abs);
  array = ap_tcons0_array_from_lincons0_array(linarray);
  ap_lincons0_array_clear(linarray);
  return array;
}


/* ********************************************************************** */
/* II. Operations */
/* ********************************************************************** */

/* ============================================================ */
/*  Meet/Join on arrays of abstract values */
/* ============================================================ */

/*
   This function implements a generic meet/join_array operation using copy and meet
   operations.
*/
void* ap_generic_meetjoin_array(bool meet,
				ap_manager_t* man,
				void** tab, size_t size)
{
  void* (*copy)(ap_manager_t*,...) = man->funptr[AP_FUNID_COPY];
  void* (*meetjoin)(ap_manager_t*,...) = man->funptr[meet ? AP_FUNID_MEET : AP_FUNID_JOIN];
  size_t i;
  void* res;
  bool exact,best;
  if (size==1){
    return copy(man,tab[0]);
  }
  else {
    res = meetjoin(man,false,tab[0],tab[1]);
    exact = man->result.flag_exact;
    best =  man->result.flag_best;
    for (i=2; i<size; i++){
      res = meetjoin(man,true,res,tab[i]);
      exact = exact && man->result.flag_exact;
      best =  best && man->result.flag_best;
    }
    man->result.flag_exact = exact;
    man->result.flag_best = best;
    return res;
  }
}

/* ============================================================ */
/*  Meet with array of constraints */
/* ============================================================ */

MACRO_FOREACH XXX @MainNum
void*
ap_generic_meet_quasilinearize_linconsXXX_array_internal(
    ap_manager_t* man, bool destructive, void* abs,
    ap_linconsXXX_array_t arrayX, /* mutable: be careful ! */
    ap_linexpr_type_t linearize,
    ap_linexpr0_ptr penv, /* may be NULL */
    ap_linexpr_type_t boxize, unsigned int kmax,
    bool diffize, bool octagonal,
    bool* exact,
    void* (*meet_lincons_array)(ap_manager_t*,
				bool, void*,
				ap_lincons0_array_t)
)
{
  void* (*copy)(ap_manager_t*,...) = man->funptr[AP_FUNID_COPY];
  ap_dimension_t (*dimension)(ap_manager_t*,...) = man->funptr[AP_FUNID_DIMENSION];
  if (meet_lincons_array==NULL) meet_lincons_array = man->funptr[AP_FUNID_MEET_LINCONS_ARRAY];
  void* res;
  tbool_t tb;
  ap_lincons0_array_t array0;
  ap_linexpr0_t env;
  bool change;
  bool* tchange;

  ap_dimension_t dim = dimension(man,abs);
  ap_linexpr_type_t typ = ap_linconsXXX_array_type(arrayX);

  if (typ<=boxize){
    /* We deduce box constraints */
    unsigned int i;
    ap_dim_t d;
    eitvXXX_ptr eitv;

    /* Extract bouding box from abs if needed */
    if (!penv){
      ap_linexpr0_init(env,AP_SCALAR_XXX,0);
      penv = env;
      ap_generic_bound_support_linconsXXX_array(man,penv,abs,arrayX);
    } else {
      if (penv->discr!=AP_SCALAR_XXX) abort();
    }
    unsigned int size = ap_dimension_size(dim);
    tchange = malloc(2*size);
    for (unsigned int i=0;i<2*size;i++) tchange[i] = false;
    /* Extract bound constraints extracted from general constraints */
    change =
      ap_linconsXXX_array_boxize(
	  penv->linexpr.XXX,tchange,arrayX,
	  dim.intd,kmax,man->num
      );
    if (eitvXXX_is_bottom(penv->linexpr.XXX->cst)){
      void* (*bottom)(ap_manager_t*,ap_dimension_t) = man->funptr[AP_FUNID_BOTTOM];
      res = bottom(man,dim);
      if (destructive){
	void (*afree)(ap_manager_t*,void*) = man->funptr[AP_FUNID_FREE];
	afree(man,abs);
      }
      free(tchange);
      goto ap_generic_meet_quasilinearize_linconsXXX_array_internal_exit;
    }
  }
  else {
    change = false;
    tchange = NULL;
  }
  /* Cannot add boxized constraint now, because with more constrained
     environment some constraints can disappear. For instance, if we inferred
     x0=1, then in env we also have x0=1, and the linearisation algorithm
     will replace x0=1 with 1=1. */

  /* Quasi or full linearization, using possibly the improved environment. */
  while (typ<linearize){
    switch (typ){
    case AP_LINEXPR_INTLINEAR:
      if (!penv){
	ap_linexpr0_init(env,AP_SCALAR_XXX,0);
	penv = env;
	ap_generic_bound_supportinterval_linconsXXX_array(man,penv,abs,arrayX);
      }
      *exact = ap_linconsXXX_array_quasilinearize(arrayX,
						  penv->linexpr.XXX,true,
						  man->num) && *exact;
      typ = AP_LINEXPR_QUASILINEAR;
      break;
    case AP_LINEXPR_QUASILINEAR:
      ap_linconsXXX_array_linearize(arrayX,true,man->num);
      typ = AP_LINEXPR_LINEAR;
      break;
    default:
      assert(false);
    }
  }
  /* Add possibly difference and sum constraints */
  if (typ!=AP_LINEXPR_INTLINEAR && diffize){
    ap_linconsXXX_array_extract_append_difference(
	arrayX, arrayX, penv->linexpr.XXX, dim.intd,
	octagonal, man->num
    );
  }
  /* Add possibly bound constraint */
  if (change){
    ap_linconsXXX_array_append_set_env(arrayX,penv->linexpr.XXX,tchange);
  }
  if (tchange){
    free(tchange);
  }
  /* Simplification s */
  tb = ap_linconsXXX_array_reduce_integer(arrayX,dim.intd,man->num);
  switch (tb){
  case tbool_false:
    if (destructive){
      void* (*afree)(ap_manager_t*, void*) = man->funptr[AP_FUNID_FREE];
      afree(man,abs);
    }
    void* (*bottom)(ap_manager_t*, ap_dimension_t) = man->funptr[AP_FUNID_BOTTOM];
    res = bottom(man,dim);
    *exact = true;
    break;
  case tbool_true:
    res = destructive ? abs : copy(man,abs);
    *exact = false; /* To be improved: no eqmod constraints */
    break;
  case tbool_top:
    ap_lincons0_array_cons_XXX(array0,arrayX);
    res = meet_lincons_array(man,destructive,abs,array0);
    break;
  default: abort();
  }
 ap_generic_meet_quasilinearize_linconsXXX_array_internal_exit:
  if (penv==env) ap_linexpr0_clear(env);
  return res;
}
ENDMACRO
void*
ap_generic_meet_quasilinearize_lincons_array(
    ap_manager_t* man, bool destructive, void* abs, ap_lincons0_array_t array,
    ap_scalar_discr_t discr,
    ap_linexpr_type_t linearize,
    ap_linexpr_type_t boxize, unsigned int kmax,
    bool diffize, bool octagonal,
    void* (*meet_lincons_array)(ap_manager_t*,
				bool, void*,
				ap_lincons0_array_t)
)
{
  void* (*copy)(ap_manager_t*,...) = man->funptr[AP_FUNID_COPY];
  bool (*is_bottom)(ap_manager_t*,...) = man->funptr[AP_FUNID_IS_BOTTOM];
  if (meet_lincons_array==NULL) meet_lincons_array = man->funptr[AP_FUNID_MEET_LINCONS_ARRAY];
  void* res;
  bool exact;

  exact = true;
  man->result.flag_exact = man->result.flag_best = true;

  size_t size = ap_lincons0_array_size(array);
  if (is_bottom(man,abs) || size==0){
    res = destructive ? abs : copy(man,abs);
  }
  else {
    MACRO_SWITCH(discr) XXX {
      ap_linconsXXX_array_t arrayX;

      ap_linconsXXX_array_init(arrayX,0);
      exact = ap_linconsXXX_array_set_lincons0_array(arrayX,array,man->num) && exact;
      res =
	ap_generic_meet_quasilinearize_linconsXXX_array_internal(
	    man,destructive,abs,arrayX,
	    linearize,NULL,
	    boxize,kmax,
	    diffize, octagonal,
	    &exact,
	    meet_lincons_array
	);
      ap_linconsXXX_array_clear(arrayX);
    }
    ENDMACRO;
    man->result.flag_exact &= exact;
  }
  return res;
}
void*
ap_generic_meet_intlinearize_tcons_array(
    ap_manager_t* man, bool destructive, void* abs, ap_tcons0_array_t* array,
    ap_scalar_discr_t discr, ap_linexpr_type_t linearize,
    ap_linexpr_type_t boxize, unsigned int kmax,
    bool diffize, bool octagonal,
    void* (*meet_lincons_array)(ap_manager_t*,
				bool, void*,
				ap_lincons0_array_t)
)
{
  void* (*copy)(ap_manager_t*,...) = man->funptr[AP_FUNID_COPY];
  bool (*is_bottom)(ap_manager_t*,...) = man->funptr[AP_FUNID_IS_BOTTOM];
  ap_dimension_t (*dimension)(ap_manager_t*,...) = man->funptr[AP_FUNID_DIMENSION];
  if (meet_lincons_array==NULL) meet_lincons_array = man->funptr[AP_FUNID_MEET_LINCONS_ARRAY];
  ap_dimension_t dim;
  ap_linexpr0_t env;
  ap_linexpr0_ptr penv;
  bool error,exact;
  void* res;

  exact = true;
  man->result.flag_exact = man->result.flag_best = true;

  if (is_bottom(man,abs) || array->size==0){
    res = destructive ? abs : copy(man,abs);
  }
  else {
    ap_dimension_t dim = dimension(man,abs);
    MACRO_SWITCH(discr) XXX {
      ap_linconsXXX_array_t arrayX;

      ap_linconsXXX_array_init(arrayX,0);
      exact = ap_linconsXXX_array_set_tcons0_array(arrayX,&error,array,man->num);
      if (error){
	ap_linexpr0_init(env,discr,0);
	ap_generic_bound_support_tcons0_array(man,env,abs,array);
	ap_linconsXXX_array_intlinearize_tcons0_array(arrayX,array,
						      env->linexpr.XXX,dim.intd,
						      man->num);
	penv = env;
	exact = false;
      } else {
	penv = NULL;
      }
      res =
	ap_generic_meet_quasilinearize_linconsXXX_array_internal(
	    man,destructive,abs,arrayX,
	    linearize,penv,
	    boxize,kmax,
	    diffize,octagonal,
	    &exact,
	    meet_lincons_array
	);
      ap_linconsXXX_array_clear(arrayX);
    }
    ENDMACRO;
    if (penv) ap_linexpr0_clear(env);
    man->result.flag_exact &= exact;
  }
  return res;
}

/* ============================================================ */
/*  Assignments/Substitutions */
/* ============================================================ */

/*
   This function implements generic parallel assignment/substitution
   operations by:
   1. introducing primed dimensions
   2. transforming linear expressions into equality constraints relating the
      assigned primed dimension and the linear expression
   If dest!=NULL
     3. introducing primed dimensions in dest
     4. exchanging primed and unprimed dimensions in dest
     5. intersecting the abstract value with the modified dest
   6. intersecting the obtained abstract value with the constraints
   7. exchanging primed and unprimed dimensions
   8. removing the introduced (primed) dimensions

   It relies on: is_bottom, copy, dimension, add_dimensions,
   permute_dimensions, remove_dimensions, meet_lincons_array, meet and free
   abstract operations.

   Meaning of parameters:
   - assign selects the operation: true means assignment, false substitution
   - The other parameters have the meaning they have for parallel
     assignment/substitution
*/

void*
ap_generic_asssub_linexpr_array(bool assign,
				ap_scalar_discr_t discr,
				ap_manager_t* man,
				bool destructive, void* abs,
				ap_dim_t* tdim, ap_linexpr0_array_t texpr,
				void* dest)
{
  bool (*is_bottom)(ap_manager_t*,...) = man->funptr[AP_FUNID_IS_BOTTOM];
  void* (*copy)(ap_manager_t*,...) = man->funptr[AP_FUNID_COPY];
  void* (*add_dimensions)(ap_manager_t*,...) = man->funptr[AP_FUNID_ADD_DIMENSIONS];
  void* (*permute_dimensions)(ap_manager_t*,...) = man->funptr[AP_FUNID_PERMUTE_DIMENSIONS];
  void* (*remove_dimensions)(ap_manager_t*,...) = man->funptr[AP_FUNID_REMOVE_DIMENSIONS];
  void* (*meet_lincons_array)(ap_manager_t*,...) = man->funptr[AP_FUNID_MEET_LINCONS_ARRAY];
  void* (*meet)(ap_manager_t*,...) = man->funptr[AP_FUNID_MEET];
  void (*ap_free)(ap_manager_t*,...) = man->funptr[AP_FUNID_FREE];
  ap_dimension_t (*dimension)(ap_manager_t*,...) = man->funptr[AP_FUNID_DIMENSION];
  size_t i,size;
  ap_dimension_t d, dsup;
  ap_dimchange_t dimchange;
  ap_dimperm_t permutation;
  ap_lincons0_array_t array;
  void* abs2;
  bool exact,best;

  if (is_bottom(man,abs)){
    man->result.flag_exact = man->result.flag_best = true;
    return destructive ? abs : copy(man,abs);
  }
  size = ap_linexpr0_array_size(texpr);
  /* 1. Compute the number of integer and real dimensions assigned */
  d = dimension(man,abs);
  dsup = ap_dimension_make(0,0);
  for (i=0; i<size; i++){
    if (tdim[i]<d.intd)
      dsup.intd++;
    else
      dsup.reald++;
  }
  /* 2. Build dimchange (for addition of primed dimensions) */
  ap_dimchange_init(&dimchange,dsup);
  for (i=0;i<dsup.intd;i++)
    dimchange.p[i]=d.intd;
  for (i=dsup.intd;i<dsup.intd+dsup.reald;i++)
    dimchange.p[i]=d.intd+d.reald;

  /* 3. Build permutation (exchanging primed and unprimed dimensions) */
  ap_dimperm_init(&permutation,d.intd+d.reald+dsup.intd+dsup.reald);
  ap_dimperm_set_id(&permutation);
  {
    int index_int = 0;
    int index_real = 0;
    for (i=0; i<size; i++){
      ap_dim_t dim = tdim[i];
      ap_dim_t dimp;
      if (dim<d.intd){
	dimp = d.intd+index_int;
	index_int++;
      } else {
	dim += dsup.intd;
	dimp = d.intd+dsup.intd+d.reald+index_real;
	index_real++;
      }
      permutation.p[dim] = dimp;
      permutation.p[dimp] = dim;
    }
  }
  /* 4. Add primed dimensions to abstract value */
  abs2 = add_dimensions(man,destructive,abs,&dimchange,false);
  exact = man->result.flag_exact;
  best =  man->result.flag_best;
  /* From now, work by side-effect on abs2 */

  /* 5. Build constraints system
     An assignment x'_i := a_ij x_j + b_i becomes
     an equality constraint -x'_i + a_ij x_j + b_i = 0
     Primed and unprimed dimensiosn permuted if dest!=NULL
  */
  MACRO_SWITCH(discr) XXX {
    ap_linconsXXX_array_t arrayXXX;
    ap_linexpr0_t linexpr0;
    eitvXXX_t eitv;
    ap_linconsXXX_array_init(arrayXXX,size);
    eitvXXX_init(eitv);
    eitvXXX_set_int(eitv,-1);
    for (i=0; i<size; i++){
      ap_dim_t dim = tdim[i];
      ap_dim_t dimp = permutation.p[dim];
      ap_linexpr0_array_ref_index(linexpr0,texpr,i);
      exact = ap_linexprXXX_set_linexpr0(arrayXXX->p[i]->linexpr,linexpr0,man->num) && exact;
      ap_linexprXXX_add_dimensions(arrayXXX->p[i]->linexpr,
				   arrayXXX->p[i]->linexpr,&dimchange);
      ap_linexprXXX_set_eitv0(arrayXXX->p[i]->linexpr,dimp,eitv);
      arrayXXX->p[i]->constyp = AP_CONS_EQ;
    }
    eitvXXX_clear(eitv);
    ap_lincons0_array_cons_XXX(array,arrayXXX);
  }
  ENDMACRO;
  /* 6. Permute unprimed and primed dimensions if !assign */
  if (!assign){
    abs2 = permute_dimensions(man,true,abs2,&permutation);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;
  }
  /* 7. If dest!=NULL, perform intersection */
  if (dest!=NULL){
    void* dest2 = add_dimensions(man,false,dest,&dimchange,false);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;

    if (assign){
      dest2 = permute_dimensions(man,true,dest2,&permutation);
      exact = exact && man->result.flag_exact;
      best =  best && man->result.flag_best;
    }
    abs2 = meet(man,true,abs2,dest2);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;

    ap_free(man,dest2);
  }
  /* 8. Perform meet of abs2 with constraints */
  abs2 = meet_lincons_array(man,true,abs2,array);
  exact = exact && man->result.flag_exact;
  best =  best && man->result.flag_best;

  /* 9. Permute unprimed and primed dimensions if assign */
  if (assign){
    abs2 = permute_dimensions(man,true,abs2,&permutation);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;
  }
  /* 10. Remove extra dimensions */
  ap_dimchange_add_invert(&dimchange);
  abs2 = remove_dimensions(man,true,abs2,&dimchange);
  exact = exact && man->result.flag_exact;
  best =  best && man->result.flag_best;

  /* 11. Free allocated objects */
  ap_dimperm_clear(&permutation);
  ap_dimchange_clear(&dimchange);
  MACRO_SWITCH(discr) XXX {
    ap_linconsXXX_array_clear(array->lincons_array.XXX);
  }
  ENDMACRO;
  man->result.flag_exact = exact;
  man->result.flag_best = best;
  return abs2;
}

void* ap_generic_asssub_texpr_array(bool assign,
				    ap_manager_t* man,
				    bool destructive, void* abs,
				    ap_dim_t* tdim, ap_texpr0_array_t* texpr,
				    void* dest)
{
  bool (*is_bottom)(ap_manager_t*,...) = man->funptr[AP_FUNID_IS_BOTTOM];
  void* (*copy)(ap_manager_t*,...) = man->funptr[AP_FUNID_COPY];
  void* (*add_dimensions)(ap_manager_t*,...) = man->funptr[AP_FUNID_ADD_DIMENSIONS];
  void* (*permute_dimensions)(ap_manager_t*,...) = man->funptr[AP_FUNID_PERMUTE_DIMENSIONS];
  void* (*remove_dimensions)(ap_manager_t*,...) = man->funptr[AP_FUNID_REMOVE_DIMENSIONS];
  void* (*meet_tcons_array)(ap_manager_t*,...) = man->funptr[AP_FUNID_MEET_TCONS_ARRAY];
  void* (*meet)(ap_manager_t*,...) = man->funptr[AP_FUNID_MEET];
  void (*ap_free)(ap_manager_t*,...) = man->funptr[AP_FUNID_FREE];
  ap_dimension_t (*dimension)(ap_manager_t*,...) = man->funptr[AP_FUNID_DIMENSION];
  size_t i,size;
  ap_dimension_t d, dsup;
  ap_dimchange_t dimchange;
  ap_dimperm_t permutation;
  ap_tcons0_array_t array;
  void* abs2;
  bool exact,best;

  if (is_bottom(man,abs)){
    man->result.flag_exact = man->result.flag_best = true;
    return destructive ? abs : copy(man,abs);
  }
  size = ap_texpr0_array_size(texpr);
  /* 1. Compute the number of integer and real dimensions assigned */
  d = dimension(man,abs);
  dsup.intd = 0;
  dsup.reald = 0;
  for (i=0; i<size; i++){
    if (tdim[i]<d.intd)
      dsup.intd++;
    else
      dsup.reald++;
  }
  /* 2. Build dimchange (for addition of primed dimensions) */
  ap_dimchange_init(&dimchange,dsup);
  for (i=0;i<dsup.intd;i++)
    dimchange.p[i]=d.intd;
  for (i=dsup.intd;i<dsup.intd+dsup.reald;i++)
    dimchange.p[i]=d.intd+d.reald;

  /* 3. Build permutation (exchanging primed and unprimed dimensions) */
  ap_dimperm_init(&permutation,d.intd+d.reald+dsup.intd+dsup.reald);
  ap_dimperm_set_id(&permutation);
  {
    int index_int = 0;
    int index_real = 0;
    for (i=0; i<size; i++){
      ap_dim_t dim = tdim[i];
      ap_dim_t dimp;
      if (dim<d.intd){
	dimp = d.intd+index_int;
	index_int++;
      } else {
	dim += dsup.intd;
	dimp = d.intd+dsup.intd+d.reald+index_real;
	index_real++;
      }
      permutation.p[dim] = dimp;
      permutation.p[dimp] = dim;
    }
  }

  /* 4. Add primed dimensions to abstract value */
  abs2 = add_dimensions(man,destructive,abs,&dimchange,false);
  exact = man->result.flag_exact;
  best =  man->result.flag_best;
  /* From now, work by side-effect on abs2 */

  /* 5. Build constraints system
     An assignment x'_i := a_ij x_j + b_i becomes
     an equality constraint -x'_i + a_ij x_j + b_i = 0
  */
  array = ap_tcons0_array_make(size);
  for (i=0; i<size; i++){
    ap_dim_t dim = tdim[i];
    ap_dim_t dimp = permutation.p[dim];
    ap_texpr0_t* expr = ap_texpr0_add_dimensions(texpr->p[i],&dimchange);
    expr = ap_texpr0_binop(AP_TEXPR_SUB, expr, ap_texpr0_dim(dimp),
			   AP_RTYPE_REAL, AP_RDIR_RND);
    ap_tcons0_t* cons = ap_tcons0_make(expr,AP_CONS_EQ,NULL);
    array.p[i] = cons;
  }
  /* 6. Permute unprimed and primed dimensions if !assign */
  if (!assign){
    abs2 = permute_dimensions(man,true,abs2,&permutation);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;
  }
  /* 7. If dest!=NULL, perform intersection */
  if (dest!=NULL){
    void* dest2 = add_dimensions(man,false,dest,&dimchange,false);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;

    if (assign){
      dest2 = permute_dimensions(man,true,dest2,&permutation);
      exact = exact && man->result.flag_exact;
      best =  best && man->result.flag_best;
    }
    abs2 = meet(man,true,abs2,dest2);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;

    ap_free(man,dest2);
  }
  /* 8. Perform meet of abs2 with constraints */
  abs2 = meet_tcons_array(man,true,abs2,&array);
  exact = exact && man->result.flag_exact;
  best =  best && man->result.flag_best;

  /* 9. Permute unprimed and primed dimensions if assign */
  if (assign){
    abs2 = permute_dimensions(man,true,abs2,&permutation);
    exact = exact && man->result.flag_exact;
    best =  best && man->result.flag_best;
  }
  /* 10. Remove extra dimensions */
  ap_dimchange_add_invert(&dimchange);
  abs2 = remove_dimensions(man,true,abs2,&dimchange);
  exact = exact && man->result.flag_exact;
  best =  best && man->result.flag_best;

  /* 11. Free allocated objects */
  ap_dimperm_clear(&permutation);
  ap_dimchange_clear(&dimchange);
  ap_tcons0_array_clear(&array);

  man->result.flag_exact = exact;
  man->result.flag_best = best;
  return abs2;
}
