/* -*- mode: c -*- */

/*
 * test_domains.c.tmpl
 *
 * Unit testing. Compares domains & implementations.
 *
 * Copyright (C) Antoine Mine' 2006, bertrand Jeannet' 2007-2011
 *
 */

/* This file is part of the APRON Library, released under GPL license
   (use of PPL library).
   Please read the COPYING file packaged in the distribution.
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <assert.h>

#include "ap_global0.h"
#include "boxMPQ.h"
#include "pkMPQ.h"
#include "pkeqMPQ.h"
#include "octMPQ.h"
/*
#include "pkeq.h"
#include "ap_ppl.h"
#include "ap_pkgrid.h"
*/


/* ********************************************************************** */
/* Global paramaters */
/* ********************************************************************** */

FILE* stream=NULL;
bool warning = true;

num_internal_ptr intern = NULL;
ap_manager_t* manprec;
ap_manager_t* manrough;

ap_scalar_discr_t global_discr = AP_SCALAR_MPQ;
size_t nb_intdim = 0;
size_t nb_dim = 2;
size_t global_depth = 3;
bool ap_abstract0_random2_equal = false;
  /* Indicates whether the last call to ap_abstract0_set_random2 guarantees
     that the two abstract values are semantically equal */
size_t nb_maxcoeff = 3;
size_t nb_meetcons = 3;
size_t nb_meetjoin_array = 3;
size_t nb_assign_array = 3;
size_t nb_substitute_array = 3;

ap_abstract0_t* (*ap_abstract0_random)(ap_manager_t*) = NULL;
void (*ap_abstract0_random2)(
    ap_manager_t*, ap_manager_t*,
    ap_abstract0_t**, ap_abstract0_t**
) = NULL;
void (*ap_linexpr0_set_random)(ap_linexpr0_t l, int dim, int nb) = NULL;
ap_texpr0_t* (*ap_texpr0_random)(int dim, int depth) = NULL;


#define N 10

char b1_[N+4]= " [";
char b2_[N+4];
int i_;
int error_ = 0;
int warning_ = 0;

#define LOOP								\
  {									\
    memset(b1_+2,' ',N); b1_[N+2]=']'; b1_[N+3]=0;			\
    memset(b2_,8,N+3); b2_[N+3]=0;					\
    for (i_=0;i_<N;i_++) {						\
      printf("%s%s",b1_,b2_);						\
      fflush(stdout);

#define RESULT(c) b1_[i_+2]=c

static inline void ERROR(bool berror, char*msg){
  fprintf(stream,"\n%s\n",msg);
  if (berror){
    RESULT('!');
    error_++;
  } else {
    RESULT('-');
    warning_++;
  }
}

#define ENDLOOP	} } printf("%s%s\n",b1_,b2_); // if (error_) abort();

/* ********************************************************************** */
/* Random generations of expressions, constraints, rays */
/* ********************************************************************** */

/* Random coefficient, scalar */
void ap_coeff_set_random_lfrac(ap_coeff_t i)
{
  long n = rand()%20-10;
  long d  = rand()%4+1;
  ap_coeff_set_val(intern,i,AP_COEFF_LFRAC,n,d);
}
/* Random coefficient, interval */
void ap_coeff_set_random_lfrac2(ap_coeff_t i)
{
  long n1 = rand()%20-10;
  long d1 = rand()%4+1;
  long n2 = rand()%20;
  long d2  = rand()%4+1;
  n2 = n1*d2+n2*d1;
  d2 = d1*d2;
  ap_coeff_set_val(intern,i,AP_COEFF_LFRAC2,n1,d1,n2,d2);
}
/* Random linear part of a affine expression */
void ap_linexpr0_set_random_vertex(ap_linexpr0_t vertex, int dim, int maxcoeffs)
{
  ap_coeff_t coeff;
  int i,d;
  for (i=0;i<maxcoeffs;i++){
    d = rand()%dim;
    ap_linexpr0_coeffref(coeff,vertex,d);
    ap_coeff_set_random_lfrac(coeff);
  }
  ap_linexpr0_cstref(coeff,vertex);
  ap_coeff_set_int(coeff,0);
}

/* random affine expression, linear */
void ap_linexpr0_set_random_linear(ap_linexpr0_t l, int dim, int maxcoeffs)
{
  ap_coeff_t coeff;
  ap_linexpr0_set_random_vertex(l,dim,maxcoeffs);
  ap_linexpr0_cstref(coeff,l);
  ap_coeff_set_random_lfrac(coeff);
}

/* random affine expression, quasilinear */
void ap_linexpr0_set_random_quasilinear(ap_linexpr0_t l, int dim, int maxcoeffs)
{
  ap_coeff_t coeff;
  ap_linexpr0_set_random_vertex(l,dim,maxcoeffs);
  ap_linexpr0_cstref(coeff,l);
  ap_coeff_set_random_lfrac2(coeff);
}

/* random affine expression, intlinear */
void ap_linexpr0_set_random_intlinear(ap_linexpr0_t l, int dim, int maxcoeffs)
{
  ap_coeff_t coeff;
  int i,d;
  for (i=0;i<maxcoeffs;i++){
    d = rand()%dim;
    ap_linexpr0_coeffref(coeff,l,d);
    ap_coeff_set_random_lfrac2(coeff);
  }
  ap_linexpr0_cstref(coeff,l);
  ap_coeff_set_random_lfrac2(coeff);
}
/* random generator of specified type */
void ap_lingen0_set_random(ap_lingen0_t res, int dim, int maxcoeffs, ap_gentyp_t g)
{
  ap_linexpr0_t linexpr;
  ap_lingen0_linexpr0ref(linexpr,res);
  ap_linexpr0_set_random_linear(linexpr,dim,maxcoeffs);
  {
    ap_coeff_t coeff;
    ap_linexpr0_cstref(coeff,linexpr);
    ap_coeff_set_int(coeff,0);
  }
  if (g>=100){
    g = (rand()%100>=80)?AP_GEN_LINE:AP_GEN_RAY;
  }
  ap_lingen0_set_gentyp(res,g);
}

/* random constraint of specified type */
void ap_lincons0_set_random(ap_lincons0_t res, int dim, int maxcoeffs, ap_constyp_t c)
{
  ap_linexpr0_t linexpr;
  ap_lincons0_linexpr0ref(linexpr,res);
  ap_linexpr0_set_random(linexpr,dim,maxcoeffs);
  if (c>=100){
    c =
      (rand()%100>=90) ? AP_CONS_EQ :
      (rand()%100>=90) ? AP_CONS_SUP :
      AP_CONS_SUPEQ;
  }
  ap_lincons0_set_constyp(res,c);
  if (c==AP_CONS_EQMOD){
    mpq_ptr mpq = ap_lincons0_mpqref(res);
    mpq_set_si(mpq,rand()%20-10,rand()%4+1);
  }
}

/* random affine expression, linear, chosen from an interval linear one */
void ap_coeff_pick_value(ap_coeff_t res, ap_coeff_t a)
{
  assert(res->discr==a->discr);
  MACRO_SWITCH(a->discr) ZZZ {
    eitvZZZ_ptr ires = res->eitv.ZZZ;
    eitvZZZ_ptr ia = a->eitv.ZZZ;
    if (eitvZZZ_is_point(ia)){
      eitvZZZ_set(ires,ia);
    }
    else {
      if (boundZZZ_infty(ia->itv->sup)){
	if (boundZZZ_infty(ia->itv->neginf)){
	  ap_coeff_set_random_lfrac(res);
	} else {
	  eitvZZZ_set_num(ires,ia->itv->neginf);
	  eitvZZZ_neg(ires,ires);
	}
      } else {
	if (boundZZZ_infty(ia->itv->neginf)){
	  eitvZZZ_set_num(ires,ia->itv->sup);
	} else {
	  if (rand()%2){
	    eitvZZZ_set_num(ires,ia->itv->neginf);
	    eitvZZZ_neg(ires,ires);
	  } else {
	    eitvZZZ_set_num(ires,ia->itv->sup);
	  }
	}
      }
    }
  }
  ENDMACRO;
}

void ap_linexpr0_pick_linear(ap_linexpr0_t l, ap_linexpr0_t a, int dim)
{
  assert(l->discr==a->discr);
  ap_coeff_t coeffa,coeffl;
  int i;

  for (i=0;i<dim;i++) {
    ap_linexpr0_coeffref(coeffa,a,i);
    ap_linexpr0_coeffref(coeffl,l,i);
    ap_coeff_pick_value(coeffl,coeffa);
  }
  ap_linexpr0_cstref(coeffa,a);
  ap_linexpr0_cstref(coeffl,l);
  ap_coeff_pick_value(coeffl,coeffa);
}

void ap_lincons0_pick_linear(ap_lincons0_t l, ap_lincons0_t a, int dim)
{
  assert(l->discr==a->discr);
  ap_linexpr0_t exprl, expra;
  ap_lincons0_linexpr0ref(expra,a);
  ap_lincons0_linexpr0ref(exprl,l);
  ap_linexpr0_pick_linear(exprl,expra,dim);
}

/* random tree expression */
ap_texpr0_t* ap_texpr0_random_std(int dim, int depth)
{
  ap_coeff_t coeff;
  ap_texpr0_t* res;
  if (depth==0) {
    switch (rand()%3) {
    case 0: return ap_texpr0_dim(rand()%dim);
    case 1:
      ap_coeff_init(coeff,global_discr);
      ap_coeff_set_random_lfrac(coeff);
      res = ap_texpr0_cst(coeff);
      ap_coeff_clear(coeff);
      return res;
    default:
      ap_coeff_init(coeff,global_discr);
      ap_coeff_set_random_lfrac2(coeff);
      res = ap_texpr0_cst(coeff);
      ap_coeff_clear(coeff);
      return res;
    }
  }
  else {
    if (rand()%2)
      return ap_texpr0_unop(AP_TEXPR_NEG+rand()%(AP_TEXPR_SQRT-AP_TEXPR_NEG+1),
			    ap_texpr0_random_std(dim,rand()%depth),
			    rand()%AP_RTYPE_SIZE, rand()%AP_RDIR_SIZE);
    else
      return ap_texpr0_binop(rand()%AP_TEXPR_NEG,
			     ap_texpr0_random_std(dim,rand()%depth),
			     ap_texpr0_random_std(dim,rand()%depth),
			     rand()%AP_RTYPE_SIZE, rand()%AP_RDIR_SIZE);
  }
}
ap_texpr0_t* ap_texpr0_random_real(int dim, int depth)
{
  ap_coeff_t coeff;
  ap_texpr0_t* res;
  if (depth==0) {
    switch (rand()%3) {
    case 0: return ap_texpr0_dim(rand()%dim);
    case 1:
      ap_coeff_init(coeff,global_discr);
      ap_coeff_set_random_lfrac(coeff);
      res = ap_texpr0_cst(coeff);
      ap_coeff_clear(coeff);
      return res;
    default:
      ap_coeff_init(coeff,global_discr);
      ap_coeff_set_random_lfrac2(coeff);
      res = ap_texpr0_cst(coeff);
      ap_coeff_clear(coeff);
      return res;
    }
  }
  else {
    if (rand()%2){
      return ap_texpr0_unop(AP_TEXPR_NEG+rand()%(AP_TEXPR_SQRT-AP_TEXPR_NEG+1),
			    ap_texpr0_random_real(dim,rand()%depth),
			    AP_RTYPE_REAL, rand()%AP_RDIR_SIZE);
    } else {
      return ap_texpr0_binop(rand()%AP_TEXPR_NEG,
			     ap_texpr0_random_real(dim,rand()%depth),
			     ap_texpr0_random_real(dim,rand()%depth),
			     AP_RTYPE_REAL, rand()%AP_RDIR_SIZE);
    }
  }
}
ap_tcons0_t* ap_tcons0_random(int dim, int depth, ap_constyp_t c)
{
  if (c>=100){
    c =
      (rand()%100>=90) ? AP_CONS_EQ :
      (rand()%100>=90) ? AP_CONS_SUP :
      AP_CONS_SUPEQ;
  }
  return ap_tcons0_make(ap_texpr0_random(dim,depth),c,NULL);
}

MACRO_FOREACH yyy ("expr","cons","gen");
#define MARK_yyy
void ap_linyyy0_array_set_random(ap_linyyy0_array_t array, int dim, int maxcoeffs, int nb)
{
  ap_linyyy0_t elt;
  int i;
  ap_linyyy0_array_resize(array,nb);
  for (i=0;i<nb;i++){
    ap_linyyy0_array_ref_index(elt,array,i);
#if defined(MARK_expr)
    ap_linyyy0_set_random(elt,dim,maxcoeffs);
#else
    ap_linyyy0_set_random(elt,dim,maxcoeffs,100);
#endif
  }
}
#undef MARK_yyy
ENDMACRO;

MACRO_FOREACH yyy ("expr","cons");
#define MARK_yyy
ap_tyyy0_array_t ap_tyyy0_array_random(int dim, int depth, int nb)
{
  ap_tyyy0_array_t array = ap_tyyy0_array_make(nb);
  int i;
  for (i=0;i<nb;i++){
    array.p[i] =
#if defined(MARK_expr)
      ap_texpr0_random(dim,depth)
#else
      ap_tcons0_random(dim,depth,100)
#endif
      ;
  }
  return array;
}
#undef MARK_yyy
ENDMACRO;


/* ********************************************************************** */
/* Random generation of abstract values */
/* ********************************************************************** */

/* random abstract value, created with the vdim vertices, and rdim
   rays. */
ap_abstract0_t* ap_abstract0_random_gen(ap_manager_t* man)
{
  size_t i;
  ap_abstract0_t* p;
  ap_coeff_t coeff;
  ap_linexpr0_t vertex;
  ap_dimension_t dimension;
  ap_lingen0_array_t array;
  ap_lingen0_t gen;

  size_t vdim,rdim;

  vdim = (nb_dim * 90) / 100;
  rdim = nb_dim-vdim;


  dimension.intd = nb_intdim;
  dimension.reald = nb_dim-nb_intdim;

  ap_linexpr0_init(vertex,global_discr,nb_dim);
  if (vdim==0){
    /* creating an abstract value with the origin */
    for (i=0;i<nb_dim;i++){
      ap_linexpr0_coeffref(coeff,vertex,i);
      ap_coeff_set_int(coeff,0);
    }
    p = ap_abstract0_of_box(man,dimension,vertex);
  }
  else {
    /* creating an abstract value with a random vertex */
    ap_linexpr0_set_random_vertex(vertex,nb_dim,nb_maxcoeff);
    p = ap_abstract0_of_box(man,dimension,vertex);
    /* adding other vertices */
    for (i=1; i<vdim; i++){
      ap_abstract0_t* tmp;
      ap_linexpr0_set_random_vertex(vertex,nb_dim,nb_maxcoeff);
      tmp = ap_abstract0_of_box(man,dimension,vertex);
      p = ap_abstract0_join(man,true,p,tmp);
      ap_abstract0_free(tmp->man,tmp);
    }
  }

  /* adding rays */
  ap_lingen0_array_init(array,global_discr,rdim);
  for (i=0;i<rdim;i++){
    ap_lingen0_array_ref_index(gen,array,i);
    ap_lingen0_set_random(gen,nb_dim,nb_maxcoeff,AP_GEN_RAY);
  }
  p = ap_abstract0_add_ray_array(man,true,p,array);

  /* clearing */
  ap_linexpr0_clear(vertex);
  ap_lingen0_array_clear(array);

  // fprintf(stdout,"abs0:\n"); ap_abstract0_fprint(stdout,man,p,0);

  return p;
}

/* random abstract value, created with dim/RATIOEQ equalities */
#define RATIOEQ 3

ap_abstract0_t* ap_abstract0_random_eq(ap_manager_t* man)
{
  size_t i;
  ap_abstract0_t* p;
  ap_lincons0_array_t array;
  ap_lincons0_t cons;
  ap_dimension_t dimension;

  dimension.intd = nb_intdim;
  dimension.reald = nb_dim-nb_intdim;

  /* creating a top abstract value */
  p = ap_abstract0_top(man,dimension);

  ap_lincons0_array_init(array,global_discr,nb_dim/RATIOEQ);
  for (i=0;i<nb_dim/RATIOEQ;i++){
    ap_lincons0_array_ref_index(cons,array,i);
    ap_lincons0_set_random(cons,nb_dim,nb_maxcoeff,AP_CONS_EQ);
  }
  p = ap_abstract0_meet_lincons_array(man,true,p,array);
  ap_lincons0_array_clear(array);
  // fprintf(stdout,"abs0:\n"); ap_abstract0_fprint(stdout,man,p,0);

  return p;
}

/* random abstract value, created with nb_dim/RATIOEQ equalities modulo */
#define RATIOEQMOD 2
ap_abstract0_t* ap_abstract0_random_eqmod(ap_manager_t* man)
{
  size_t i;
  ap_abstract0_t* p;
  ap_lincons0_array_t array;

  ap_lincons0_t cons;
  ap_dimension_t dimension;

  dimension.intd = nb_intdim;
  dimension.reald = nb_dim-nb_intdim;

  /* creating a top abstract value */
  p = ap_abstract0_top(man,dimension);

  ap_lincons0_array_init(array,global_discr,nb_dim/RATIOEQMOD);
  for (i=0;i<nb_dim/RATIOEQMOD;i++){
    ap_lincons0_array_ref_index(cons,array,i);
    ap_constyp_t constyp = (rand() % RATIOEQMOD == 0) ? AP_CONS_EQMOD : AP_CONS_EQ;
    ap_lincons0_set_random(cons,nb_dim,nb_maxcoeff,constyp);
  }
  p = ap_abstract0_meet_lincons_array(man,true,p,array);
  ap_lincons0_array_clear(array);

  // fprintf(stdout,"abs0:\n"); ap_abstract0_fprint(stdout,man,p,0);

  return p;
}

/* convert to specified manager */
size_t convert_count = 0;
ap_abstract0_t* convert(ap_manager_t* man, ap_abstract0_t* a)
{
  convert_count++;
  ap_abstract0_t* res;
  ap_lincons0_array_t array;
  ap_dimension_t d = ap_abstract0_dimension(a->man,a);
  if (a->man==man) return a;
  ap_lincons0_array_init(array,global_discr,0);
  ap_abstract0_to_lincons_array(a->man,array,a);
  res = ap_abstract0_of_lincons_array(man,d,array);
  ap_lincons0_array_clear(array);
  return res;
}

/* generate a pair of related abstract values */
void ap_abstract0_random2_rough2prec(ap_manager_t* man1,/* assumed to be the most precise */
			  ap_manager_t* man2,/* assumed to be the less precise */
			  ap_abstract0_t** abs1, ap_abstract0_t** abs2)
{
  *abs2 = ap_abstract0_random(man2);
  *abs1 = convert(man1,*abs2);
  ap_abstract0_random2_equal = true;
}
void ap_abstract0_random2_prec2rough(ap_manager_t* man1,/* assumed to be the most precise */
			  ap_manager_t* man2,/* assumed to be the less precise */
			  ap_abstract0_t** abs1, ap_abstract0_t** abs2)
{
  *abs1 = ap_abstract0_random(man1);
  *abs2 = convert(man2,*abs1);
  ap_abstract0_random2_equal = false;
}

/* print */
void print_abstract(const char* msg, ap_abstract0_t* p)
{
  fprintf(stream,"%s (%s) = ",msg,p->man->library);
  ap_abstract0_fprint(stream,p->man,p,NULL);
  ap_abstract0_fdump(stream,p->man,p);
  fprintf(stream,"\n");
}

/* ********************************************************************** */
/* Comparison of abstract values */
/* ********************************************************************** */

   /*
The first abstract value is supposed to be defined on a more precise abstract
domain than the second one. Hence we convert a2 to the first abstract domain
and then performs the comparison.
*/
bool is_eq(ap_abstract0_t* a1, ap_abstract0_t* a2)
{
  ap_abstract0_t* aa2 = convert(a1->man,a2);
  bool r = ap_abstract0_is_eq(a1->man,a1,aa2);
  if (a2!=aa2) ap_abstract0_free(aa2->man,aa2);
  return r;
}
bool is_leq(ap_abstract0_t* a1, ap_abstract0_t* a2)
{
  ap_abstract0_t* aa2 = convert(a1->man,a2);
  bool r = ap_abstract0_is_leq(a1->man,a1,aa2);
  if (a2!=aa2) ap_abstract0_free(aa2->man,aa2);
  return r;
}


/* ********************************************************************** */
/* Tests */
/* ********************************************************************** */

/* ====================================================================== */
/* Various tests on special cases */
/* ====================================================================== */

/* test on prec domain */
void test_misc(void)
{
  size_t i;
  ap_abstract0_t *bot,*top;

  ap_dimension_t dimension = { 0, nb_dim };

  bot = ap_abstract0_bottom(manprec,dimension);
  top = ap_abstract0_top(manprec,dimension);
  ap_dimension_t d1 = ap_abstract0_dimension(manprec,bot);
  ap_dimension_t d2 = ap_abstract0_dimension(manprec,top);
  printf("\nperforming various tests\n");
  if (d1.intd || d1.reald!=nb_dim) printf("ap_abstract0_dimension failed #1\n");
  if (d2.intd || d2.reald!=nb_dim) printf("ap_abstract0_dimension failed #2\n");
  if (ap_abstract0_is_bottom(manprec,bot)==false)  printf("ap_abstract0_is_bottom failed #3\n");
  if (ap_abstract0_is_bottom(manprec,top))   printf("ap_abstract0_is_bottom failed #4\n");
  if (ap_abstract0_is_top(manprec,bot))      printf("ap_abstract0_is_top failed #5\n");
  if (ap_abstract0_is_top(manprec,top)==false)     printf("ap_abstract0_is_top failed #6\n");
  if (ap_abstract0_is_leq(manprec,bot,top)==false) printf("ap_abstract0_is_leq failed #7\n");
  if (ap_abstract0_is_leq(manprec,top,bot))  printf("ap_abstract0_is_leq failed #8\n");
  if (ap_abstract0_is_eq(manprec,bot,bot)==false)  printf("ap_abstract0_is_eq failed #9\n");
  if (ap_abstract0_is_eq(manprec,top,top)==false)  printf("ap_abstract0_is_eq failed #10\n");
  if (ap_abstract0_is_eq(manprec,bot,top))   printf("ap_abstract0_is_eq failed #11\n");
  if (ap_abstract0_is_dimension_unconstrained(manprec,bot,0))
    printf("ap_abstract0_is_dimension_unconstrained #12\n");
  if (ap_abstract0_is_dimension_unconstrained(manprec,top,0)==false)
    printf("ap_abstract0_is_dimension_unconstrained #13\n");
  for (i=0;i<N;i++) {
    ap_abstract0_t* o = ap_abstract0_random(manprec);
    ap_abstract0_t* c = ap_abstract0_copy(manprec,o);
    ap_abstract0_t* l = ap_abstract0_closure(manprec,false,o);
    ap_dimension_t d = ap_abstract0_dimension(manprec,o);
    if (d.intd || d.reald!=nb_dim) printf("ap_abstract0_dimension failed #14\n");
    if (ap_abstract0_is_leq(manprec,bot,o)==false)  printf("ap_abstract0_is_leq failed #15\n");
    if (ap_abstract0_is_leq(manprec,o,top)==false)  printf("ap_abstract0_is_leq failed #16\n");
    if (ap_abstract0_is_eq(manprec,o,c)==false)     printf("ap_abstract0_is_eq failed #17\n");
    if (ap_abstract0_is_eq(manprec,o,l)==false)     printf("ap_abstract0_is_eq failed #18\n");
    // not implemented
    //ap_abstract0_minimize(manprec,o);
    //ap_abstract0_canonicalize(manprec,o);
    //ap_abstract0_approximate(manprec,o,0);
    //ap_abstract0_is_minimal(manprec,o);
    //ap_abstract0_is_canonical(manprec,o);
    ap_abstract0_free(manprec,o); ap_abstract0_free(manprec,c); ap_abstract0_free(manprec,l);
  }
  ap_abstract0_free(manprec,bot); ap_abstract0_free(manprec,top);
}

/* ====================================================================== */
/* Comparison tests */
/* ====================================================================== */

void test_conv(void)
{
  printf("\nconversions\n");
  LOOP {
    ap_abstract0_t* rough0 = ap_abstract0_random(manrough);
    ap_abstract0_t* prec0 = convert(manprec,rough0);
    ap_abstract0_t* rough1 = convert(manrough,prec0);
    ap_abstract0_t* prec1 = convert(manprec,rough1);
    RESULT('*');
    bool t1 = !is_eq(rough0,rough1);
    bool t2 = !is_eq(prec0,prec1);
    bool t3 = !is_leq(prec0,rough0);

    if (t1 || t2 || t3){
      char msg[256];
      int n = 0;
      if (t1) n+=snprintf(msg+n,256-n,"rough0!=rough1 (error) ");
      if (t2) n+=snprintf(msg+n,256-n,"prec0!=prec1 (error) ");
      if (t3) n+=snprintf(msg+n,256-n,"prec0 not in rough0 (error) ");
      ERROR(true,msg);
      print_abstract("rough0",rough0); print_abstract("prec0",prec0);
      print_abstract("rough1",rough1); print_abstract("prec1",prec1);
    }
    ap_abstract0_free(manrough,rough0); ap_abstract0_free(manrough,rough1);
    ap_abstract0_free(manprec,prec0); ap_abstract0_free(manprec,prec1);
  } ENDLOOP;
}

void test_bound_dimension(void)
{
  printf("\nbound_dimension\n");
  LOOP {
    int cmp;
    size_t i;
    ap_abstract0_t* rougha,*preca;
    ap_coeff_t roughi,preci;

    ap_coeff_init(roughi,global_discr);
    ap_coeff_init(preci,global_discr);
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    RESULT('*');
    for (i=0;i<nb_dim;i++) {
      bool roughd,precd;
      roughd = ap_abstract0_is_dimension_unconstrained(manrough,rougha,i);
      precd = ap_abstract0_is_dimension_unconstrained(manprec,preca,i);

      ap_abstract0_bound_dimension(manrough,roughi,rougha,i);
      ap_abstract0_bound_dimension(manprec,preci,preca,i);
      cmp = ap_coeff_cmp(preci,roughi);
      bool t1 = precd && !roughd;
      bool t2 = ap_abstract0_random2_equal && cmp!=0;
      bool t3 = (cmp!=0) && (cmp!=(-1));
      if (t1 || t2 || t3){
	char msg[256];
	int n=0;
	if (t1) n+=snprintf(msg+n,256-n,"dimension constrained in rougha but not in preca (error) ");
	if (t2) n+=snprintf(msg+n,256-n,"no equality (error) ");
	if (t3) n+=snprintf(msg+n,256-n,"no inclusion (error)");
	ERROR(true,msg);
	print_abstract("rougha",rougha);
	print_abstract("preca",preca);
	fprintf(stream,"roughd=%i precd=%i",roughd,precd);
	fprintf(stream," roughi[%i]=",(int)i); ap_coeff_fprint(stream,roughi);
	fprintf(stream," preci[%i]=",(int)i); ap_coeff_fprint(stream,preci);
	printf("\n");
      }
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_coeff_clear(roughi);
    ap_coeff_clear(preci);

  } ENDLOOP;
}

size_t test_bound_linexpr_count = 0;
void test_bound_linexpr(void)
{
  test_bound_linexpr_count++;
  printf("\nbound_linexpr\n");
  LOOP {
    int cmp;
    ap_abstract0_t *rougha,*preca;
    ap_coeff_t roughi,preci;
    ap_linexpr0_t l;

    ap_coeff_init(roughi,global_discr); ap_coeff_init(preci,global_discr);
    ap_linexpr0_init(l,global_discr,nb_dim);
    ap_linexpr0_set_random(l,nb_dim,nb_maxcoeff);
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    ap_abstract0_bound_linexpr(manrough,roughi,rougha,l);
    ap_abstract0_bound_linexpr(manprec,preci,preca,l);
    cmp = ap_coeff_cmp(preci,roughi);
    RESULT('*');
    bool t1 = (ap_abstract0_random2_equal && cmp!=0);
    bool t2 = (cmp!=0 && cmp!=(-1));
    if (t1 || t2){
      char msg[256];
      int n=0;
      if (t1) n+=snprintf(msg+n,256-n,"rougha==preca but different results (sound) ");
      if (t2) n+=snprintf(msg+n,256-n,"no inclusion (likely to be an error)");
      ERROR(false,msg);
      if (t2 || (t1 && warning)){
	print_abstract("rougha",rougha); print_abstract("preca",preca);
	ap_linexpr0_fprint(stream,l,NULL);
	fprintf(stream,"\nroughi="); ap_coeff_fprint(stream,roughi);
	fprintf(stream,"\npreci="); ap_coeff_fprint(stream,preci);
	fprintf(stream,"\n");
      }
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_coeff_clear(roughi); ap_coeff_clear(preci);
    ap_linexpr0_clear(l);
  } ENDLOOP;
}

void test_bound_texpr(void)
{
  printf("\nbound_texpr\n");
  LOOP {
    int cmp;
    ap_abstract0_t* rougha,*preca;
    ap_coeff_t roughi,preci;

    ap_coeff_init(roughi,global_discr); ap_coeff_init(preci,global_discr);
    ap_texpr0_t* e = ap_texpr0_random(nb_dim,global_depth);
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    ap_abstract0_bound_texpr(manrough,roughi,rougha,e);
    ap_abstract0_bound_texpr(manprec,preci,preca,e);
    cmp = ap_coeff_cmp(preci,roughi);
    RESULT('*');
    bool t1 = (ap_abstract0_random2_equal && cmp!=0);
    bool t2 = (cmp!=0 && cmp!=(-1));
    if (t1 || t2){
      char msg[256];
      int n=0;
      if (t1) n+=snprintf(msg+n,256-n,"rougha==preca but different results (sound) ");
      if (t2) n+=snprintf(msg+n,256-n,"no inclusion (likely to be an error)");
      ERROR(false,msg);
      if (t2 || (t1 && warning)){
	print_abstract("rougha",rougha); print_abstract("preca",preca);
	ap_texpr0_fprint(stream,e,NULL);
	fprintf(stream,"\nroughi="); ap_coeff_fprint(stream,roughi);
	fprintf(stream,"\npreci="); ap_coeff_fprint(stream,preci);
	fprintf(stream,"\n");
      }
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_coeff_clear(roughi); ap_coeff_clear(preci);
    ap_texpr0_free(e);
  } ENDLOOP;
}

void test_sat_interval(void)
{
  printf("\nsat_interval\n");
  LOOP {
    size_t p = rand() % nb_dim;
    ap_abstract0_t* rougha,*preca;
    ap_coeff_t i;
    bool roughs,precs;

    ap_coeff_init(i,global_discr);
    ap_coeff_set_random_lfrac2(i);
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    roughs = ap_abstract0_sat_interval(manrough,rougha,p,i);
    precs = ap_abstract0_sat_interval(manprec,preca,p,i);
    RESULT('*');
    bool t1 = (ap_abstract0_random2_equal &&
	       ((roughs && roughs!=precs) ||
		(precs && roughs!=precs)));
    bool t2 = roughs && !precs;
    if (t1 || t2){
      char msg[256];
      int n=0;
      if (t1) n+=snprintf(msg+n,256-n,"rougha==preca but different results (sound) ");
      if (t2) n+=snprintf(msg+n,256-n,"no implication (likely to be an error)");
      ERROR(false,msg);
      if (t2 || (t1 && warning)){
	print_abstract("rougha",rougha);
	print_abstract("preca",preca);
	ap_coeff_fprint(stream,i);
	fprintf(stream,"\nvar=%i\nroughs=%i precs=%i\n",(int)p,roughs,precs);
      }
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_coeff_clear(i);
  } ENDLOOP;
}

void test_sat_lincons(void)
{
  printf("\nsat_lincons\n");
  LOOP {
    ap_abstract0_t* rougha,*preca;
    ap_lincons0_t l;

    ap_lincons0_init(l,global_discr,nb_dim);
    ap_lincons0_set_random(l,nb_dim,nb_maxcoeff,100);
    bool roughs,precs;
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    roughs = ap_abstract0_sat_lincons(manrough,rougha,l);
    precs = ap_abstract0_sat_lincons(manprec,preca,l);
    RESULT('*');
    bool t1 = (ap_abstract0_random2_equal &&
	       ((roughs && roughs!=precs) ||
		(precs && roughs!=precs)));
    bool t2 = roughs && !precs;
    if (t1 || t2){
      char msg[256];
      int n=0;
      if (t1) n+=snprintf(msg+n,256-n,"rougha==preca but different results (sound) ");
      if (t2) n+=snprintf(msg+n,256-n,"no implication (likely to be an error)");
      ERROR(false,msg);
      if (t2 || (t1 && warning)){
	print_abstract("rougha",rougha);print_abstract("preca",preca);
	ap_lincons0_fprint(stream,l,NULL);
	fprintf(stream,"\nroughs=%i precs=%i\n",roughs,precs);
      }
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_lincons0_clear(l);
  } ENDLOOP;
}

void test_sat_tcons(void)
{
  printf("\nsat_tcons\n");
  LOOP {
    ap_abstract0_t* rougha,*preca;
    ap_tcons0_t* l = ap_tcons0_random(nb_dim,global_depth,100);

    if (0){
      printf("\n");
      ap_tcons0_print(l,NULL);
      printf("\n");
    }
    bool roughs,precs;
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    roughs = ap_abstract0_sat_tcons(manrough,rougha,l);
    precs = ap_abstract0_sat_tcons(manprec,preca,l);
    RESULT('*');
    bool t1 = (ap_abstract0_random2_equal &&
	       ((roughs && roughs!=precs) ||
		(precs && roughs!=precs)));
    bool t2 = roughs && !precs;
    if (t1 || t2){
      char msg[256];
      int n=0;
      if (t1) n+=snprintf(msg+n,256-n,"rougha==preca but different results (sound) ");
      if (t2) n+=snprintf(msg+n,256-n,"no implication (likely to be an error)");
      ERROR(false,msg);
      if (t2 || (t1 && warning)){
	print_abstract("rougha",rougha);print_abstract("preca",preca);
	ap_tcons0_fprint(stream,l,NULL);
	fprintf(stream,"\nroughs=%i precs=%i\n",roughs,precs);
      }
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_tcons0_free(l);
  } ENDLOOP;
}

void test_to_box(void)
{
  printf("\nbox conversion\n");
  LOOP {
    size_t i;
    ap_dimension_t dimension = { 0, nb_dim };
    ap_abstract0_t* rougha,*roughr, *preca,*precr;
    ap_linexpr0_t roughi,preci;
    ap_linexpr0_init(roughi,global_discr,nb_dim);
    ap_linexpr0_init(preci,global_discr,nb_dim);
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    ap_abstract0_to_box(manrough,roughi,rougha);
    ap_abstract0_to_box(manprec,preci,preca);
    roughr = ap_abstract0_of_box(manrough,dimension,roughi);
    precr = ap_abstract0_of_box(manprec,dimension,preci);
    RESULT('*');
    if (!is_leq(precr,roughr)) {
      ERROR(true,"no inclusion");
      fprintf(stream,"roughi="); ap_linexpr0_fprint(stream,roughi,NULL); fprintf(stream,"\n");
      fprintf(stream,"preci="); ap_linexpr0_fprint(stream,preci,NULL); fprintf(stream,"\n");
      print_abstract("rougha",rougha); print_abstract("roughr",roughr); print_abstract("precr",precr);
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
    ap_linexpr0_clear(roughi); ap_linexpr0_clear(preci);
  } ENDLOOP;

}


void test_meet(void)
{
  printf("\nmeet\n");
  LOOP {
    ap_abstract0_t *prec0,*prec1,*precr,*rough0,*rough1,*roughr;
    ap_abstract0_random2(manprec,manrough,&prec0,&rough0);
    ap_abstract0_random2(manprec,manrough,&prec1,&rough1);
    roughr = ap_abstract0_meet(manrough,false,rough0,rough1);
    precr = ap_abstract0_meet(manprec,false,prec0,prec1);
    RESULT('*');
    if (!is_leq(precr,roughr)) {
      ERROR(true,"no inclusion");
      print_abstract("rough0",rough0); print_abstract("rough1",rough1);
      print_abstract("roughr",roughr); print_abstract("precr",precr);
    }
    ap_abstract0_free(manrough,rough0); ap_abstract0_free(manrough,rough1); ap_abstract0_free(manrough,roughr);
    ap_abstract0_free(manprec,prec0); ap_abstract0_free(manprec,prec1); ap_abstract0_free(manprec,precr);
  } ENDLOOP;
}

void test_meet_array(void)
{
  size_t i;
  printf("\nmeet_array\n");
  LOOP {
    ap_abstract0_t* rougha[nb_meetjoin_array], *roughr;
    ap_abstract0_t* preca[nb_meetjoin_array], *precr;
    for (i=0;i<nb_meetjoin_array;i++) {
      ap_abstract0_random2(manprec,manrough,&preca[i],&rougha[i]);
    }
    roughr = ap_abstract0_meet_array(manrough,(ap_abstract0_t**)rougha,nb_meetjoin_array);
    precr = ap_abstract0_meet_array(manprec,(ap_abstract0_t**)preca,nb_meetjoin_array);
    RESULT('*');
    if (!is_leq(precr,roughr)) {
      ERROR(true,"no inclusion");
      print_abstract("roughr",roughr); print_abstract("precr",precr);
    }
    for (i=0;i<nb_meetjoin_array;i++) { ap_abstract0_free(manrough,rougha[i]); ap_abstract0_free(manprec,preca[i]); }
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
  } ENDLOOP;
}


void test_meet_lincons_array(void)
{
  printf("\nmeet_lincons_array\n");
  LOOP {
    size_t i;
    ap_abstract0_t* rougha,*roughr, *preca,*precr;
    ap_lincons0_array_t array;
    ap_lincons0_array_init(array,global_discr,nb_meetcons);
    ap_lincons0_array_set_random(array,nb_dim,nb_maxcoeff,nb_meetcons);
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    roughr = ap_abstract0_meet_lincons_array(manrough,false,rougha,array);
    precr = ap_abstract0_meet_lincons_array(manprec,false,preca,array);
    RESULT('*');
    if (!is_leq(precr,roughr)) {
      ERROR(false,"no inclusion (likely to be an error)");
      ap_lincons0_array_fprint(stream,array,NULL);
      print_abstract("rougha",rougha); print_abstract("preca",preca);
      print_abstract("roughr",roughr); print_abstract("precr",precr);
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
    ap_lincons0_array_clear(array);
  } ENDLOOP;
}

void test_meet_tcons_array(void)
{
  printf("\nmeet_tcons_array\n");
  LOOP {
    size_t i;
    ap_abstract0_t* rougha,*roughr, *preca,*precr;
    ap_tcons0_array_t array = ap_tcons0_array_random(nb_dim,global_depth,nb_meetcons);
    if (0){
      printf("\n");
      ap_tcons0_array_print(&array,NULL);
      printf("\n");
    }
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    roughr = ap_abstract0_meet_tcons_array(manrough,false,rougha,&array);
    precr = ap_abstract0_meet_tcons_array(manprec,false,preca,&array);
    RESULT('*');
    if (!is_leq(precr,roughr)) {
      ERROR(false,"no inclusion (likely to be an error)");
      ap_tcons0_array_fprint(stream,&array,NULL);
      print_abstract("rougha",rougha); print_abstract("preca",preca);
      print_abstract("roughr",roughr); print_abstract("precr",precr);
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
    ap_tcons0_array_clear(&array);
  } ENDLOOP;
}

void test_join(void)
{
  printf("\njoin\n");
  LOOP {
    ap_abstract0_t *prec0,*prec1,*precr,*rough0,*rough1,*roughr;
    ap_abstract0_random2(manprec,manrough,&prec0,&rough0);
    ap_abstract0_random2(manprec,manrough,&prec1,&rough1);
    roughr = ap_abstract0_join(manrough,false,rough0,rough1);
    precr = ap_abstract0_join(manprec,false,prec0,prec1);
    RESULT('*');
    if (!is_leq(precr,roughr)) {
      ERROR(true,"no inclusion");
      print_abstract("rough0",rough0); print_abstract("rough1",rough1);
      print_abstract("roughr",roughr); print_abstract("precr",precr);
    }
    ap_abstract0_free(manrough,rough0); ap_abstract0_free(manrough,rough1); ap_abstract0_free(manrough,roughr);
    ap_abstract0_free(manprec,prec0); ap_abstract0_free(manprec,prec1); ap_abstract0_free(manprec,precr);
  } ENDLOOP;
}

void test_join_array(void)
{
  size_t i;
  printf("\njoin_array\n");
  LOOP {
    ap_abstract0_t* rougha[nb_meetjoin_array], *roughr;
    ap_abstract0_t* preca[nb_meetjoin_array], *precr;
    for (i=0;i<nb_meetjoin_array;i++) {
      ap_abstract0_random2(manprec,manrough,&preca[i],&rougha[i]);
    }
    roughr = ap_abstract0_join_array(manrough,(ap_abstract0_t**)rougha,nb_meetjoin_array);
    precr = ap_abstract0_join_array(manprec,(ap_abstract0_t**)preca,nb_meetjoin_array);
    RESULT('*');
    if (!is_leq(precr,roughr)) {
      ERROR(true,"no inclusion");
      print_abstract("roughr",roughr); print_abstract("precr",precr);
    }
    for (i=0;i<nb_meetjoin_array;i++) { ap_abstract0_free(manrough,rougha[i]); ap_abstract0_free(manprec,preca[i]); }
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
  } ENDLOOP;
}

void test_add_ray(void)
{
  printf("\nadd_rays_array\n");
  LOOP {
    size_t i;
    ap_abstract0_t* rougha,*roughr, *preca,*precr;
    ap_lingen0_array_t array;
    ap_lingen0_array_init(array,global_discr,nb_meetcons);
    ap_lingen0_array_set_random(array,nb_dim,nb_maxcoeff,nb_meetcons);
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    roughr = ap_abstract0_add_ray_array(manrough,false,rougha,array);
    precr = ap_abstract0_add_ray_array(manprec,false,preca,array);
    RESULT('*');
    if (!is_leq(precr,roughr)) {
      ERROR(true,"no inclusion");
      ap_lingen0_array_fprint(stream,array,NULL);
      print_abstract("rougha",rougha); print_abstract("roughr",roughr); print_abstract("precr",precr);
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
    ap_lingen0_array_clear(array);
  } ENDLOOP;
}

MACRO_FOREACH asssub ("assign","substitute");
void test_asssub_linexpr(void)
{
  printf("\nasssub_linexpr\n");
  LOOP {
    size_t p = rand() % nb_dim;
    ap_abstract0_t* rougha,*roughr, *preca,*precr;
    ap_linexpr0_t l;
    ap_linexpr0_init(l,global_discr,nb_dim);
    ap_linexpr0_set_random(l,nb_dim,nb_maxcoeff);
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    roughr = ap_abstract0_asssub_linexpr(manrough,false,rougha,p,l,NULL);
    precr = ap_abstract0_asssub_linexpr(manprec,false,preca,p,l,NULL);
    RESULT('*');
    bool t1 = !is_leq(precr,roughr);
    bool t2 = false && ap_abstract0_random2_equal && !is_eq(precr,roughr);
    if (t1 || t2) {
      char msg[256];
      int n = 0;
      if (t1) n+=snprintf(msg+n,256-n,"no inclusion (still sound...) ");
      if (t2) n+=snprintf(msg+n,256-n,"no equality (expected)");
      ERROR(false,msg);
      if (warning){
	fprintf(stream,"x%i <- ",(int)p); ap_linexpr0_fprint(stream,l,NULL); fprintf(stream,"\n");
	print_abstract("rougha",rougha); print_abstract("roughr",roughr); print_abstract("precr",precr);
      }
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
    ap_linexpr0_clear(l);
  } ENDLOOP;
}
void test_asssub_linexpr_array(void)
{
  printf("\nasssub_linexpr_array\n");
  LOOP {
    size_t i;
    ap_abstract0_t* rougha,*roughr, *preca,*precr;
    ap_dim_t d[nb_asssub_array];
    ap_linexpr0_array_t array;
    ap_linexpr0_array_init(array,global_discr,nb_asssub_array);
    ap_linexpr0_array_set_random(array,nb_dim,nb_maxcoeff,nb_asssub_array);
    for (i=0;i<nb_asssub_array;i++) {
      if (!i) d[i] = rand()%(nb_dim-nb_asssub_array+1);
      else d[i] = d[i-1] + 1 + (rand()%(nb_dim-(nb_asssub_array-i)-d[i-1]));
    }
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    roughr = ap_abstract0_asssub_linexpr_array(manrough,false,rougha,d,array,NULL);
    precr = ap_abstract0_asssub_linexpr_array(manprec,false,preca,d,array,NULL);
    RESULT('*');
    bool t1 = !is_leq(precr,roughr);
    bool t2 = false && ap_abstract0_random2_equal && !is_eq(precr,roughr);
    if (t1 || t2) {
      char msg[256];
      int n = 0;
      if (t1) n+=snprintf(msg+n,256-n,"no inclusion (still sound...) ");
      if (t2) n+=snprintf(msg+n,256-n,"no equality (expected)");
      ERROR(false,msg);
      if (warning){
	for (i=0;i<nb_asssub_array;i++) {
	  fprintf(stream,"x%i <- ",d[i]);
	  ap_linexpr0_t elt;
	  ap_linexpr0_array_ref_index(elt,array,i);
	  ap_linexpr0_fprint(stream,elt,NULL);
	  fprintf(stream,"\n");
	}
	print_abstract("rougha",rougha); print_abstract("preca",preca); print_abstract("roughr",roughr); print_abstract("precr",precr);
      }
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
    ap_linexpr0_array_clear(array);
  } ENDLOOP;
}

void test_asssub_texpr(void)
{
  printf("\nasssub_texpr\n");
  LOOP {
    size_t p = rand() % nb_dim;
    ap_abstract0_t* rougha,*roughr, *preca,*precr;
    ap_texpr0_t* l = ap_texpr0_random(nb_dim, global_depth);
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    if (0){
      printf("\n");
      fprintf(stream,"x%i <- ",(int)p); ap_texpr0_print(l,NULL);
      printf("\n");
    }
    roughr = ap_abstract0_asssub_texpr(manrough,false,rougha,p,l,NULL);
    precr = ap_abstract0_asssub_texpr(manprec,false,preca,p,l,NULL);
    RESULT('*');
    bool t1 = !is_leq(precr,roughr);
    bool t2 =false && ap_abstract0_random2_equal && !is_eq(precr,roughr);
    if (t1 || t2) {
      char msg[256];
      int n = 0;
      if (t1) n+=snprintf(msg+n,256-n,"no inclusion (still sound...) ");
      if (t2) n+=snprintf(msg+n,256-n,"no equality (expected)");
      ERROR(false,msg);
      if (warning){
	fprintf(stream,"x%i <- ",(int)p); ap_texpr0_fprint(stream,l,NULL); fprintf(stream,"\n");
	print_abstract("rougha",rougha); print_abstract("roughr",roughr); print_abstract("precr",precr);
      }
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
    ap_texpr0_free(l);
  } ENDLOOP;
}
void test_asssub_texpr_array(void)
{
  printf("\nasssub_texpr_array\n");
  LOOP {
    size_t i;
    size_t p = rand() % nb_dim;
    ap_abstract0_t* rougha,*roughr, *preca,*precr;
    ap_dim_t d[nb_asssub_array];
    ap_texpr0_array_t array = ap_texpr0_array_random(nb_dim,global_depth,nb_asssub_array);
    for (i=0;i<nb_asssub_array;i++) {
      if (!i) d[i] = rand()%(nb_dim-nb_asssub_array+1);
      else d[i] = d[i-1] + 1 + (rand()%(nb_dim-(nb_asssub_array-i)-d[i-1]));
    }
    if (false){
      printf("\ntdim = ");
      for (i=0;i<nb_asssub_array;i++) {
	printf("%d,",(int)d[i]);
      }
      printf("\n");
      ap_texpr0_array_print(&array,NULL);
      printf("\n");
    }
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    roughr = ap_abstract0_asssub_texpr_array(manrough,false,rougha,d,&array,NULL);
    precr = ap_abstract0_asssub_texpr_array(manprec,false,preca,d,&array,NULL);
    RESULT('*');
    bool t1 = !is_leq(precr,roughr);
    bool t2 = false && ap_abstract0_random2_equal && !is_eq(precr,roughr);
    if (t1 || t2) {
      char msg[256];
      int n = 0;
      if (t1) n+=snprintf(msg+n,256-n,"no inclusion (still sound...) ");
      if (t2) n+=snprintf(msg+n,256-n,"no equality (expected)");
      ERROR(false,msg);
      if (warning){
	for (i=0;i<nb_asssub_array;i++) {
	  fprintf(stream,"x%i <- ",d[i]);
	  ap_texpr0_fprint(stream,array.p[i],NULL);
	  fprintf(stream,"\n");
	}
	print_abstract("rougha",rougha); print_abstract("preca",preca); print_abstract("roughr",roughr); print_abstract("precr",precr);
      }
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
    ap_texpr0_array_clear(&array);
  } ENDLOOP;
}
ENDMACRO;

void test_forget_array(void)
{
  printf("\nforget_array\n");
  LOOP {
    size_t i;
    ap_abstract0_t* rougha,*roughr, *preca,*precr;
    ap_dimension_t d;
    int nb = rand()%nb_dim;
    int proj = rand()%2;
    ap_dimension_t dimension;
    ap_dimchange_t a;

    dimension.intd = 0;
    dimension.reald = nb;
    ap_dimchange_init(&a,dimension);
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    d = ap_abstract0_dimension(manrough,rougha);

    for (i=0;i<dimension.intd+dimension.reald;i++) {
      if (i){
	a.p[i] = a.p[i-1] + 1 + rand()%(nb_dim-(nb-i)-a.p[i-1]);
      } else {
	a.p[i] = rand()%(1+nb_dim-nb);
      }
      if (a.p[i]<d.intd) { a.dim.intd++; a.dim.reald--; }
      assert(a.p[i]<nb_dim);
    }
    if (0){
      printf("\n");
      ap_dimchange_fprint(stream,&a);
      print_abstract("rougha",rougha); print_abstract("preca",preca);
      printf("\n");
    }
    roughr = ap_abstract0_forget_array(manrough,false,rougha,a.p, a.dim.intd+a.dim.reald, proj);
    precr = ap_abstract0_forget_array(manprec,false,preca,a.p, a.dim.intd+a.dim.reald,proj);
    RESULT('*');
    bool t1 = !is_leq(precr,roughr);
    bool t2 = ap_abstract0_random2_equal && !is_eq(precr,roughr);
    if (t1 || t2) {
      char msg[256];
      int n = 0;
      if (t1) n+=snprintf(msg+n,256-n,"no inclusion (error) ");
      if (t2) n+=snprintf(msg+n,256-n,"no equality (sound)");
      ERROR(t1,msg);
      if (t1 || (t2 && warning)){
	ap_dimchange_fprint(stream,&a);
	print_abstract("rougha",rougha); print_abstract("roughr",roughr);
	print_abstract("precaa",preca); print_abstract("precr",precr);
      }
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
    ap_dimchange_clear(&a);
  } ENDLOOP;
}

void test_add_dimensions(void)
{
  printf("\nadd dimensions\n");
  LOOP {
    size_t i;
    int nb = rand()%(nb_dim+1);
    ap_dimension_t dimension;
    dimension.intd = 0;
    dimension.reald = rand()%(nb+1);
    ap_dimchange_t a; ap_dimchange_init(&a,dimension);
    ap_abstract0_t* rougha,*roughr, *preca,*precr;
    int proj = rand()%2;
    ap_dimension_t d;
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    d = ap_abstract0_dimension(manrough,rougha);
    for (i=0;i<a.dim.intd+a.dim.reald;i++) {
      if (i){
	a.p[i] = a.p[i-1] + rand()%(1+nb-a.p[i-1]);
      } else {
	a.p[i] = rand()%(1+nb);
      }
      if (a.p[i]<d.intd) { a.dim.intd++; a.dim.reald--; }
      assert(a.p[i]<=nb_dim);
    }
    roughr = ap_abstract0_add_dimensions(manrough,false,rougha,&a,proj);
    precr = ap_abstract0_add_dimensions(manprec,false,preca,&a,proj);
    RESULT('*');
    bool t1 = !is_leq(precr,roughr);
    bool t2 = ap_abstract0_random2_equal && !is_eq(precr,roughr);
    if (t1 || t2) {
      char msg[256];
      int n = 0;
      if (t1) n+=snprintf(msg+n,256-n,"no inclusion (error) ");
      if (t2) n+=snprintf(msg+n,256-n,"no equality (error)");
      ERROR(true,msg);
      ap_dimchange_fprint(stream,&a);
      fprintf(stream,"proj=%d\n",proj);
      print_abstract("rougha",rougha); print_abstract("preca",preca); print_abstract("roughr",roughr); print_abstract("precr",precr);
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
    ap_dimchange_clear(&a);
  } ENDLOOP;
}

void test_remove_dimensions(void)
{
  printf("\nremove dimensions\n");
  LOOP {
    size_t i;
    int nb = rand()%(nb_dim+1);
    ap_dimension_t dimension;
    dimension.intd = 0;
    dimension.reald = rand()%(nb+1);
    ap_dimchange_t a; ap_dimchange_init(&a,dimension);
    ap_abstract0_t* rougha,*roughr, *preca,*precr;
    ap_dimension_t d;
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    d = ap_abstract0_dimension(manrough,rougha);
    for (i=0;i<a.dim.intd+a.dim.reald;i++) {
      if (i){
	a.p[i] = a.p[i-1] + 1 + rand()%(nb_dim-(nb-i)-a.p[i-1]);
      } else {
	a.p[i] = rand()%(1+nb_dim-nb);
      }
      if (a.p[i]<d.intd) { a.dim.intd++; a.dim.reald--; }
      assert(a.p[i]<nb_dim);
    }
    roughr = ap_abstract0_remove_dimensions(manrough,false,rougha,&a);
    precr = ap_abstract0_remove_dimensions(manprec,false,preca,&a);
    RESULT('*');
    bool t1 = !is_leq(precr,roughr);
    bool t2 = ap_abstract0_random2_equal && !is_eq(precr,roughr);
    if (t1 || t2) {
      char msg[256];
      int n = 0;
      if (t1) n+=snprintf(msg+n,256-n,"no inclusion (error) ");
      if (t2) n+=snprintf(msg+n,256-n,"no equality (sound)");
      ERROR(t1,msg);
      if (t1 || (t2 && warning)){
	ap_dimchange_fprint(stream,&a);
	print_abstract("rougha",rougha); print_abstract("preca",preca); print_abstract("roughr",roughr); print_abstract("precr",precr);
      }
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
    ap_dimchange_clear(&a);
  } ENDLOOP;
}

void test_permute_dimensions(void)
{
  printf("\npermute dimensions\n");
  LOOP {
    size_t i;
    ap_dimperm_t perm;
    ap_dimperm_init(&perm,nb_dim);
    ap_abstract0_t* rougha,*roughr, *preca,*precr;
    ap_dimension_t d;
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    d = ap_abstract0_dimension(manrough,rougha);
    /* random permutation */
    ap_dimperm_set_id(&perm);
    for (i=0;i<=2*perm.size;i++) {
      unsigned int i1,i2;
      ap_dim_t t;
      if (d.intd){
	i1 = rand()%d.intd;
	i2 = rand()%d.intd;
	if (i1!=i2){ t = perm.p[i1]; perm.p[i1] = perm.p[i2]; perm.p[i2] = t; }
      }
      if (d.reald){
	i1 = d.intd + rand()%d.reald;
	i2 = d.intd + rand()%d.reald;
	if (i1!=i2){ t = perm.p[i1]; perm.p[i1] = perm.p[i2]; perm.p[i2] = t; }
      }
    }
    roughr = ap_abstract0_permute_dimensions(manrough,false,rougha,&perm);
    precr = ap_abstract0_permute_dimensions(manprec,false,preca,&perm);
    RESULT('*');
    bool t1 = !is_leq(precr,roughr);
    bool t2 = ap_abstract0_random2_equal && !is_eq(precr,roughr);
    if (t1 || t2) {
      char msg[256];
      int n = 0;
      if (t1) n+=snprintf(msg+n,256-n,"no inclusion (error) ");
      if (t2) n+=snprintf(msg+n,256-n,"no equality (error)");
      ERROR(true,msg);
      ap_dimperm_fprint(stream,&perm);
      print_abstract("rougha",rougha); print_abstract("roughr",roughr); print_abstract("precr",precr);
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
    ap_dimperm_clear(&perm);
  } ENDLOOP;
}

void test_expand(void)
{
  printf("\nexpand dimensions\n");
  LOOP {
    ap_dim_t dd = rand() % nb_dim;
    size_t n = (rand() % 2) + 1;
    ap_abstract0_t* rougha,*roughr, *preca,*precr;
    ap_dimension_t d;
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    d = ap_abstract0_dimension(manrough,rougha);
    roughr = ap_abstract0_expand(manrough,false,rougha,dd,n);
    precr = ap_abstract0_expand(manprec,false,preca,dd,n);
    RESULT('*');
    bool t1 = !is_leq(precr,roughr);
    bool t2 = ap_abstract0_random2_equal && !is_eq(precr,roughr);
    if (t1 || t2) {
      char msg[256];
      int n = 0;
      if (t1) n+=snprintf(msg+n,256-n,"no inclusion (error) ");
      if (t2) n+=snprintf(msg+n,256-n,"no equality (error)");
      ERROR(true,msg);
      fprintf(stream,"dim %i expanded %i times\n",(int)dd,(int)n);
      print_abstract("rougha",rougha); print_abstract("roughr",roughr); print_abstract("precr",precr);
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
  } ENDLOOP;
}

void test_fold(void)
{
  printf("\nfold dimensions\n");
  LOOP {
    int i;
    ap_dim_t* dd;
    ap_abstract0_t* rougha,*roughr, *preca,*precr;
    ap_dimension_t d;
    ap_abstract0_random2(manprec,manrough,&preca,&rougha);
    d = ap_abstract0_dimension(manrough,rougha);
    bool intdim = d.intd>0 ? rand()%2 : false;
    if (d.reald==0) intdim = 1;
    int nb = 1 + (rand()%(intdim ? d.intd : d.reald));
    dd = malloc(nb*sizeof(ap_dim_t));
    for (i=0;i<nb;i++){
      if (intdim){
	if (i){
	  dd[i] = dd[i-1] + 1 + rand()%(d.intd-(nb-i)-dd[i-1]);
	} else {
	  dd[i] = rand()%(1+d.intd-nb);
	}
	assert(dd[i]<d.intd);
      } else {
	if (i){
	  dd[i] = dd[i-1] + 1 + rand()%(d.reald-(nb-i)-(dd[i-1]-d.intd));
	} else {
	  dd[i] = d.intd + rand()%(1+d.reald-nb);
	}
	assert(dd[i]>=d.intd && dd[i]<nb_dim);
      }
    }
    roughr = ap_abstract0_fold(manrough,false,rougha,dd,nb);
    precr = ap_abstract0_fold(manprec,false,preca,dd,nb);
    RESULT('*');
    bool t1 = !is_leq(precr,roughr);
    bool t2 = ap_abstract0_random2_equal && !is_eq(precr,roughr);
    if (t1 || t2) {
      char msg[256];
      int n = 0;
      if (t1) n+=snprintf(msg+n,256-n,"no inclusion (error) ");
      if (t2) n+=snprintf(msg+n,256-n,"no equality (sound)");
      ERROR(t1,msg);
      if (t1 || (t2 && warning)){
	fprintf(stream,"fold ");
	for (i=0;i<nb;i++){
	  fprintf(stream,"%i,",(int)dd[i]);
	}
	fprintf(stream,"\n");
	print_abstract("rougha",rougha); print_abstract("roughr",roughr); print_abstract("precr",precr);
      }
    }
    ap_abstract0_free(manrough,rougha); ap_abstract0_free(manprec,preca);
    ap_abstract0_free(manrough,roughr); ap_abstract0_free(manprec,precr);
  } ENDLOOP;
}

void test_widen(void)
{
  printf("\nwidening\n");
  LOOP {
    ap_abstract0_t* rough0, *rough1, *roughr;
    ap_abstract0_t* prec0, *prec1, *precr;
    rough0 = ap_abstract0_random(manrough);
    rough1 = ap_abstract0_random(manrough);
    rough1 = ap_abstract0_join(manrough,true,rough1,rough0);
    roughr = ap_abstract0_widening(manrough,rough0,rough1);
    prec0 = convert(manprec,rough0);
    prec1 = convert(manprec,rough1);
    precr = ap_abstract0_widening(manprec,prec0,prec1);
    RESULT('*');
    if (!is_leq(precr,roughr)) {
      ERROR(false,"different results (sound)");
      print_abstract("rough0",rough0); print_abstract("rough1",rough1);
      print_abstract("roughr",roughr); print_abstract("precr",precr);
    }
    ap_abstract0_free(manrough,rough0); ap_abstract0_free(manrough,rough1); ap_abstract0_free(manrough,roughr);
    ap_abstract0_free(manprec,prec0); ap_abstract0_free(manprec,prec1); ap_abstract0_free(manprec,precr);
  } ENDLOOP;
}

/* Main test function */
/* Depends on global variables manprec,manrough,intdim */
void test(ap_manager_t* man1, /* the most precise */
	  ap_manager_t* man2 /* the less precise */
)
{
  size_t i;

  manprec = man1;
  manrough = man2;
  for (i=0;i<AP_EXC_SIZE;i++){
    manprec->option.abort_if_exception[i] = true;
    manrough->option.abort_if_exception[i] = true;
  }
  error_ = warning_ = 0;

  printf(
      "\n\
COMPARING libraries %s (%s) with %s (%s)\n\
with dim=%zd, intdim=%zd, abs=%s, abs2=%s\n\
     lin=%s, tree=%s, maxcoeff=%zd, depth=%zd,\n\
     meetcons=%zd, meetjoin=%zd, asssub=%zd\n\
",
      manrough->library,manrough->version,
      manprec->library,manprec->version,
      nb_dim,nb_intdim,
      ap_abstract0_random==ap_abstract0_random_gen ? "gen" :
      (ap_abstract0_random==ap_abstract0_random_eq ? "eq" : "eqmod"),
      ap_abstract0_random2==ap_abstract0_random2_rough2prec ? "rough2prec" : "prec2rough",
      ap_linexpr0_set_random==ap_linexpr0_set_random_linear ? "full" :
      (ap_linexpr0_set_random==ap_linexpr0_set_random_quasilinear ? "quasi" : "int"),
      ap_texpr0_random==ap_texpr0_random_std ? "std" : "real",
      nb_maxcoeff,global_depth,nb_meetcons,nb_meetjoin_array,nb_assign_array
  );

  /* run tests */

  test_conv();
  test_bound_dimension();
  test_bound_linexpr();
  test_bound_texpr();
  test_sat_interval();
  test_sat_lincons();
  test_sat_tcons();
  test_to_box();

  test_meet();
  test_meet_array();
  test_meet_lincons_array();
  test_meet_tcons_array();
  test_join();
  test_join_array();
  test_add_ray();

  test_assign_linexpr();
  test_assign_linexpr_array();
  test_substitute_linexpr();
  test_substitute_linexpr_array();
  test_assign_texpr();
  test_assign_texpr_array();
  test_substitute_texpr();
  test_substitute_texpr_array();
  test_forget_array();

  test_add_dimensions();
  test_remove_dimensions();
  test_permute_dimensions();
  test_expand();
  test_fold();

  if (warning_ || error_){
    printf("\n");
    if (warning_) printf("%i warning(s) ",warning_);
    if (error_) printf("%i error(s)!",error_);
    printf("\n");
  }
  else printf("\nall tests passed\n");
}




/* main */
/* **** */

ap_manager_t* strtoman(char* name)
{
  ap_manager_t* man = NULL;
  if (strcmp(name,"box")==0) man = boxMPQ_manager_alloc();
  else if (strcmp(name,"oct")==0) man = octMPQ_manager_alloc();
  else if (strcmp(name,"pkl")==0) man = pkMPQ_manager_alloc(false);
  else if (strcmp(name,"pks")==0) man = pkMPQ_manager_alloc(true);
  else if (strcmp(name,"pkeq")==0) man = pkeqMPQ_manager_alloc();
  return man;
}

int main(int argc, char** argv)
{
  int i;

  stream = stdout;

  ap_abstract0_random = ap_abstract0_random_gen;
  ap_abstract0_random2 = ap_abstract0_random2_rough2prec;
  ap_linexpr0_set_random = ap_linexpr0_set_random_linear;
  ap_texpr0_random = ap_texpr0_random_std;

  i=1;
  while (i<argc && strncmp(argv[i],"-",1)==0){
    if (strcmp(argv[i],"-abs")==0){
      i++;
      if (i>=argc) goto main_exit;
      if (strcmp(argv[i],"gen")==0)
	ap_abstract0_random = ap_abstract0_random_gen;
      else if (strcmp(argv[i],"eq")==0)
	ap_abstract0_random = ap_abstract0_random_eq;
      else if (strcmp(argv[i],"eqmod")==0)
	ap_abstract0_random = ap_abstract0_random_eqmod;
      else goto main_exit;
    }
    else if (strcmp(argv[i],"-abs2")==0){
      i++;
      if (i>=argc) goto main_exit;
      if (strcmp(argv[i],"rough2prec")==0)
	ap_abstract0_random2 = ap_abstract0_random2_rough2prec;
      else if (strcmp(argv[i],"prec2rough")==0)
	ap_abstract0_random2 = ap_abstract0_random2_prec2rough;
      else goto main_exit;
    }
    else if (strcmp(argv[i],"-lin")==0){
      i++;
      if (i>=argc) goto main_exit;
      if (strcmp(argv[i],"full")==0)
	ap_linexpr0_set_random = ap_linexpr0_set_random_linear;
      else if (strcmp(argv[i],"quasi")==0)
	ap_linexpr0_set_random = ap_linexpr0_set_random_quasilinear;
      else if (strcmp(argv[i],"int")==0)
	ap_linexpr0_set_random = ap_linexpr0_set_random_intlinear;
      else goto main_exit;
    }
    else if (strcmp(argv[i],"-tree")==0){
      i++;
      if (i>=argc) goto main_exit;
      if (strcmp(argv[i],"std")==0)
	ap_texpr0_random = ap_texpr0_random_std;
      else if (strcmp(argv[i],"real")==0)
	ap_texpr0_random = ap_texpr0_random_real;
      else goto main_exit;
    }
    else if (strcmp(argv[i],"-dim")==0){
      i++;
      if (i>=argc) goto main_exit;
      nb_dim = strtol(argv[i],NULL,10);
      if (nb_dim==0) goto main_exit;
    }
    else if (strcmp(argv[i],"-intdim")==0){
      i++;
      if (i>=argc) goto main_exit;
      nb_intdim = strtol(argv[i],NULL,10);
      if (nb_intdim>nb_dim) nb_intdim = nb_dim;
    }
    else if (strcmp(argv[i],"-maxcoeff")==0){
      i++;
      if (i>=argc) goto main_exit;
      nb_maxcoeff = strtol(argv[i],NULL,10);
      if (nb_maxcoeff==0) goto main_exit;
    }
    else if (strcmp(argv[i],"-depth")==0){
      i++;
      if (i>=argc) goto main_exit;
      global_depth = strtol(argv[i],NULL,10);
      if (global_depth==0) goto main_exit;
    }
    else if (strcmp(argv[i],"-meetcons")==0){
      i++;
      if (i>=argc) goto main_exit;
      nb_meetcons = strtol(argv[i],NULL,10);
      if (nb_meetcons==0) goto main_exit;
    }
    else if (strcmp(argv[i],"-meetjoin")==0){
      i++;
      if (i>=argc) goto main_exit;
      nb_meetjoin_array = strtol(argv[i],NULL,10);
      if (nb_meetjoin_array==0) goto main_exit;
    }
    else if (strcmp(argv[i],"-asssub")==0){
      i++;
      if (i>=argc) goto main_exit;
      nb_assign_array = strtol(argv[i],NULL,10);
      if (nb_assign_array==0) goto main_exit;
      nb_substitute_array = nb_assign_array;
    }
    else
      goto main_exit;
    i++;
  }
  if (i+3 != argc) goto main_exit;
  manrough = strtoman(argv[i]);
  if (manrough==NULL) goto main_exit;
  i++;
  manprec = strtoman(argv[i]);
  if (manprec==NULL) goto main_exit;
  i++;
  unsigned long seed = strtol(argv[i],NULL,10);
  srand(seed);

  if (nb_assign_array>nb_dim){
    nb_assign_array = nb_substitute_array = nb_dim;
  }

  test(manprec,manrough);

  /* clean-up */
  ap_manager_free(manprec);
  ap_manager_free(manrough);
  return 0;
 main_exit:
  printf("\n\
usage: domain <options> <roughdom> <precdom> <seed>\n\
where <roughdom>: less precise domain, <precdom>: more precise domain\n\
to be picked in the list: box oct pkl pks\n\
Options are :\n\
  -dim <n>\n\
  -intdim <n>\n\
  -abs (gen|eq|eqmod)\n\
  -abs2 (rough2prec|prec2rough)\n\
  -lin (full|quasi|int)\n\
  -tree (std|real)\n\
  -maxcoeff <n>\n\
  -depth <n>\n\
  -meetcons <n>\n\
  -meetjoin <n>\n\
  -asssub <n>\n\
");
  return 1;
}
