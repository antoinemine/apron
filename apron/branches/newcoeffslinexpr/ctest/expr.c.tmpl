/* -*- mode: c -*- */

/* Testing expressions and cinstraints manipulation */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#include "eitv_all.h"
#include "num_conv.h"
MACRO_FOREACH XXX @AllNum
#include "ap_linconsXXX.h"
ENDMACRO
#include "ap_tcons0.h"
#include "ap_lincons0.h"

num_internal_t intern;
FILE* output=NULL;

/* ********************************************************************** */
/* FPU init */
/* ********************************************************************** */

/* simple run-time test that fpu behaves correctly */
static bool test_fpu(void)
{
  int i;
  long double d = 1., dd;
  /* find the minimal long double, as the fixpoint of x -> x/2 with rounding
     towards +oo;
     the max iteration value should be enough for 128-bit floating-point */
  for (i=0;i<5000000;i++) {
    dd = d;
    d /= 2;
    if (d==dd || d==0.) break;
  }
  /* fails if flush to 0 */
  if (d!=dd) { fprintf(stderr,"test_fpu failed test #1 after %i iterations\n",i); return false; }
  /* fails if long double rounding is not towards +oo */
  if (d*0.25!=dd) { fprintf(stderr,"test_fpu failed test #2\n"); return false; }
  /* fails if double rounding is not towards +oo */
  if ((double)d<dd) { fprintf(stderr,"test_fpu failed test #3\n"); return false; }
  /* fails if float rounding is not towards +oo */
  if ((float)d<dd) { fprintf(stderr,"test_fpu failed test #4\n"); return false; }
  return true;
}

#if defined(__ppc__)
static bool fpu_init(void)
{
  __asm volatile ("mtfsfi 7,2");
  return test_fpu();
}
#elif defined(__linux) || defined (__APPLE__)
#include <fenv.h>
static bool fpu_init(void)
{
  if (!fesetround(FE_UPWARD)) return test_fpu();
  fprintf(stderr,"could not set fpu rounding mode: fesetround failed\n");
  return false;
}
#elif defined(__FreeBSD__) || defined(sun)
#include <ieeefp.h>
static bool fpu_init(void)
{
  fpsetround(FP_RP);
  return test_fpu();
}
#else
static bool fpu_init(void)
{
  fprintf(stderr,"could not set fpu rounding mode: platform not supported\n");
  return false;
}

#endif

/* ********************************************************************** */
/* Testing normal ops */
/* ********************************************************************** */

void error(char* fmt, char* msg)
{
  fprintf(output,"error :");
  fprintf(output,fmt,msg);
  fprintf(output,"\n");
  abort();
}

ap_dim_t* tdim;
ap_dimchange_t changeadd, changeremove;
ap_dimperm_t perm;

void init_set_dimension(void)
{
  int i;
  ap_dimension_t dim = ap_dimension_make(0,4);

  tdim = malloc(6*sizeof(ap_dim_t));
  ap_dimchange_init(&changeadd,dim);
  changeadd.p[0]=1;
  changeadd.p[1]=2;
  changeadd.p[2]=2;
  changeadd.p[3]=4;
  ap_dimchange_init(&changeremove,dim);
  for (i=0;i<4; i++){
    changeremove.p[i] = changeadd.p[i];
  }
  ap_dimchange_add_invert(&changeremove);

  ap_dimperm_init(&perm,6);
  perm.p[0]=2;
  perm.p[1]=1;
  perm.p[2]=0;
  perm.p[3]=5;
  perm.p[4]=4;
  perm.p[5]=3;

  fprintf(stdout,"changeadd\t = ");
  ap_dimchange_fprint(stdout,&changeadd);
  fprintf(stdout,"\nchangeremove\t = ");
  ap_dimchange_fprint(stdout,&changeremove);
  fprintf(stdout,"\nperm\t = ");
  ap_dimperm_fprint(stdout,&perm);
  fprintf(stdout,"\n");
}

void clear_dimension(void)
{
  free(tdim);
  ap_dimchange_clear(&changeadd);
  ap_dimchange_clear(&changeremove);
  ap_dimperm_clear(&perm);
}


#define LSIZE 20
#define TSIZE LSIZE+8+6
ap_texpr0_t *texpr0[TSIZE];
ap_tcons0_t *tcons0[TSIZE];
ap_tcons0_array_t tconsarray[3];
ap_tcons0_array_t tconsarrayt;


MACRO_FOREACH XXX ("MPQ")
ap_linconsXXX_t linconsXXX[LSIZE];
ap_linexprXXX_ptr linexprXXX[LSIZE];
ap_linexprXXX_t envXXX[4];
ap_linconsXXX_array_t linconsarrayXXX[4];
ap_linconsXXX_array_t linconsarraytXXX;

void clear_linearXXX(void)
{
  int i;
  for (i=0; i<LSIZE; i++){
    ap_linconsXXX_clear(linconsXXX[i]);
  }
  for (i=0; i<2; i++){
    ap_linexprXXX_clear(envXXX[i]);
  }
  for (i=0;i<4;i++){
    ap_linconsXXX_array_clear(linconsarrayXXX[i]);
  }
  ap_linconsXXX_array_clear(linconsarraytXXX);
}
void init_set_linearXXX(void)
{
  int i;
  size_t index;
  eitvXXX_ptr eitv;

  /* Create a number of linear expressions */
  for (i=0; i<2; i++){
    ap_linexprXXX_init(envXXX[i],10);
  }
  for (i=0; i<LSIZE; i++){
    ap_linconsXXX_init(linconsXXX[i],2);
    linexprXXX[i] = linconsXXX[i]->linexpr;
  }
  bool error = false;

  ap_linexprXXX_set_list0(intern,envXXX[0],&error,
			  AP_COEFF_LINT2,1L,2L,0,
			  AP_COEFF_LINT2,-2L,-1L,1,
			  AP_COEFF_LINT,3L,2,
			  AP_COEFF_LINT2,1L,2L,4,
			  AP_COEFF_LINT2,-1L,1L,5,
			  AP_END);
  assert(!error);
  ap_linexprXXX_set(envXXX[1],envXXX[0]);
  eitv = ap_linexprXXX_eitvref0(envXXX[1],0,false);
  boundXXX_set_infty(eitv->itv->sup,1);
  eitv = ap_linexprXXX_eitvref0(envXXX[1],1,false);
  boundXXX_set_infty(eitv->itv->neginf,1);
  eitv = ap_linexprXXX_eitvref0(envXXX[1],4,false);
  boundXXX_set_infty(eitv->itv->neginf,1);
  eitv = ap_linexprXXX_eitvref0(envXXX[1],5,false);
  boundXXX_set_infty(eitv->itv->sup,1);

  for (i=0;i<2;i++){
    ap_linexprXXX_minimize(envXXX[i]);
    fprintf(stdout,"env[%d] \t= ",i);
    ap_linexprXXX_fprint(stdout,envXXX[i],0);
    fprintf(stdout,"\n");
  }

  /*
     0: 2x1 + 3x2 - x4 + 3
     1: -4/3 x0 + 19/8 x2 - 3x5 - 4
     2: as 0 with interval constant obtained by enlarging
     3:
     4: as 2 with first coeff enlarged
     5:
     6: as 4 with neginf/sup constant bound set to infty
     7:
     8: as 4 with neginf/sup coeff bound set to infty
     9:
  */
  ap_linexprXXX_set_list0(intern,linexprXXX[0],&error,
			  AP_COEFF_LINT,2L,1,
			  AP_COEFF_LINT,3L,2,
			  AP_COEFF_LINT,-1L,4,
			  AP_CST_LINT,3L,
			  AP_END);
  assert(!error);
  ap_linexprXXX_set_list0(intern,linexprXXX[1],&error,
			  AP_COEFF_LFRAC,-4L,3L,0,
			  AP_COEFF_LFRAC,19L,8L,2,
			  AP_COEFF_LINT,-3L,5,
			  AP_CST_LINT,-4L,
			  AP_END);
  assert(!error);
  for (i=0; i<2; i++){
    ap_dim_t dim;
    boundXXX_t bound;
    boundXXX_init(bound);
    double k=0.5;
    boundXXX_set_numD(bound,&k,intern);

    ap_linexprXXX_set(linexprXXX[i+2],linexprXXX[i]);
    eitvXXX_enlarge_bound(linexprXXX[i+2]->cst,linexprXXX[i]->cst,bound);

    ap_linexprXXX_set(linexprXXX[i+4],linexprXXX[i+2]);
    ap_linexprXXX_ForeachLinterm0(linexprXXX[i+4],index,dim,eitv){
      eitvXXX_enlarge_bound(eitv,eitv,bound);
      break;
    }

    ap_linexprXXX_set(linexprXXX[i+6],linexprXXX[i+2]);
    if (i==0)
      boundXXX_set_infty(linexprXXX[i+6]->cst->itv->neginf,1);
    else
      boundXXX_set_infty(linexprXXX[i+6]->cst->itv->sup,1);

    ap_linexprXXX_set(linexprXXX[i+8],linexprXXX[i+4]);
    ap_linexprXXX_ForeachLinterm0(linexprXXX[i+8],index,dim,eitv){
      if (i==0)
	boundXXX_set_infty(eitv->itv->sup,1);
      else
	boundXXX_set_infty(eitv->itv->neginf,1);
      break;
    }
    boundXXX_clear(bound);
  }
  for (i=0;i<10;i++){
    linconsXXX[i]->constyp = AP_CONS_SUPEQ;
    ap_linconsXXX_set(linconsXXX[i+10],linconsXXX[i]);
    linconsXXX[i+10]->constyp = AP_CONS_EQ;
    ap_linconsXXX_minimize(linconsXXX[i]);
  }

  /* Arrays */
  ap_linconsXXX_array_init(linconsarrayXXX[0],7);
  for (i=0;i<6;i++){
    ap_linconsXXX_set(linconsarrayXXX[0]->p[i],linconsXXX[i]);
  }
  ap_linconsXXX_set_bool(linconsarrayXXX[0]->p[6],true);
  fprintf(stdout,"array[0]=\n");

  ap_linconsXXX_array_init(linconsarrayXXX[1],9);
  for (i=0;i<6;i++){
    ap_linconsXXX_set(linconsarrayXXX[1]->p[i],linconsXXX[i]);
  }
  for (i=8;i<10;i++){
    ap_linconsXXX_set(linconsarrayXXX[1]->p[i-2],linconsXXX[i]);
  }
  ap_linconsXXX_set_bool(linconsarrayXXX[1]->p[8],true);
  fprintf(stdout,"array[1]=\n");

  ap_linconsXXX_array_init(linconsarrayXXX[2],22);
  ap_linconsXXX_set_bool(linconsarrayXXX[2]->p[0],true);
  for (i=0;i<20;i++){
    ap_linconsXXX_set(linconsarrayXXX[2]->p[i+1],linconsXXX[i]);
  }
  ap_linconsXXX_set_bool(linconsarrayXXX[2]->p[21],true);
  fprintf(stdout,"array[2]=\n");

  ap_linconsXXX_array_init_set(linconsarrayXXX[3],linconsarrayXXX[2]);
  ap_linconsXXX_set_bool(linconsarrayXXX[3]->p[21],false);
  fprintf(stdout,"array[3]=\n");

  ap_linconsXXX_array_init(linconsarraytXXX,0);

  for (i=0;i<LSIZE;i++){
    fprintf(stdout,"lincons[%d] \t= ",i);
    ap_linconsXXX_fprint(stdout,linconsXXX[i],0);
    fprintf(stdout,"\n");
  }
  for (i=0;i<4;i++){
    fprintf(stdout,"array[%d] \t=\n",i);
    ap_linconsXXX_array_fprint(stdout,linconsarrayXXX[i],0);
  }
}
/* ********************************************************************** */
/* linexprXXX */
/* ********************************************************************** */

void test_linexprXXX(void)
{
  int i,j;
  ap_linexprXXX_t expr;

  ap_linexprXXX_init(expr,0);

  {
    size_t k,size;

    for (i=0; i<10; i++){
      fprintf(stdout,"linexpr[%d] :\n\tsupport\t = ",i);
      size = ap_linexprXXX_support(linexprXXX[i],tdim);
      for (k=0;k<size;k++){
	fprintf(stdout,"%d,",tdim[k]);
      }
      fprintf(stdout,"\n\tsupportinterval\t = ");
      size = ap_linexprXXX_supportinterval(linexprXXX[i],tdim);
      for (k=0;k<size;k++){
	fprintf(stdout,"%d,",tdim[k]);
      }
      fprintf(stdout,"\n");

      bool bi1 = ap_linexprXXX_is_integer(linexprXXX[i],4);
      bool br1 = ap_linexprXXX_is_real(linexprXXX[i],4);
      bool bi2 = ap_linexprXXX_is_integer(linexprXXX[i],5);
      bool br2 = ap_linexprXXX_is_real(linexprXXX[i],5);
      bool lin = ap_linexprXXX_is_linear(linexprXXX[i]);
      bool quasilin = ap_linexprXXX_is_quasilinear(linexprXXX[i]);
      ap_linexpr_type_t typ = ap_linexprXXX_type(linexprXXX[i]);

      fprintf(stdout,"\tintdim=4: is_integer=%hhd, is_real=%hhd\n",bi1,br1);
      fprintf(stdout,"\tintdim=5: is_integer=%hhd, is_real=%hhd\n",bi2,br2);
      fprintf(stdout,"\tis_linear=%hhd, is_quasilinear=%hhd, typ=%d\n",lin,quasilin,typ);
    }
  }

  for (i=0; i<2; i++){
    ap_linexprXXX_add_dimensions(expr,linexprXXX[i],&changeadd);
    fprintf(stdout,"add_dimensions linexprXXX[%d]\t = ",i);
    ap_linexprXXX_fprint(stdout,expr,0);
    fprintf(stdout,"\n");
    ap_linexprXXX_permute_dimensions(expr,linexprXXX[i],&perm);
    fprintf(stdout,"permute linexprXXX[%d]\t = ",i);
    ap_linexprXXX_fprint(stdout,expr,0);
    fprintf(stdout,"\n");
  }

  ap_linexprXXX_set(expr,linexprXXX[0]);
  ap_linexprXXX_set_zero(expr);
  fprintf(stdout,"set_zero linexpr[0] = ");
  ap_linexprXXX_fprint(stdout,expr,0);
  fprintf(stdout,"\n");

  for (i=0; i<10; i++){
    ap_linexprXXX_neg(expr,linexprXXX[i]);
    fprintf(stdout,"neg linexpr[%d] = ",i);
    ap_linexprXXX_fprint(stdout,expr,0);
    fprintf(stdout,"\n");
  }
  for (i=0; i<5; i++){
    ap_linexprXXX_add(expr,linexprXXX[2*i],linexprXXX[2*i+1],intern);

    fprintf(stdout,"add linexpr[%d] linexpr[%d] = ",2*i,2*i+1);
    ap_linexprXXX_fprint(stdout,expr,0);
    fprintf(stdout,"\n");
  }
  for (i=0; i<5; i++){
    ap_linexprXXX_sub(expr,linexprXXX[2*i],linexprXXX[2*i+1],intern);

    fprintf(stdout,"sub linexpr[%d] linexpr[%d] = ",2*i,2*i+1);
    ap_linexprXXX_fprint(stdout,expr,0);
    fprintf(stdout,"\n");
  }
  {
    eitvXXX_t eitv[8];
    for (j=0; j<8; j++) eitvXXX_init(eitv[j]);

    eitvXXX_set_val(intern,eitv[0],EITV_LINT,2L);
    eitvXXX_set_val(intern,eitv[1],EITV_LINT2,1L,2L);
    eitvXXX_set(eitv[2],eitv[1]);
    boundXXX_set_infty(eitv[2]->itv->sup,1);
    eitvXXX_set(eitv[3],eitv[1]);
    boundXXX_set_infty(eitv[3]->itv->neginf,1);
    for (j=0;j<4;j++) eitvXXX_neg(eitv[j+4],eitv[j]);

    for (i=0; i<10; i++){
      for (j=0; j<8;j++){
	ap_linexprXXX_scale(expr,linexprXXX[i],eitv[j],intern);
	fprintf(stdout,"scale linexpr[%d]\t ",i);
	eitvXXX_fprint(stdout,eitv[j]);
	fprintf(stdout,"\t = ");
	ap_linexprXXX_fprint(stdout,expr,0);
	fprintf(stdout,"\n");
      }
    }
    for (i=0; i<10; i++){
      for (j=0; j<8;j++){
	ap_linexprXXX_div(expr,linexprXXX[i],eitv[j],intern);
	fprintf(stdout,"div linexpr[%d]\t ",i);
	eitvXXX_fprint(stdout,eitv[j]);
	fprintf(stdout,"\t = ");
	ap_linexprXXX_fprint(stdout,expr,0);
	fprintf(stdout,"\n");
      }
    }
    for (j=0; j<8; j++) eitvXXX_clear(eitv[j]);
  }
  {
    eitvXXX_t eitv;
    eitvXXX_init(eitv);

    for (i=0; i<10; i++){
      for (j=0;j<2;j++){
	ap_linexprXXX_set(expr,linexprXXX[i]);
	ap_linexprXXX_quasilinearize(expr,envXXX[j],false,intern);
	fprintf(stdout,"quasilinearize linexpr[%d] env[%d]= ",i,j);
	ap_linexprXXX_fprint(stdout,expr,NULL);
	fprintf(stdout,"\n");

	ap_linexprXXX_set(expr,linexprXXX[i]);
	ap_linexprXXX_quasilinearize(expr,envXXX[j],true,intern);
	fprintf(stdout,"quasilinearize linexpr[%d] env[%d] for meet = ",i,j);
	ap_linexprXXX_fprint(stdout,expr,NULL);
	fprintf(stdout,"\n");

	ap_linexprXXX_eval(eitv,linexprXXX[i],envXXX[j],intern);
	fprintf(stdout,"eval linexpr[%d] env[%d]= ",i,j);
	eitvXXX_fprint(stdout,eitv);
	fprintf(stdout,"\n");
      }
    }
    eitvXXX_clear(eitv);
  }
  ap_linexprXXX_clear(expr);
}

/* ********************************************************************** */
/* linconsXXX */
/* ********************************************************************** */

void test_linconsXXX(void)
{
  int i,j;
  ap_linconsXXX_t cons;

  ap_linconsXXX_init(cons,0);

  {
    ap_dim_t* tdim = malloc(6*sizeof(ap_dim_t));
    size_t k,size;

    for (i=0; i<20; i++){
      fprintf(stdout,"lincons[%d] :\n\tsupport\t = ",i);
      size = ap_linconsXXX_support(linconsXXX[i],tdim);
      for (k=0;k<size;k++){
	fprintf(stdout,"%d,",tdim[k]);
      }
      fprintf(stdout,"\n\tsupportinterval\t = ");
      size = ap_linconsXXX_supportinterval(linconsXXX[i],tdim);
      for (k=0;k<size;k++){
	fprintf(stdout,"%d,",tdim[k]);
      }
      fprintf(stdout,"\n");

      bool bi1 = ap_linconsXXX_is_integer(linconsXXX[i],4);
      bool br1 = ap_linconsXXX_is_real(linconsXXX[i],4);
      bool bi2 = ap_linconsXXX_is_integer(linconsXXX[i],5);
      bool br2 = ap_linconsXXX_is_real(linconsXXX[i],5);
      bool lin = ap_linconsXXX_is_linear(linconsXXX[i]);
      bool quasilin = ap_linconsXXX_is_quasilinear(linconsXXX[i]);
      ap_linexpr_type_t typ = ap_linconsXXX_type(linconsXXX[i]);
      bool sat = ap_linconsXXX_sat_is_false(linconsXXX[i],intern);
      fprintf(stdout,"\tintdim=4: is_integer=%hhd, is_real=%hhd\n",bi1,br1);
      fprintf(stdout,"\tintdim=5: is_integer=%hhd, is_real=%hhd\n",bi2,br2);
      fprintf(stdout,"\tis_linear=%hhd, is_quasilinear=%hhd, typ=%d\n",lin,quasilin,typ);
      fprintf(stdout,"\tsat_is_false=%hhd\n",sat);
    }
    free(tdim);
  }

  for (i=0; i<2; i++){
    ap_linconsXXX_add_dimensions(cons,linconsXXX[i],&changeadd);
    fprintf(stdout,"add_dimensions linconsXXX[%d]\t = ",i);
    ap_linconsXXX_fprint(stdout,cons,0);
    fprintf(stdout,"\n");
    ap_linconsXXX_permute_dimensions(cons,linconsXXX[i],&perm);
    fprintf(stdout,"permute linconsXXX[%d]\t = ",i);
    ap_linconsXXX_fprint(stdout,cons,0);
    fprintf(stdout,"\n");
  }

  ap_linconsXXX_set(cons,linconsXXX[0]);
  ap_linconsXXX_set_zero(cons);
  fprintf(stdout,"set_zero lincons[0] = ");
  ap_linconsXXX_fprint(stdout,cons,0);
  fprintf(stdout,"\n");

  ap_linconsXXX_set(cons,linconsXXX[0]);
  ap_linconsXXX_set_bool(cons,false);
  fprintf(stdout,"set_bool lincons[0] false = ");
  ap_linconsXXX_fprint(stdout,cons,0);
  {
    tbool_t tb = ap_linconsXXX_evalcst(cons,intern);
    fprintf(stdout,"\t eval_cst = %d\n",tb);
  }
  ap_linconsXXX_set(cons,linconsXXX[0]);
  ap_linconsXXX_set_bool(cons,true);
  fprintf(stdout,"set_bool lincons[0] true = ");
  ap_linconsXXX_fprint(stdout,cons,0);
  {
    tbool_t tb = ap_linconsXXX_evalcst(cons,intern);
    fprintf(stdout,"\t eval_cst = %d\n",tb);
  }

  for (i=0;i<4;i++){
    for (j=0;j<2; j++){
      ap_linconsXXX_set(cons,linconsXXX[i+10*j]);
      ap_linconsXXX_reduce_integer(cons,4,intern);
      fprintf(stdout,"reduce_integer lincons[%d] 4 = ",i+10*j);
      ap_linconsXXX_fprint(stdout,cons,NULL);
      fprintf(stdout,"\n");
    }
  }

  {
    eitvXXX_t eitv;
    eitvXXX_init(eitv);
    for (i=0; i<10; i++){
      for (j=0;j<2;j++){
	ap_linconsXXX_set(cons,linconsXXX[i]);
	ap_linconsXXX_quasilinearize(cons,envXXX[j],false,intern);
	fprintf(stdout,"quasilinearize lincons[%d] env[%d] = ",i,j);
	ap_linconsXXX_fprint(stdout,cons,NULL);
	fprintf(stdout,"\n");

	ap_linconsXXX_set(cons,linconsXXX[i]);
	ap_linconsXXX_quasilinearize(cons,envXXX[j],true,intern);
	fprintf(stdout,"quasilinearize lincons[%d] env[%d] for meet = ",i,j);
	ap_linconsXXX_fprint(stdout,cons,NULL);
	fprintf(stdout,"\n");
      }
    }
    eitvXXX_clear(eitv);
  }

  /* ====================================================================== */
  /* linconsXXXX_array */
  /* ====================================================================== */


  {
    size_t k,size;

    fprintf(stdout,"array[0]=\n\tsupport\t = ");
    size = ap_linconsXXX_array_support(linconsarrayXXX[0],tdim,6);
    for (k=0;k<size;k++){
      fprintf(stdout,"%d,",tdim[k]);
    }
    fprintf(stdout,"\n\tsupportinterval\t = ");
    size = ap_linconsXXX_array_supportinterval(linconsarrayXXX[0],tdim,6);
    for (k=0;k<size;k++){
      fprintf(stdout,"%d,",tdim[k]);
    }
    fprintf(stdout,"\n");

    bool lin = ap_linconsXXX_array_is_linear(linconsarrayXXX[0]);
    bool quasilin = ap_linconsXXX_array_is_quasilinear(linconsarrayXXX[0]);
    ap_linexpr_type_t typ = ap_linconsXXX_array_type(linconsarrayXXX[0]);
    fprintf(stdout,"\tis_linear=%hhd, is_quasilinear=%hhd, typ=%d\n",lin,quasilin,typ);
  }

  ap_linconsXXX_array_add_dimensions(linconsarraytXXX,linconsarrayXXX[0],&changeadd);
  fprintf(stdout,"add_dimensions array[0] =\n");
  ap_linconsXXX_array_fprint(stdout,linconsarraytXXX,0);
  ap_linconsXXX_array_permute_dimensions(linconsarraytXXX,linconsarrayXXX[0],&perm);
  fprintf(stdout,"permute array[0] =\n");
  ap_linconsXXX_array_fprint(stdout,linconsarraytXXX,0);

  {
    int meet;
    for (i=0; i<4; i++){
      for (meet=0; meet<2; meet++){
	ap_linconsXXX_array_set(linconsarraytXXX,linconsarrayXXX[i]);
	tbool_t tb = ap_linconsXXX_array_reduce(linconsarraytXXX,meet,intern);
	fprintf(stdout,"array_reduce array[%d] meet=%d = %d\n",i,meet,tb);
	ap_linconsXXX_array_fprint(stdout,linconsarraytXXX,0);
      }
    }
  }
  {
    int meet;
    for (i=0; i<4; i++){
      for (j=0;j<2;j++){
	for (meet=0;meet<2;meet++){
	  ap_linconsXXX_array_set(linconsarraytXXX,linconsarrayXXX[i]);
	  bool b = ap_linconsXXX_array_quasilinearize(linconsarraytXXX,envXXX[j],meet,intern);
	  fprintf(stdout,"quasilinearize array[%d] env[%d] meet=%d = %hhd\n",i,j,meet,b);
	  ap_linconsXXX_array_fprint(stdout,linconsarraytXXX,NULL);
	  if (meet){
	    ap_linconsXXX_array_reduce_integer(linconsarraytXXX,5,intern);
	    fprintf(stdout,"array_reduce_integer = \n");
	  }
	  else {
	    ap_linconsXXX_array_reduce(linconsarraytXXX,meet,intern);
	    fprintf(stdout,"array_reduce = \n");
	  }
	  ap_linconsXXX_array_fprint(stdout,linconsarraytXXX,NULL);
	  ap_linconsXXX_array_fprint(stdout,linconsarraytXXX,NULL);
	  ap_linconsXXX_array_linearize(linconsarraytXXX,meet,intern);
	  fprintf(stdout,"linearize = \n");
	  ap_linconsXXX_array_fprint(stdout,linconsarraytXXX,NULL);
	}
      }
    }
  }
  ap_linconsXXX_clear(cons);
}

/* ********************************************************************** */
/* treeXXX */
/* ********************************************************************** */

void test_treeXXX(void)
{
  int i,j;

  for (i=0;i<TSIZE;i++){
    ap_dim_t dim = ap_tcons0_max_dim(tcons0[i]);
    size_t size = ap_tcons0_support(tcons0[i],tdim);
    bool bc = ap_tcons0_is_interval_cst(tcons0[i]);
    bool bl = ap_tcons0_is_interval_linear(tcons0[i]);
    bool bp = ap_tcons0_is_interval_polynomial(tcons0[i]);
    bool bf = ap_tcons0_is_interval_polyfrac(tcons0[i]);
    bool bs = ap_tcons0_is_scalar(tcons0[i]);
    fprintf(stdout,"tcons0[%d]:\n",i);
    fprintf(stdout,"\tmaxdim = %d, support = ",(int)dim);
    for (j=0;j<(int)size;j++){
      fprintf(stdout,"%d,",(int)tdim[j]);
    }
    fprintf(stdout,"\n\tis_itv_cst=%hhd, is_itv_linear=%hhd, is_itv_poly=%hhd, is_itv_polyfrac=%hhd, is_scalar=%hhd\n\thas_dim: ",
	    bc,bl,bp,bf,bs);
    for (dim=0;dim<6;dim++){
      bool b = ap_tcons0_has_dim(tcons0[i],dim);
      if (b) fprintf(stdout,"%d,",(int)dim);
    }
    fprintf(stdout,"\n");
  }

  {
    ap_tcons0_t* tcons;

    tcons = ap_tcons0_add_dimensions(tcons0[0],&changeadd);
    fprintf(stdout,"add_dimensions tcons0[0] = ");
    ap_tcons0_print(tcons,0);
    fprintf(stdout,"\n");
    ap_tcons0_free(tcons);
    tcons = ap_tcons0_permute_dimensions(tcons0[0],&perm);
    fprintf(stdout,"permute tcons0[0] = ");
    ap_tcons0_print(tcons,0);
    fprintf(stdout,"\n");
    ap_tcons0_free(tcons);
  }

  {
    ap_linconsXXX_t lincons;
    bool error;
    ap_linconsXXX_init(lincons,0);
    for (i=0;i<TSIZE;i++){
      ap_linconsXXX_set_tcons0(lincons,&error,tcons0[i],intern);
      fprintf(stdout,"ap_linconsXXX_set_tcons tcons0[%d] = ",i);
      if (error)
	fprintf(stdout,"error=true");
      else
	ap_linconsXXX_fprint(stdout,lincons,0);
      fprintf(stdout,"\n");
      if (error){
	for (j=0;j<2;j++){
	  ap_linconsXXX_intlinearize_tcons0(lincons,tcons0[i],envXXX[j],5,intern);
	  fprintf(stdout,"\tap_linconsXXX_intlinearize_tcons0 tcons0[%d] envXXX[%d] = ",i,j);
	  ap_linconsXXX_fprint(stdout,lincons,0);
	  bool is_quasilinear = ap_linconsXXX_is_quasilinear(lincons);
	  fprintf(stdout,"\n\tis_quasilinear=%hhd\n",is_quasilinear);
	  if (!is_quasilinear){
	    for (int meet=0;meet<2;meet++){
	      ap_linconsXXX_quasilinearize(lincons,envXXX[j],meet,intern);
	      fprintf(stdout,"\tquasilinearize lincons meet=%d = ",meet);
	      ap_linconsXXX_fprint(stdout,lincons,0);
	      fprintf(stdout,"\n");
	    }
	  }
	}
      }
    }
    ap_linconsXXX_clear(lincons);
  }

  /* ====================================================================== */
  /* tcons0_array */
  /* ====================================================================== */





}
ENDMACRO

void init_set_tree(void)
{
  ap_coeff_t coeff;
  int i;

  ap_coeff_init(coeff,AP_SCALAR_MPQ);

  for (i=0;i<LSIZE;i++){
    ap_lincons0_t lincons0;
    ap_lincons0_cons_MPQ(lincons0,linconsMPQ[i]);
    tcons0[i] = ap_tcons0_from_lincons0(lincons0);
    texpr0[i] = tcons0[i]->texpr0;
  }
  ap_coeff_set_val(intern, coeff, AP_COEFF_LINT2,-7L,-1L);
  texpr0[LSIZE] = ap_texpr0_unop(AP_TEXPR_SQRT,
				 ap_texpr0_cst(coeff),
				 AP_RTYPE_DOUBLE,AP_RDIR_RND);
  ap_coeff_set_val(intern, coeff, AP_COEFF_LINT2,-7L,8L);
  texpr0[LSIZE+1] = ap_texpr0_unop(AP_TEXPR_SQRT,
				   ap_texpr0_cst(coeff),
				   AP_RTYPE_DOUBLE,AP_RDIR_RND);
  texpr0[LSIZE+2] = ap_texpr0_unop(AP_TEXPR_SQRT,
				   ap_texpr0_dim(5),
				   AP_RTYPE_DOUBLE,AP_RDIR_RND);
  texpr0[LSIZE+3] = ap_texpr0_binop(AP_TEXPR_SUB,
				    ap_texpr0_copy(texpr0[LSIZE+1]),
				    ap_texpr0_copy(texpr0[LSIZE+2]),
				    AP_RTYPE_REAL,AP_RDIR_RND);
  texpr0[LSIZE+4] = ap_texpr0_binop(AP_TEXPR_ADD,
				    ap_texpr0_copy(texpr0[0]),
				    ap_texpr0_copy(texpr0[1]),
				    AP_RTYPE_REAL,AP_RDIR_RND);
  texpr0[LSIZE+5] = ap_texpr0_binop(AP_TEXPR_SUB,
				    ap_texpr0_copy(texpr0[0]),
				    ap_texpr0_copy(texpr0[1]),
				    AP_RTYPE_REAL,AP_RDIR_RND);
  texpr0[LSIZE+6] = ap_texpr0_binop(AP_TEXPR_MUL,
				    ap_texpr0_copy(texpr0[0]),
				    ap_texpr0_copy(texpr0[1]),
				    AP_RTYPE_REAL,AP_RDIR_RND);
  texpr0[LSIZE+7] = ap_texpr0_binop(AP_TEXPR_DIV,
				    ap_texpr0_copy(texpr0[0]),
				    ap_texpr0_copy(texpr0[1]),
				    AP_RTYPE_REAL,AP_RDIR_RND);
  for (i=0;i<6; i++){
    texpr0[LSIZE+8+i] = ap_texpr0_binop(AP_TEXPR_MUL,
					ap_texpr0_dim(i),
					ap_texpr0_copy(texpr0[0]),
					AP_RTYPE_REAL,AP_RDIR_RND);
  }
  for (i=LSIZE; i<TSIZE; i++){
    tcons0[i] = ap_tcons0_make(texpr0[i],AP_CONS_SUPEQ,NULL);
  }
  for (i=0;i<TSIZE;i++){
    fprintf(stdout,"tcons0[%d] = ",i);
    ap_tcons0_fprint(stdout,tcons0[i],NULL);
    fprintf(stdout,"\n");
  }

  array[0] = ap_tcons0_array_make(1);
  array[0].p[0] = ap_tcons0_copy(tcons0[LSIZE]);
  array[1] = ap_tcons0_array_make(3);
  for (i=0; i<3; i++){
    array[1].p[i] = ap_tcons0_copy(tcons0[LSIZE+1+i]);
  }
  array[2] = ap_tcons0_array_make(TSIZE-LSIZE-1);
  for (i=0; i<TSIZE-LSIZE-1; i++){
    array[2].p[i] = ap_tcons0_copy(tcons0[LSIZE+1+i]);
  }


  ap_coeff_clear(coeff);
}

void clear_tree(void)
{
  int i;
  for (i=0; i<TSIZE; i++){
    ap_tcons0_free(tcons0[i]);
  }
}


int main(void)
{
  fpu_init();
  /*  mpfr_set_default_prec(4046);*/
  mpfr_set_default_prec(53);
  num_internal_init(intern);

  output = stdout;
  init_set_dimension();
  init_set_linearMPQ();
  init_set_tree();
  test_linexprMPQ();
  test_linconsMPQ();
  test_treeMPQ();
  clear_tree();
  clear_linearMPQ();
  clear_dimension();

  num_internal_clear(intern);
  return 0;
}
