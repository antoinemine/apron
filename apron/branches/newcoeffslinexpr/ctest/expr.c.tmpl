/* -*- mode: c -*- */

/* Testing expressions and cinstraints manipulation */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#include "eitv_all.h"
#include "num_conv.h"
MACRO_FOREACH XXX @AllNum
#include "ap_linconsXXX.h"
ENDMACRO


num_internal_t intern;
FILE* output=NULL;

/* ********************************************************************** */
/* FPU init */
/* ********************************************************************** */

/* simple run-time test that fpu behaves correctly */
static bool test_fpu(void)
{
  int i;
  long double d = 1., dd;
  /* find the minimal long double, as the fixpoint of x -> x/2 with rounding
     towards +oo;
     the max iteration value should be enough for 128-bit floating-point */
  for (i=0;i<5000000;i++) {
    dd = d;
    d /= 2;
    if (d==dd || d==0.) break;
  }
  /* fails if flush to 0 */
  if (d!=dd) { fprintf(stderr,"test_fpu failed test #1 after %i iterations\n",i); return false; }
  /* fails if long double rounding is not towards +oo */
  if (d*0.25!=dd) { fprintf(stderr,"test_fpu failed test #2\n"); return false; }
  /* fails if double rounding is not towards +oo */
  if ((double)d<dd) { fprintf(stderr,"test_fpu failed test #3\n"); return false; }
  /* fails if float rounding is not towards +oo */
  if ((float)d<dd) { fprintf(stderr,"test_fpu failed test #4\n"); return false; }
  return true;
}

#if defined(__ppc__)
static bool fpu_init(void)
{
  __asm volatile ("mtfsfi 7,2");
  return test_fpu();
}
#elif defined(__linux) || defined (__APPLE__)
#include <fenv.h>
static bool fpu_init(void)
{
  if (!fesetround(FE_UPWARD)) return test_fpu();
  fprintf(stderr,"could not set fpu rounding mode: fesetround failed\n");
  return false;
}
#elif defined(__FreeBSD__) || defined(sun)
#include <ieeefp.h>
static bool fpu_init(void)
{
  fpsetround(FP_RP);
  return test_fpu();
}
#else
static bool fpu_init(void)
{
  fprintf(stderr,"could not set fpu rounding mode: platform not supported\n");
  return false;
}

#endif

/* ********************************************************************** */
/* Testing normal ops */
/* ********************************************************************** */

void error(char* fmt, char* msg)
{
  fprintf(output,"error :");
  fprintf(output,fmt,msg);
  fprintf(output,"\n");
  abort();
}

#define LSIZE 20


MACRO_FOREACH XXX ("MPQ")
ap_linconsXXX_t linconsXXX[LSIZE];
ap_linexprXXX_ptr linexprXXX[LSIZE];
ap_linexprXXX_t envXXX[2];

void clear_linearXXX(void)
{
  int i;
  for (i=0; i<LSIZE; i++){
    ap_linconsXXX_clear(linconsXXX[i]);
  }
  for (i=0; i<2; i++){
    ap_linexprXXX_clear(envXXX[i]);
  }
}
void init_set_linearXXX(void)
{
  int i;
  size_t index;
  eitvXXX_ptr eitv;

  /* Create a number of linear expressions */
  for (i=0; i<2; i++){
    ap_linexprXXX_init(envXXX[i],10);
  }
  for (i=0; i<LSIZE; i++){
    ap_linconsXXX_init(linconsXXX[i],2);
    linexprXXX[i] = linconsXXX[i]->linexpr;
  }
  bool error = false;

  ap_linexprXXX_set_list0(intern,envXXX[0],&error,
			  AP_COEFF_LINT2,1L,2L,0,
			  AP_COEFF_LINT2,-2L,-1L,1,
			  AP_COEFF_LINT,3L,2,
			  AP_COEFF_LINT2,1L,2L,4,
			  AP_COEFF_LINT2,-1L,1L,5,
			  AP_END);
  assert(!error);
  ap_linexprXXX_set(envXXX[1],envXXX[0]);
  eitv = ap_linexprXXX_eitvref0(envXXX[1],0,false);
  boundXXX_set_infty(eitv->itv->sup,1);
  eitv = ap_linexprXXX_eitvref0(envXXX[1],1,false);
  boundXXX_set_infty(eitv->itv->neginf,1);
  eitv = ap_linexprXXX_eitvref0(envXXX[1],4,false);
  boundXXX_set_infty(eitv->itv->neginf,1);
  eitv = ap_linexprXXX_eitvref0(envXXX[1],5,false);
  boundXXX_set_infty(eitv->itv->sup,1);

  for (i=0;i<2;i++){
    ap_linexprXXX_minimize(envXXX[i]);
    fprintf(stdout,"env[%d] \t= ",i);
    ap_linexprXXX_fprint(stdout,envXXX[i],0);
    fprintf(stdout,"\n");
  }


  /*
     0: 2x1 + 3x2 - x4 + 3
     1: -4/3 x0 + 19/8 x2 - 3x5 - 4
     2: as 0 with interval constant obtained by enlarging
     3:
     4: as 2 with first coeff enlarged
     5:
     6: as 4 with neginf/sup constant bound set to infty
     7:
     8: as 4 with neginf/sup coeff bound set to infty
     9:
  */
  ap_linexprXXX_set_list0(intern,linexprXXX[0],&error,
			  AP_COEFF_LINT,2L,1,
			  AP_COEFF_LINT,3L,2,
			  AP_COEFF_LINT,-1L,4,
			  AP_CST_LINT,3L,
			  AP_END);
  assert(!error);
  ap_linexprXXX_set_list0(intern,linexprXXX[1],&error,
			  AP_COEFF_LFRAC,-4L,3L,0,
			  AP_COEFF_LFRAC,19L,8L,2,
			  AP_COEFF_LINT,-3L,5,
			  AP_CST_LINT,-4L,
			  AP_END);
  assert(!error);
  for (i=0; i<2; i++){
    ap_dim_t dim;
    boundXXX_t bound;
    boundXXX_init(bound);
    double k=0.5;
    boundXXX_set_numD(bound,&k,intern);

    ap_linexprXXX_set(linexprXXX[i+2],linexprXXX[i]);
    eitvXXX_enlarge_bound(linexprXXX[i+2]->cst,linexprXXX[i]->cst,bound);

    ap_linexprXXX_set(linexprXXX[i+4],linexprXXX[i+2]);
    ap_linexprXXX_ForeachLinterm0(linexprXXX[i+4],index,dim,eitv){
      eitvXXX_enlarge_bound(eitv,eitv,bound);
      break;
    }

    ap_linexprXXX_set(linexprXXX[i+6],linexprXXX[i+2]);
    if (i==0)
      boundXXX_set_infty(linexprXXX[i+6]->cst->itv->neginf,1);
    else
      boundXXX_set_infty(linexprXXX[i+6]->cst->itv->sup,1);

    ap_linexprXXX_set(linexprXXX[i+8],linexprXXX[i+4]);
    ap_linexprXXX_ForeachLinterm0(linexprXXX[i+8],index,dim,eitv){
      if (i==0)
	boundXXX_set_infty(eitv->itv->sup,1);
      else
	boundXXX_set_infty(eitv->itv->neginf,1);
      break;
    }
    boundXXX_clear(bound);
  }
  for (i=0;i<10;i++){
    linconsXXX[i]->constyp = AP_CONS_SUPEQ;
    ap_linconsXXX_set(linconsXXX[i+10],linconsXXX[i]);
    linconsXXX[i+10]->constyp = AP_CONS_EQ;
    ap_linconsXXX_minimize(linconsXXX[i]);
  }
  for (i=0;i<LSIZE;i++){
    fprintf(stdout,"lincons[%d] \t= ",i);
    ap_linconsXXX_fprint(stdout,linconsXXX[i],0);
    fprintf(stdout,"\n");
  }
}
/* ********************************************************************** */
/* linexprXXX */
/* ********************************************************************** */

void test_linexprXXX(void)
{
  int i,j;
  ap_linexprXXX_t expr;

  ap_linexprXXX_init(expr,0);

  {
    ap_dim_t* tdim = malloc(6*sizeof(ap_dim_t));
    size_t k,size;

    for (i=0; i<10; i++){
      fprintf(stdout,"linexpr[%d] :\n\tsupport\t = ",i);
      size = ap_linexprXXX_support(linexprXXX[i],tdim);
      for (k=0;k<size;k++){
	fprintf(stdout,"%d,",tdim[k]);
      }
      fprintf(stdout,"\n\tsupportinterval\t = ");
      size = ap_linexprXXX_supportinterval(linexprXXX[i],tdim);
      for (k=0;k<size;k++){
	fprintf(stdout,"%d,",tdim[k]);
      }
      fprintf(stdout,"\n");

      bool bi1 = ap_linexprXXX_is_integer(linexprXXX[i],4);
      bool br1 = ap_linexprXXX_is_real(linexprXXX[i],4);
      bool bi2 = ap_linexprXXX_is_integer(linexprXXX[i],5);
      bool br2 = ap_linexprXXX_is_real(linexprXXX[i],5);
      bool lin = ap_linexprXXX_is_linear(linexprXXX[i]);
      bool quasilin = ap_linexprXXX_is_quasilinear(linexprXXX[i]);
      ap_linexpr_type_t typ = ap_linexprXXX_type(linexprXXX[i]);

      fprintf(stdout,"\tintdim=4: is_integer=%hhd, is_real=%hhd\n",bi1,br1);
      fprintf(stdout,"\tintdim=5: is_integer=%hhd, is_real=%hhd\n",bi2,br2);
      fprintf(stdout,"\tis_linear=%hhd, is_quasilinear=%hhd, typ=%d\n",lin,quasilin,typ);
    }
    free(tdim);
  }
  {
    ap_dimchange_t changeadd, changeremove;
    ap_dimperm_t perm;
    ap_dimension_t dim = ap_dimension_make(0,4);

    ap_dimchange_init(&changeadd,dim);
    changeadd.p[0]=1;
    changeadd.p[1]=2;
    changeadd.p[2]=2;
    changeadd.p[3]=4;
    ap_dimchange_init(&changeremove,dim);
    for (i=0;i<4; i++){
      changeremove.p[i] = changeadd.p[i];
    }
    ap_dimchange_add_invert(&changeremove);

    ap_dimperm_init(&perm,6);
    perm.p[0]=2;
    perm.p[1]=1;
    perm.p[2]=0;
    perm.p[3]=5;
    perm.p[4]=4;
    perm.p[5]=3;

    fprintf(stdout,"changeadd\t = ");
    ap_dimchange_fprint(stdout,&changeadd);
    fprintf(stdout,"\nchangeremove\t = ");
    ap_dimchange_fprint(stdout,&changeremove);
    fprintf(stdout,"\nperm\t = ");
    ap_dimperm_fprint(stdout,&perm);
    fprintf(stdout,"\n");

    for (i=0; i<2; i++){
      ap_linexprXXX_add_dimensions(expr,linexprXXX[i],&changeadd);
      fprintf(stdout,"add_dimensions linexprXXX[%d]\t = ",i);
      ap_linexprXXX_fprint(stdout,expr,0);
      fprintf(stdout,"\n");
      ap_linexprXXX_permute_dimensions(expr,linexprXXX[i],&perm);
      fprintf(stdout,"permute linexprXXX[%d]\t = ",i);
      ap_linexprXXX_fprint(stdout,expr,0);
      fprintf(stdout,"\n");
    }
    ap_dimchange_clear(&changeadd);
    ap_dimchange_clear(&changeremove);
    ap_dimperm_clear(&perm);
  }

  ap_linexprXXX_set(expr,linexprXXX[0]);
  ap_linexprXXX_set_zero(expr);
  fprintf(stdout,"set_zero linexpr[0] = ");
  ap_linexprXXX_fprint(stdout,expr,0);
  fprintf(stdout,"\n");

  for (i=0; i<10; i++){
    ap_linexprXXX_neg(expr,linexprXXX[i]);
    fprintf(stdout,"neg linexpr[%d] = ",i);
    ap_linexprXXX_fprint(stdout,expr,0);
    fprintf(stdout,"\n");
  }
  for (i=0; i<5; i++){
    ap_linexprXXX_add(expr,linexprXXX[2*i],linexprXXX[2*i+1],intern);

    fprintf(stdout,"add linexpr[%d] linexpr[%d] = ",2*i,2*i+1);
    ap_linexprXXX_fprint(stdout,expr,0);
    fprintf(stdout,"\n");
  }
  for (i=0; i<5; i++){
    ap_linexprXXX_sub(expr,linexprXXX[2*i],linexprXXX[2*i+1],intern);

    fprintf(stdout,"sub linexpr[%d] linexpr[%d] = ",2*i,2*i+1);
    ap_linexprXXX_fprint(stdout,expr,0);
    fprintf(stdout,"\n");
  }
  {
    eitvXXX_t eitv[8];
    for (j=0; j<8; j++) eitvXXX_init(eitv[j]);

    eitvXXX_set_val(intern,eitv[0],EITV_LINT,2L);
    eitvXXX_set_val(intern,eitv[1],EITV_LINT2,1L,2L);
    eitvXXX_set(eitv[2],eitv[1]);
    boundXXX_set_infty(eitv[2]->itv->sup,1);
    eitvXXX_set(eitv[3],eitv[1]);
    boundXXX_set_infty(eitv[3]->itv->neginf,1);
    for (j=0;j<4;j++) eitvXXX_neg(eitv[j+4],eitv[j]);

    for (i=0; i<10; i++){
      for (j=0; j<8;j++){
	ap_linexprXXX_scale(expr,linexprXXX[i],eitv[j],intern);
	fprintf(stdout,"scale linexpr[%d]\t ",i);
	eitvXXX_fprint(stdout,eitv[j]);
	fprintf(stdout,"\t = ");
	ap_linexprXXX_fprint(stdout,expr,0);
	fprintf(stdout,"\n");
      }
    }
    for (i=0; i<10; i++){
      for (j=0; j<8;j++){
	ap_linexprXXX_div(expr,linexprXXX[i],eitv[j],intern);
	fprintf(stdout,"div linexpr[%d]\t ",i);
	eitvXXX_fprint(stdout,eitv[j]);
	fprintf(stdout,"\t = ");
	ap_linexprXXX_fprint(stdout,expr,0);
	fprintf(stdout,"\n");
      }
    }
    for (j=0; j<8; j++) eitvXXX_clear(eitv[j]);
  }
  {
    eitvXXX_t eitv;
    eitvXXX_init(eitv);

    for (i=0; i<10; i++){
      for (j=0;j<2;j++){
	ap_linexprXXX_set(expr,linexprXXX[i]);
	ap_linexprXXX_quasilinearize(expr,envXXX[j],false,intern);
	fprintf(stdout,"quasilinearize linexpr[%d] env[%d]= ",i,j);
	ap_linexprXXX_fprint(stdout,expr,NULL);
	fprintf(stdout,"\n");

	ap_linexprXXX_set(expr,linexprXXX[i]);
	ap_linexprXXX_quasilinearize(expr,envXXX[j],true,intern);
	fprintf(stdout,"quasilinearize linexpr[%d] env[%d] for meet = ",i,j);
	ap_linexprXXX_fprint(stdout,expr,NULL);
	fprintf(stdout,"\n");

	ap_linexprXXX_eval(eitv,linexprXXX[i],envXXX[j],intern);
	fprintf(stdout,"eval linexpr[%d] env[%d]= ",i,j);
	eitvXXX_fprint(stdout,eitv);
	fprintf(stdout,"\n");
      }
    }
    eitvXXX_clear(eitv);
  }
  ap_linexprXXX_clear(expr);
}

/* ********************************************************************** */
/* linconsXXX */
/* ********************************************************************** */

void test_linconsXXX(void)
{
  int i,j;
  ap_linconsXXX_t cons;
  ap_linconsXXX_array_t array[2];
  ap_linconsXXX_array_t arrayt;

  ap_linconsXXX_init(cons,0);

  {
    ap_dim_t* tdim = malloc(6*sizeof(ap_dim_t));
    size_t k,size;

    for (i=0; i<20; i++){
      fprintf(stdout,"lincons[%d] :\n\tsupport\t = ",i);
      size = ap_linconsXXX_support(linconsXXX[i],tdim);
      for (k=0;k<size;k++){
	fprintf(stdout,"%d,",tdim[k]);
      }
      fprintf(stdout,"\n\tsupportinterval\t = ");
      size = ap_linconsXXX_supportinterval(linconsXXX[i],tdim);
      for (k=0;k<size;k++){
	fprintf(stdout,"%d,",tdim[k]);
      }
      fprintf(stdout,"\n");

      bool bi1 = ap_linconsXXX_is_integer(linconsXXX[i],4);
      bool br1 = ap_linconsXXX_is_real(linconsXXX[i],4);
      bool bi2 = ap_linconsXXX_is_integer(linconsXXX[i],5);
      bool br2 = ap_linconsXXX_is_real(linconsXXX[i],5);
      bool lin = ap_linconsXXX_is_linear(linconsXXX[i]);
      bool quasilin = ap_linconsXXX_is_quasilinear(linconsXXX[i]);
      ap_linexpr_type_t typ = ap_linconsXXX_type(linconsXXX[i]);
      bool sat = ap_linconsXXX_sat_is_false(linconsXXX[i],intern);
      fprintf(stdout,"\tintdim=4: is_integer=%hhd, is_real=%hhd\n",bi1,br1);
      fprintf(stdout,"\tintdim=5: is_integer=%hhd, is_real=%hhd\n",bi2,br2);
      fprintf(stdout,"\tis_linear=%hhd, is_quasilinear=%hhd, typ=%d\n",lin,quasilin,typ);
      fprintf(stdout,"\tsat_is_false=%hhd\n",sat);
    }
    free(tdim);
  }
  {
    ap_dimchange_t changeadd, changeremove;
    ap_dimperm_t perm;
    ap_dimension_t dim = ap_dimension_make(0,4);

    ap_dimchange_init(&changeadd,dim);
    changeadd.p[0]=1;
    changeadd.p[1]=2;
    changeadd.p[2]=2;
    changeadd.p[3]=4;
    ap_dimchange_init(&changeremove,dim);
    for (i=0;i<4; i++){
      changeremove.p[i] = changeadd.p[i];
    }
    ap_dimchange_add_invert(&changeremove);

    ap_dimperm_init(&perm,6);
    perm.p[0]=2;
    perm.p[1]=1;
    perm.p[2]=0;
    perm.p[3]=5;
    perm.p[4]=4;
    perm.p[5]=3;

    fprintf(stdout,"changeadd\t = ");
    ap_dimchange_fprint(stdout,&changeadd);
    fprintf(stdout,"\nchangeremove\t = ");
    ap_dimchange_fprint(stdout,&changeremove);
    fprintf(stdout,"\nperm\t = ");
    ap_dimperm_fprint(stdout,&perm);
    fprintf(stdout,"\n");

    for (i=0; i<2; i++){
      ap_linconsXXX_add_dimensions(cons,linconsXXX[i],&changeadd);
      fprintf(stdout,"add_dimensions linconsXXX[%d]\t = ",i);
      ap_linconsXXX_fprint(stdout,cons,0);
      fprintf(stdout,"\n");
      ap_linconsXXX_permute_dimensions(cons,linconsXXX[i],&perm);
      fprintf(stdout,"permute linconsXXX[%d]\t = ",i);
      ap_linconsXXX_fprint(stdout,cons,0);
      fprintf(stdout,"\n");
    }
    ap_dimchange_clear(&changeadd);
    ap_dimchange_clear(&changeremove);
    ap_dimperm_clear(&perm);
  }

  ap_linconsXXX_set(cons,linconsXXX[0]);
  ap_linconsXXX_set_zero(cons);
  fprintf(stdout,"set_zero lincons[0] = ");
  ap_linconsXXX_fprint(stdout,cons,0);
  fprintf(stdout,"\n");

  ap_linconsXXX_set(cons,linconsXXX[0]);
  ap_linconsXXX_set_bool(cons,false);
  fprintf(stdout,"set_bool lincons[0] false = ");
  ap_linconsXXX_fprint(stdout,cons,0);
  {
    tbool_t tb = ap_linconsXXX_evalcst(cons,intern);
    fprintf(stdout,"\t eval_cst = %d\n",tb);
  }
  ap_linconsXXX_set(cons,linconsXXX[0]);
  ap_linconsXXX_set_bool(cons,true);
  fprintf(stdout,"set_bool lincons[0] true = ");
  ap_linconsXXX_fprint(stdout,cons,0);
  {
    tbool_t tb = ap_linconsXXX_evalcst(cons,intern);
    fprintf(stdout,"\t eval_cst = %d\n",tb);
  }

  for (i=0;i<4;i++){
    for (j=0;j<2; j++){
      ap_linconsXXX_set(cons,linconsXXX[i+10*j]);
      ap_linconsXXX_reduce_integer(cons,4,intern);
      fprintf(stdout,"reduce_integer lincons[%d] 4 = ",i+10*j);
      ap_linconsXXX_fprint(stdout,cons,NULL);
      fprintf(stdout,"\n");
    }
  }

  {
    eitvXXX_t eitv;
    eitvXXX_init(eitv);
    for (i=0; i<10; i++){
      for (j=0;j<2;j++){
	ap_linconsXXX_set(cons,linconsXXX[i]);
	ap_linconsXXX_quasilinearize(cons,envXXX[j],false,intern);
	fprintf(stdout,"quasilinearize lincons[%d] env[%d] = ",i,j);
	ap_linconsXXX_fprint(stdout,cons,NULL);
	fprintf(stdout,"\n");

	ap_linconsXXX_set(cons,linconsXXX[i]);
	ap_linconsXXX_quasilinearize(cons,envXXX[j],true,intern);
	fprintf(stdout,"quasilinearize lincons[%d] env[%d] for meet = ",i,j);
	ap_linconsXXX_fprint(stdout,cons,NULL);
	fprintf(stdout,"\n");
      }
    }
    eitvXXX_clear(eitv);
  }

  /* ====================================================================== */
  /* linconsXXXX_array */
  /* ====================================================================== */

  ap_linconsXXX_array_init(array[0],22);
  ap_linconsXXX_set_bool(array[0]->p[0],true);
  for (i=0;i<20;i++){
    ap_linconsXXX_set(array[0]->p[i+1],linconsXXX[i]);
  }
  ap_linconsXXX_set_bool(array[0]->p[21],true);
  ap_linconsXXX_array_init_set(array[1],array[0]);
  ap_linconsXXX_set_bool(array[1]->p[21],false);

  ap_linconsXXX_array_init(arrayt,0);

  {
    ap_dim_t* tdim = malloc(6*sizeof(ap_dim_t));
    size_t k,size;

    size = ap_linconsXXX_array_support(array[0],tdim,6);
    for (k=0;k<size;k++){
      fprintf(stdout,"%d,",tdim[k]);
    }
    fprintf(stdout,"\n\tsupportinterval\t = ");
    size = ap_linconsXXX_array_supportinterval(array[0],tdim,6);
    for (k=0;k<size;k++){
      fprintf(stdout,"%d,",tdim[k]);
    }
    fprintf(stdout,"\n");

    bool lin = ap_linconsXXX_array_is_linear(array[0]);
    bool quasilin = ap_linconsXXX_array_is_quasilinear(array[0]);
    ap_linexpr_type_t typ = ap_linconsXXX_array_type(array[0]);
    fprintf(stdout,"\tis_linear=%hhd, is_quasilinear=%hhd, typ=%d\n",lin,quasilin,typ);
    free(tdim);
  }
  {
    ap_dimchange_t changeadd, changeremove;
    ap_dimperm_t perm;
    ap_dimension_t dim = ap_dimension_make(0,4);

    ap_dimchange_init(&changeadd,dim);
    changeadd.p[0]=1;
    changeadd.p[1]=2;
    changeadd.p[2]=2;
    changeadd.p[3]=4;
    ap_dimchange_init(&changeremove,dim);
    for (i=0;i<4; i++){
      changeremove.p[i] = changeadd.p[i];
    }
    ap_dimchange_add_invert(&changeremove);

    ap_dimperm_init(&perm,6);
    perm.p[0]=2;
    perm.p[1]=1;
    perm.p[2]=0;
    perm.p[3]=5;
    perm.p[4]=4;
    perm.p[5]=3;

    fprintf(stdout,"changeadd\t = ");
    ap_dimchange_fprint(stdout,&changeadd);
    fprintf(stdout,"\nchangeremove\t = ");
    ap_dimchange_fprint(stdout,&changeremove);
    fprintf(stdout,"\nperm\t = ");
    ap_dimperm_fprint(stdout,&perm);
    fprintf(stdout,"\n");

    for (i=0; i<2; i++){
      ap_linconsXXX_array_add_dimensions(arrayt,array[0],&changeadd);
      fprintf(stdout,"add_dimensions array[0] =\n");
      ap_linconsXXX_array_fprint(stdout,arrayt,0);
      ap_linconsXXX_array_permute_dimensions(arrayt,array[0],&perm);
      fprintf(stdout,"permute array[0] =\n");
      ap_linconsXXX_array_fprint(stdout,arrayt,0);
    }
    ap_dimchange_clear(&changeadd);
    ap_dimchange_clear(&changeremove);
    ap_dimperm_clear(&perm);
  }

  {
    int meet;
    for (i=0; i<2; i++){
      for (meet=0; meet<2; meet++){
	ap_linconsXXX_array_set(arrayt,array[i]);
	tbool_t tb = ap_linconsXXX_array_reduce(arrayt,meet,intern);
	fprintf(stdout,"array_reduce array[%d] meet=%d = %d\n",i,meet,tb);
	ap_linconsXXX_array_fprint(stdout,arrayt,0);
      }
    }
  }
  {
    int meet;
    for (i=0; i<2; i++){
      for (j=0;j<2;j++){
	for (meet=0;meet<2;meet++){
	  ap_linconsXXX_array_set(arrayt,array[i]);
	  bool b = ap_linconsXXX_array_quasilinearize(arrayt,envXXX[j],meet,intern);
	  fprintf(stdout,"quasilinearize array[%d] env[%d] meet=%d = %hhd\n",i,j,meet,b);
	  ap_linconsXXX_array_fprint(stdout,arrayt,NULL);
	  if (meet){
	    ap_linconsXXX_array_reduce_integer(arrayt,5,intern);
	    fprintf(stdout,"array_reduce_integer = \n");
	  }
	  else {
	    ap_linconsXXX_array_reduce(arrayt,meet,intern);
	    fprintf(stdout,"array_reduce = \n");
	  }
	  ap_linconsXXX_array_fprint(stdout,arrayt,NULL);
	  ap_linconsXXX_array_fprint(stdout,arrayt,NULL);
	  ap_linconsXXX_array_linearize(arrayt,meet,intern);
	  fprintf(stdout,"linearize = \n");
	  ap_linconsXXX_array_fprint(stdout,arrayt,NULL);
	}
      }
    }
  }

  ap_linconsXXX_clear(cons);
  ap_linconsXXX_array_clear(array[0]);
  ap_linconsXXX_array_clear(array[1]);
  ap_linconsXXX_array_clear(arrayt);
}
ENDMACRO

int main(void)
{
  fpu_init();
  /*  mpfr_set_default_prec(4046);*/
  mpfr_set_default_prec(53);
  num_internal_init(intern);

  output = stdout;
  init_set_linearMPQ();
  test_linexprMPQ();
  // test_linconsMPQ();
  clear_linearMPQ();

  num_internal_clear(intern);
  return 0;
}
