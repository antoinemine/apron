/* -*- mode: c -*- */

/* Testing expressions and cinstraints manipulation */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#include "eitv_all.h"
#include "num_conv.h"
MACRO_FOREACH XXX @AllNum
#include "ap_linconsXXX.h"
ENDMACRO


num_internal_t intern;
FILE* output=NULL;

/* ********************************************************************** */
/* FPU init */
/* ********************************************************************** */

/* simple run-time test that fpu behaves correctly */
static bool test_fpu(void)
{
  int i;
  long double d = 1., dd;
  /* find the minimal long double, as the fixpoint of x -> x/2 with rounding
     towards +oo;
     the max iteration value should be enough for 128-bit floating-point */
  for (i=0;i<5000000;i++) {
    dd = d;
    d /= 2;
    if (d==dd || d==0.) break;
  }
  /* fails if flush to 0 */
  if (d!=dd) { fprintf(stderr,"test_fpu failed test #1 after %i iterations\n",i); return false; }
  /* fails if long double rounding is not towards +oo */
  if (d*0.25!=dd) { fprintf(stderr,"test_fpu failed test #2\n"); return false; }
  /* fails if double rounding is not towards +oo */
  if ((double)d<dd) { fprintf(stderr,"test_fpu failed test #3\n"); return false; }
  /* fails if float rounding is not towards +oo */
  if ((float)d<dd) { fprintf(stderr,"test_fpu failed test #4\n"); return false; }
  return true;
}

#if defined(__ppc__)
static bool fpu_init(void)
{
  __asm volatile ("mtfsfi 7,2");
  return test_fpu();
}
#elif defined(__linux) || defined (__APPLE__)
#include <fenv.h>
static bool fpu_init(void)
{
  if (!fesetround(FE_UPWARD)) return test_fpu();
  fprintf(stderr,"could not set fpu rounding mode: fesetround failed\n");
  return false;
}
#elif defined(__FreeBSD__) || defined(sun)
#include <ieeefp.h>
static bool fpu_init(void)
{
  fpsetround(FP_RP);
  return test_fpu();
}
#else
static bool fpu_init(void)
{
  fprintf(stderr,"could not set fpu rounding mode: platform not supported\n");
  return false;
}

#endif

/* ********************************************************************** */
/* Testing normal ops */
/* ********************************************************************** */

void error(char* fmt, char* msg)
{
  fprintf(output,"error :");
  fprintf(output,fmt,msg);
  fprintf(output,"\n");
  abort();
}

#define LSIZE 20


MACRO_FOREACH XXX ("MPQ")
ap_linconsXXX_t linconsXXX[LSIZE];
ap_linexprXXX_ptr linexprXXX[LSIZE];
ap_linexprXXX_t envXXX[2];

void clear_linearXXX(void)
{
  int i;
  for (i=0; i<LSIZE; i++){
    ap_linconsXXX_clear(linconsXXX[i]);
  }
  for (i=0; i<2; i++){
    ap_linexprXXX_clear(envXXX[i]);
  }
}
void init_set_linearXXX(void)
{
  int i;
  size_t index;
  eitvXXX_ptr eitv;

  /* Create a number of linear expressions */
  for (i=0; i<2; i++){
    ap_linexprXXX_init(envXXX[i],10);
  }
  for (i=0; i<LSIZE; i++){
    ap_linconsXXX_init(linconsXXX[i],2);
    linexprXXX[i] = linconsXXX[i]->linexpr;
  }
  bool error = false;

  ap_linexprXXX_set_list0(intern,envXXX[0],&error,
			  AP_COEFF_LINT2,1L,2L,0,
			  AP_COEFF_LINT2,-2L,-1L,1,
			  AP_COEFF_LINT,3L,2,
			  AP_COEFF_LINT,0L,3,
			  AP_COEFF_LINT2,1L,2L,4,
			  AP_COEFF_LINT2,-1L,1L,5,
			  AP_END);
  assert(!error);
  ap_linexprXXX_set(envXXX[1],envXXX[0]);
  eitv = ap_linexprXXX_eitvref0(envXXX[1],0,false);
  boundXXX_set_infty(eitv->itv->sup,1);
  eitv = ap_linexprXXX_eitvref0(envXXX[1],1,false);
  boundXXX_set_infty(eitv->itv->neginf,1);
  eitv = ap_linexprXXX_eitvref0(envXXX[1],4,false);
  boundXXX_set_infty(eitv->itv->neginf,1);
  eitv = ap_linexprXXX_eitvref0(envXXX[1],5,false);
  boundXXX_set_infty(eitv->itv->sup,1);

  for (i=0;i<2;i++){
    ap_linexprXXX_minimize(envXXX[i]);
    fprintf(stdout,"env[%d] \t= ",i);
    ap_linexprXXX_fprint(stdout,envXXX[i],0);
    fprintf(stdout,"\n");
  }


  /*
     0: 2x1 + 3x2 - x4 + 3
     1: -4/3 x0 + 19/8 x2 - 3x5 - 4
     2: as 0 with interval constant obtained by enlarging
     3:
     4: as 2 with first coeff enlarged
     5:
     6: as 4 with neginf/sup constant bound set to infty
     7:
     8: as 4 with neginf/sup coeff bound set to infty
     9:
  */
  ap_linexprXXX_set_list0(intern,linexprXXX[0],&error,
			  AP_COEFF_LINT,2L,1,
			  AP_COEFF_LINT,3L,2,
			  AP_COEFF_LINT,-1L,4,
			  AP_CST_LINT,3L,
			  AP_END);
  assert(!error);
  ap_linexprXXX_set_list0(intern,linexprXXX[1],&error,
			  AP_COEFF_LFRAC,-4L,3L,0,
			  AP_COEFF_LFRAC,19L,8L,2,
			  AP_COEFF_LINT,-3L,5,
			  AP_CST_LINT,-4L,
			  AP_END);
  assert(!error);
  for (i=0; i<2; i++){
    ap_dim_t dim;
    boundXXX_t bound;
    boundXXX_init(bound);
    double k=0.5;
    boundXXX_set_numD(bound,&k,intern);

    ap_linexprXXX_set(linexprXXX[i+2],linexprXXX[i]);
    eitvXXX_enlarge_bound(linexprXXX[i+2]->cst,linexprXXX[i]->cst,bound);

    ap_linexprXXX_set(linexprXXX[i+4],linexprXXX[i+2]);
    ap_linexprXXX_ForeachLinterm0(linexprXXX[i+4],index,dim,eitv){
      eitvXXX_enlarge_bound(eitv,eitv,bound);
      break;
    }

    ap_linexprXXX_set(linexprXXX[i+6],linexprXXX[i+2]);
    if (i==0)
      boundXXX_set_infty(linexprXXX[i+6]->cst->itv->neginf,1);
    else
      boundXXX_set_infty(linexprXXX[i+6]->cst->itv->sup,1);

    ap_linexprXXX_set(linexprXXX[i+8],linexprXXX[i+4]);
    ap_linexprXXX_ForeachLinterm0(linexprXXX[i+8],index,dim,eitv){
      if (i==0)
	boundXXX_set_infty(eitv->itv->sup,1);
      else
	boundXXX_set_infty(eitv->itv->neginf,1);
      break;
    }
    boundXXX_clear(bound);
  }
  for (i=0;i<10;i++){
    linconsXXX[i]->constyp = AP_CONS_SUPEQ;
    ap_linconsXXX_set(linconsXXX[i+10],linconsXXX[i]);
    linconsXXX[i+10]->constyp = AP_CONS_EQ;
    ap_linconsXXX_minimize(linconsXXX[i]);
  }
  for (i=0;i<LSIZE;i++){
    fprintf(stdout,"lincons[%d] \t= ",i);
    ap_linconsXXX_fprint(stdout,linconsXXX[i],0);
    fprintf(stdout,"\n");
  }
}
void test_linexprXXX(void)
{
  int i,j;
  ap_linexprXXX_t expr;

  ap_linexprXXX_init(expr,0);
  for (i=0; i<10; i++){
    ap_linexprXXX_neg(expr,linexprXXX[i]);

    fprintf(stdout,"neg linexpr[%d] = ",i);
    ap_linexprXXX_fprint(stdout,expr,0);
    fprintf(stdout,"\n");
  }
  for (i=0; i<5; i++){
    ap_linexprXXX_add(expr,linexprXXX[2*i],linexprXXX[2*i+1],intern);

    fprintf(stdout,"add linexpr[%d] linexpr[%d] = ",2*i,2*i+1);
    ap_linexprXXX_fprint(stdout,expr,0);
    fprintf(stdout,"\n");
  }
  for (i=0; i<5; i++){
    ap_linexprXXX_sub(expr,linexprXXX[2*i],linexprXXX[2*i+1],intern);

    fprintf(stdout,"sub linexpr[%d] linexpr[%d] = ",2*i,2*i+1);
    ap_linexprXXX_fprint(stdout,expr,0);
    fprintf(stdout,"\n");
  }
  {
    eitvXXX_t eitv[8];
    for (j=0; j<8; j++) eitvXXX_init(eitv[j]);

    eitvXXX_set_val(intern,eitv[0],EITV_LINT,2L);
    eitvXXX_set_val(intern,eitv[1],EITV_LINT2,1L,2L);
    eitvXXX_set(eitv[2],eitv[1]);
    boundXXX_set_infty(eitv[2]->itv->sup,1);
    eitvXXX_set(eitv[3],eitv[1]);
    boundXXX_set_infty(eitv[3]->itv->neginf,1);
    for (j=0;j<4;j++) eitvXXX_neg(eitv[j+4],eitv[j]);

    for (i=0; i<10; i++){
      for (j=0; j<8;j++){
	ap_linexprXXX_scale(expr,linexprXXX[i],eitv[j],intern);
	fprintf(stdout,"scale linexpr[%d]\t ",i);
	eitvXXX_fprint(stdout,eitv[j]);
	fprintf(stdout,"\t = ");
	ap_linexprXXX_fprint(stdout,expr,0);
	fprintf(stdout,"\n");
      }
    }
    for (i=0; i<10; i++){
      for (j=0; j<8;j++){
	ap_linexprXXX_div(expr,linexprXXX[i],eitv[j],intern);
	fprintf(stdout,"div linexpr[%d]\t ",i);
	eitvXXX_fprint(stdout,eitv[j]);
	fprintf(stdout,"\t = ");
	ap_linexprXXX_fprint(stdout,expr,0);
	fprintf(stdout,"\n");
      }
    }
    for (j=0; j<8; j++) eitvXXX_clear(eitv[j]);
  }
  {
    eitvXXX_t eitv;
    eitvXXX_init(eitv);

    for (j=0;j<2;j++){
      for (i=0; i<10; i++){
        ap_linexprXXX_set(expr,linexprXXX[i]);
	ap_linexprXXX_quasilinearize(expr,envXXX[j],false,intern);
	fprintf(stdout,"quasilinearize linexpr[%d] env[%d]= ",i,j);
	ap_linexprXXX_fprint(stdout,expr,NULL);
	fprintf(stdout,"\n");

        ap_linexprXXX_set(expr,linexprXXX[i]);
	ap_linexprXXX_quasilinearize(expr,envXXX[j],true,intern);
	fprintf(stdout,"quasilinearize linexpr[%d] env[%d] for meet = ",i,j);
	ap_linexprXXX_fprint(stdout,expr,NULL);
	fprintf(stdout,"\n");

	ap_linexprXXX_eval(eitv,linexprXXX[i],envXXX[j],intern);
	fprintf(stdout,"eval linexpr[%d] env[%d]= ",i,j);
	eitvXXX_fprint(stdout,eitv);
	fprintf(stdout,"\n");
      }
    }
    eitvXXX_clear(eitv);
  }

  ap_linexprXXX_clear(expr);
}

ENDMACRO

int main(void)
{
  fpu_init();
  /*  mpfr_set_default_prec(4046);*/
  mpfr_set_default_prec(53);
  num_internal_init(intern);

  output = stdout;
  init_set_linearMPQ();
  test_linexprMPQ();
  clear_linearMPQ();

  num_internal_clear(intern);
  return 0;
}
