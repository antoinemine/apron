/* -*- mode: c -*- */

PERLEVAL @PolkaNum = split(" ",$ENV{POLKA_NUMTYPES})

/* This file is part of the APRON Library, released under LGPL license.  Please
   read the COPYING file packaged in the distribution */

quote(C,"#include \"pk.h\"")
quote(C,"#include \"apron_caml.h\"")

import "manager.idl";
import "common.idl";

enum pk_kind_t {
  PK_LOOSE,
  PK_STRICT,
  PK_EQUALITIES
};

struct pk_option_t {
  unsigned int max_coeff_size;
  unsigned int approximate_max_coeff_size;
  boolean expand_lazy;
  boolean forget_lazy;
  boolean remove_dimensions_lazy;
  boolean op_lazy;
  boolean strong_normalization;
  boolean widening_affine;
};

quote(MLMLI,"(** Convex Polyhedra and Linear Equalities abstract domains *)")

quote(MLMLI,"\n\
type loose\n\
type strict\n\
  (** Three flavors for convex polyhedra: loose, strict, or equalities only\n\
\n\
      Loose polyhedra cannot have strict inequality constraints like [x>0].\n\
      They are algorithmically more efficient\n\
      (less generators, simpler normalization).\n\
\n\
      Convex polyhedra are defined by the conjunction of a set of linear\n\
      constraints of the form [a_0*x_0 + ... + a_n*x_n + b >= 0] or\n\
      [a_0*x_0 + ... + a_n*x_n + b > 0]\n\
      where [a_0, ..., a_n, b, c] are constants and [x_0, ..., x_n] variables.\n\
  *)\n\
type equalities\n\
  (** Linear equalities.\n\
\n\
      Linear equalities are conjunctions of linear\n\
      equalities of the form [a_0*x_0 + ... + a_n*x_n + b = 0].\n\
  *)\n\
")
quote(MLI,"\
type 'a pk_type\n\
val loose : loose pk_type\n\
val strict : loose pk_type\n\
val equalities : equalities pk_type\n\
\n\
val pk_type_of_kind : pk_kind -> 'a pk_type\n\
val pk_kind_of_type : 'a pk_type -> pk_kind\n\
val string_of_pk_kind : pk_kind -> string\n\
val string_of_pk_type : 'a pk_type -> string\n\
")
quote(ML,"\
type 'a pk_type = pk_kind\n\
let loose = PK_LOOSE\n\
let strict = PK_STRICT\n\
let equalities = PK_EQUALITIES\n\
let pk_type_of_kind = fun x -> x\n\
let pk_kind_of_type = fun x -> x\n\
let string_of_pk_kind = function\n\
| PK_LOOSE -> \"LOOSE\"\n\
| PK_STRICT -> \"STRICT\"\n\
| PK_EQUALITIES -> \"EQUALITIES\"\n\
let string_of_pk_type = string_of_pk_kind\n\
")

quote(MLMLI,"\n\
type ('a,'b) t\n\
(** Type of convex polyhedra/linear equalities, where ['a] is [loose], [strict] or [equalities],\n\
    and ['b] is either [Common.numMPQ] or [Common.numRll] (unsafe).\n\
\n\
    Abstract values which are convex polyhedra have the type\n\
    [((loose,Common.numMPQ) t) Apron.Abstract0.t] or [((loose,Common.numMPQ) t) Apron.Abstract1.t] or\n\
    [((strict,Common.numMPQ) t) Apron.Abstract0.t] or [((strict,Common.numMPQ) t) Apron.Abstract1.t].\n\
\n\
    Abstract values which are conjunction of linear equalities have the type\n\
    [((equalities,Common.numMPQ)) t Apron.Abstract0.t] or [((equalities,Common.numMPQ) t) Apron.Abstract1.t].\n\
\n\
    Managers allocated by NewPolka have the type [('a,'b) t Apron.Manager.t].\n\
*)\n\
")

quote(MLI,"(** {2 Create a Polka manager} *)")

quote(C,"\n\
value camlidl_pk_manager_alloc(value _v_kind,value _v_num_discr)\n\
{\n\
  pk_kind_t kind = Int_val(_v_kind);\n\
  num_discr_t discr = Int_val(_v_num_discr);\n\
  ap_manager_t* man = pk_manager_alloc(kind,discr);\n\
  if (man==NULL){\n\
    caml_failwith(\"Num type not available\");\n\
  }\n\
  ap_exc_t i;\n\
  for (i=1; i<AP_EXC_SIZE; i++){\n\
    ap_manager_set_abort_if_exception(man,i,false);\n\
  }\n\
  value v = camlidl_apron_manager_ptr_c2ml(&man);\n\
  return v;\n\
}\n\
")
quote(MLMLI,"\n\
external manager_alloc : 'a pk_type -> 'b Common.num_type -> ('a,'b) t Manager.t = \"camlidl_pk_manager_alloc\"\n\
")

quote(MLMLI,"\n\
(** {2 Options. See the C documentation} *)\n\
")
[ref]struct pk_option_t* pk_manager_get_option(ap_manager_ptr man)
quote(call,"_res = pk_manager_option_ref(man);");
void pk_manager_set_option(ap_manager_ptr man, struct pk_option_t opt)
quote(call,"{ pk_option_t* ref = pk_manager_option_ref(man); *ref = opt; }");

quote(MLI,"\n\
(** {2 Type conversions} *)\n\
\n\
val manager_is_polka : 'a Manager.t -> bool\n\
  (** Return [true] iff the argument manager is a polka manager *)\n\
val manager_is_polka_pk_type : 'a Manager.t -> 'b pk_type -> bool\n\
  (** Return [true] iff the argument manager is a polka manager of the given kind *)\n\
val manager_is_polka_num_type : 'a Manager.t -> 'b Common.num_type -> bool\n\
  (** Return [true] iff the argument manager is a polka manager with the given number representation *)\n\
\n\
val manager_of_polka : ('a,'b) t Manager.t -> 'c Manager.t\n\
  (** Makes a polka manager generic *)\n\
\n\
val manager_to_polka : 'a Manager.t -> ('b,'c) t Manager.t\n\
val manager_to_polka_pk_type : 'a Manager.t -> 'b pk_type -> ('b,'c) t Manager.t\n\
val manager_to_polka_num_type : 'a Manager.t -> 'c Common.num_type -> ('b,'c) t Manager.t\n\
  (** Instanciate the type of a polka manager.\n\
      Raises [Failure] if the argument manager is not a right manager *)\n\
")


MACRO_FOREACH NNN ("0","1")
quote(MLI,"\n\
module AbstractNNN : sig\n\
  val is_polka : 'a AbstractNNN.t -> bool\n\
    (** Return [true] iff the argument value is a polka value *)\n\
  val is_polka_pk_type : 'a AbstractNNN.t -> 'b pk_type -> bool\n\
  (** Return [true] iff the argument value is a polka value of the given kind *)\n\
  val is_polka_num_type : 'a AbstractNNN.t -> 'b Common.num_type -> bool\n\
  (** Return [true] iff the argument value is a polka value with the given num type *)\n\
  val of_polka : ('a,'b) t AbstractNNN.t -> 'c AbstractNNN.t\n\
    (** Makes a polka value generic *)\n\
\n\
  val to_polka : 'a AbstractNNN.t -> ('b,'c) t AbstractNNN.t\n\
  val polka_to_pk_type : 'a AbstractNNN.t -> 'b pk_type -> ('b,'c) t AbstractNNN.t\n\
  val polka_to_num_type : 'a AbstractNNN.t -> 'c Common.num_type -> ('b,'c) t AbstractNNN.t\n\
    (** Instanciate the type of a polka value.\n\
	Raises [Failure] if the argument value is not a right value *)\n\
end\n\
")
ENDMACRO

quote(ML,"\n\
let regexp_polka = Str.regexp \"polka\"\n\
let manager_is_polka man =\n\
  let str = Manager.get_library man in\n\
  Str.string_match regexp_polka str 0\n\
let manager_of_polka (man:('a,'b) t Manager.t) : 'c Manager.t = Obj.magic man\n\
let manager_to_polka (man:'a Manager.t) : ('b,'c) t Manager.t =\n\
  if manager_is_polka man then\n\
    Obj.magic man\n\
  else\n\
    failwith \"Polka.to_polka: the argument manager is not a Polka manager\"\n\
let regexp_pk_type pk_type = Str.regexp (\"polka.*\"^(string_of_pk_type pk_type))\n\
let manager_is_polka_pk_type man pk_type=\n\
  let str = Manager.get_library man in\n\
  Str.string_match (regexp_pk_type pk_type) str 0\n     \
let regexp_num_type num_type = Str.regexp (\"polka.*num\"^(Common.string_of_num_type num_type))\n\
let manager_is_polka_num_type man num_type=\n\
  let str = Manager.get_library man in\n\
  Str.string_match (regexp_num_type num_type) str 0\n\
let manager_to_polka_pk_type man pk_type=\n\
  if manager_is_polka_pk_type man pk_type then\n\
    Obj.magic man\n\
  else\n\
    raise (Failure \"Polka.manager_polka_to_pk_type: the argument manager is not a Polka manager, nor not a Polka manager of the given kind\")\n\
let manager_to_polka_num_type man num_type=\n\
  if manager_is_polka_num_type man num_type then\n\
    Obj.magic man\n\
  else\n\
    raise (Failure \"Polka.manager_polka_to_num_type: the argument manager is not a Polka manager, nor not a Polka manager with the given num type\")\n\
")

MACRO_FOREACH NNN ("0","1")
quote(ML,"\n\
module AbstractNNN = struct\n\
  let is_polka abs =\n\
    manager_is_polka (AbstractNNN.manager abs)\n\
  let of_polka = Obj.magic\n\
  let to_polka abs =\n\
    if is_polka abs then\n\
      Obj.magic abs\n\
    else\n\
      raise (Failure \"Polka.Abstract0.to_polka: the argument value is not a Polka value\")\n\
  let is_polka_pk_type abs pk_type =\n\
    manager_is_polka_pk_type (AbstractNNN.manager abs) pk_type\n\
  let polka_to_pk_type abs pk_type =\n\
    if is_polka_pk_type abs pk_type then\n\
      Obj.magic abs\n\
    else\n\
      raise (Failure \"Polka.AbstractNNN.polka_to_pk_type: the argument value is not a pk_type Polka value\")\n\
  let is_polka_num_type abs num_type =\n\
    manager_is_polka_num_type (AbstractNNN.manager abs) num_type\n\
  let polka_to_num_type abs num_type =\n\
    if is_polka_num_type abs num_type then\n\
      Obj.magic abs\n\
    else\n\
      raise (Failure \"Polka.AbstractNNN.polka_to_num_type: the argument value is not a num_type Polka value\")\n\
end\n\
")
ENDMACRO
