/* -*- mode: c -*- */

PERLEVAL @BoxNum = split(" ",$ENV{BOX_NUMTYPES})

/* This file is part of the APRON Library, released under LGPL license.  Please
   read the COPYING file packaged in the distribution */

MACRO_FOREACH XXX @BoxNum
quote(C,"#include \"boxXXX.h\"")
ENDMACRO
quote(C,"#include \"apron_caml.h\"")

import "manager.idl";

struct box_option_t {
  unsigned int kmax;
};

quote(MLMLI,"(** Intervals abstract domain *)\n")

MACRO_FOREACH XXX @BoxNum
quote(MLMLI,"type numXXX = Common.numXXX")
ENDMACRO

quote(MLMLI,"\n\
type 'a t\n\
  (** Type of boxes, where ['a] is one of the [numXXX] types\n\
      above and indicates the underlying number representation.\n\
\n\
      Boxes constrains each dimension/variable [x_i] to belong to an interval\n\
      [I_i].\n\
\n\
      Abstract values which are boxes have the type ['a t Apron.AbstractX.t].\n\
\n\
      Managers allocated for boxes have the type ['a t Apron.manager.t].\n\
  *)\n\
")

quote(MLI,"(** {2 Create a Box manager} *)")
MACRO_FOREACH XXX @BoxNum
quote(C,"\n\
value camlidl_box_manager_alloc_numXXX(value vunit)\n\
{\n\
  ap_manager_t* man = boxXXX_manager_alloc();\n\
  ap_exc_t i;\n\
  for (i=1; i<AP_EXC_SIZE; i++){\n\
    ap_manager_set_abort_if_exception(man,i,false);\n\
  }\n\
  value v = camlidl_apron_manager_ptr_c2ml(&man);\n\
  return v;\n\
}\n\
")
quote(MLMLI,"\
external manager_alloc_numXXX : unit -> numXXX t Manager.t = \"camlidl_box_manager_alloc_numXXX\"\
")
ENDMACRO

[ref]struct box_option_t* box_manager_get_option(ap_manager_ptr man)
quote(call,"_res = box_manager_option_ref(man);");
void box_manager_set_option(ap_manager_ptr man, struct box_option_t opt)
quote(call,"{ box_option_t* ref = box_manager_option_ref(man); *ref = opt; }");

quote(MLI,"\n\
(** {2 Type conversions} *)\n\
\n\
val manager_is_box : 'a Manager.t -> bool\
")
MACRO_FOREACH XXX @BoxNum
quote(MLI,"val manager_is_box_numXXX : 'a Manager.t -> bool")
ENDMACRO
quote(MLI,"\
  (** Return [true] iff the argument manager is a box manager *)\n\
\n\
val manager_of_box : 'a t Manager.t -> 'b Manager.t\n\
  (** Makes a box manager generic *)\n\
\n\
val manager_to_box : 'a Manager.t -> 'b t  Manager.t\
")
MACRO_FOREACH XXX @BoxNum
quote(MLI,"val manager_box_to_numXXX : 'a t Manager.t -> numXXX t  Manager.t")
ENDMACRO
quote(MLI,"\
  (** Instanciate the type of a box manager.\n\
      Raises [Failure] if the argument manager is not a right manager *)\n\
")

MACRO_FOREACH NNN ("0","1")
quote(MLI,"\n\
module AbstractNNN : sig\n\
  val is_box : 'a AbstractNNN.t -> bool\
")
MACRO_FOREACH XXX @BoxNum
quote(MLI,"  val is_box_numXXX : 'a AbstractNNN.t -> bool")
ENDMACRO
quote(MLI,"\
    (** Return [true] iff the argument manager is a box manager *)\n\
\n\
  val of_box : 'a t AbstractNNN.t -> 'b AbstractNNN.t\n\
    (** Makes a box manager generic *)\n\
\n\
  val to_box : 'a AbstractNNN.t -> 'b t AbstractNNN.t\
")
MACRO_FOREACH XXX @BoxNum
quote(MLI,"  val box_to_numXXX : 'a t AbstractNNN.t -> numXXX t AbstractNNN.t")
ENDMACRO
quote(MLI,"\
    (** Instanciate the type of a box manager.\n\
	Raises [Failure] if the argument manager is not a right manager *)\n\
end\n\
")
ENDMACRO


quote(ML,"\n\
let regexp_box = Str.regexp \"box\"\n\
let manager_is_box man =\n\
  let str = Manager.get_library man in\n\
  Str.string_match regexp_box str 0\n\
let manager_of_box (man:'a t Manager.t) : 'b Manager.t = Obj.magic man\n\
let manager_to_box (man:'a Manager.t) : 'b t Manager.t =\n\
  if manager_is_box man then\n\
    Obj.magic man\n\
  else\n\
    failwith \"Box.to_box: the argument manager is not a Box manager\"\n\
")


MACRO_FOREACH XXX @BoxNum
quote(ML,"\n\
let regexp_numXXX = Str.regexp \"box.*numXXX\"\n\
let manager_is_box_numXXX man =\n\
  let str = Manager.get_library man in\n\
  Str.string_match regexp_numXXX str 0\n\
let manager_box_to_numXXX man =\n\
  if manager_is_box_numXXX man then\n\
    Obj.magic man\n\
  else\n\
    raise (Failure \"Box.manager_box_to_numXXX: the argument manager is not a numXXX Box manager\")\n\
")
ENDMACRO

MACRO_FOREACH NNN ("0","1")
quote(ML,"\n\
module AbstractNNN = struct\n\
  let is_box abs =\n\
    manager_is_box (AbstractNNN.manager abs)\n\
  let of_box = Obj.magic\n\
  let to_box abs =\n\
    if is_box abs then\n\
      Obj.magic abs\n\
    else\n\
      raise (Failure \"Box.Abstract0.to_box: the argument value is not a Box value\")\n\
")
MACRO_FOREACH XXX @BoxNum
quote(ML,"\n\
  let is_box_numXXX abs =\n\
    manager_is_box_numXXX (AbstractNNN.manager abs)\n\
  let box_to_numXXX abs =\n\
    if is_box_numXXX abs then\n\
      Obj.magic abs\n\
    else\n\
      raise (Failure \"Box.AbstractNNN.box_to_numXXX: the argument value is not a numXXX Box value\")\n\
")
ENDMACRO
quote(ML,"\n\
end\n\
")
ENDMACRO
