/* -*- mode: c -*- */

/* This file is part of the APRON Library, released under LGPL license.
   Please read the COPYING file packaged in the distribution  */

quote(MLI,"(** APRON tree expressions of level 0 *)\n")

quote(C, "#include \"apron_caml.h\"")

quote(C,"
value camlidl_apron_texpr0_to_expr_c2ml(ap_texpr0_t* expr)
{
  value _v_res;

  switch(expr->discr){
  case AP_TEXPR_CST:
    {
      value v0 = Val_unit;
      Begin_root(v0);
      v0 = camlidl_coeff_ptr_c2ml(&expr->val.cst);
      _v_res = caml_alloc_small(1,0);
       Field(_v_res,0) = v0;
      End_roots();
    }
    break;
  case AP_TEXPR_DIM:
    _v_res = caml_alloc_small(1,1);
    Field(_v_res,0) = Val_int(expr->val.dim);
    break;
  case AP_TEXPR_NODE:
    {
      value v0,v1,v2,v3,v4;
      v0 = v1 = v2 = v3 = v4 = Val_unit;
      Begin_roots5(v0,v1,v2,v3,v4);
      ap_texpr0_node_t* node = expr->val.node;
      v1 = camlidl_apron_texpr0_to_expr_c2ml(node->exprA);
      v3 = camlidl_apron_texpr_rtype_t_c2ml(&node->type);
      v4 = camlidl_apron_texpr_rdir_t_c2ml(&node->dir);
      if (ap_texpr_is_unop(node->op)){
	v0 = camlidl_apron_texpr_unop_t_c2ml(&node->op);
	_v_res = caml_alloc_small(4,2);
	Field(_v_res,0) = v0;
	Field(_v_res,1) = v1;
	Field(_v_res,2) = v3;
	Field(_v_res,3) = v4;
      }
      else {
	v0 = camlidl_apron_texpr_binop_t_c2ml(&node->op);
	v2 = camlidl_apron_texpr0_to_expr_c2ml(node->exprB);
	_v_res = caml_alloc_small(5,3);
	Field(_v_res,0) = v0;
	Field(_v_res,1) = v1;
	Field(_v_res,2) = v2;
	Field(_v_res,3) = v3;
	Field(_v_res,4) = v4;
      }
      End_roots();
    }
    break;
  default:
    abort();
  }
  return _v_res;
}
value camlidl_apron_texpr0_to_expr(value _v_texpr)
{
  CAMLparam1(_v_texpr);
  CAMLlocal1(_v_res);
  ap_texpr0_t* expr;

  camlidl_apron_texpr0_ptr_ml2c(_v_texpr,&expr);
  _v_res = camlidl_apron_texpr0_to_expr_c2ml(expr);
  CAMLreturn(_v_res);
}

void camlidl_apron_texpr0_of_expr_ml2c(value v, ap_texpr0_t** res)
{
  ap_texpr0_t* texpr;
  ap_texpr0_node_t* node;
  ap_coeff_t coeff;
  value v0,v1,v2,v3,v4;

  texpr = malloc(sizeof(ap_texpr0_t));\n \

  assert (Is_block(v));
  switch (Tag_val(v)){
  case 0: /* Constant */
    {
    ap_coeff_t coeff;
    assert(Wosize_val(v)==1);
    v0 = Field(v,0);
    texpr->discr = AP_TEXPR_CST;
    camlidl_coeff_ptr_ml2c(v0,&coeff);
    ap_coeff_init_set(texpr->val.cst,coeff);
    }
    break;
  case 1: /* Dimension */
    assert(Wosize_val(v)==1);
    v0 = Field(v,0);
    texpr->discr = AP_TEXPR_DIM;
    texpr->val.dim = Int_val(v0);
    break;
  case 2:  /* Unary node */
    v0 = Field(v,0);
    v1 = Field(v,1);
    v2 = Field(v,2);
    v3 = Field(v,3);

    node = malloc(sizeof(ap_texpr0_node_t));\n \
    camlidl_apron_texpr_unop_t_ml2c      (v0,&node->op);
    camlidl_apron_texpr0_of_expr_ml2c(v1,&node->exprA);\n \
    camlidl_apron_texpr_rtype_t_ml2c     (v2,&node->type);
    camlidl_apron_texpr_rdir_t_ml2c      (v3,&node->dir);
    node->exprB = NULL;
    texpr->discr = AP_TEXPR_NODE;
    texpr->val.node = node;
    break;
  case 3: /* Binary node */
    v0 = Field(v,0);
    v1 = Field(v,1);
    v2 = Field(v,2);
    v3 = Field(v,3);
    v4 = Field(v,4);
    node = malloc(sizeof(ap_texpr0_node_t));
    camlidl_apron_texpr_binop_t_ml2c     (v0,&node->op);
    camlidl_apron_texpr0_of_expr_ml2c(v1,&node->exprA);\n \
    camlidl_apron_texpr0_of_expr_ml2c(v2,&node->exprB);\n \
    camlidl_apron_texpr_rtype_t_ml2c     (v3,&node->type);
    camlidl_apron_texpr_rdir_t_ml2c      (v4,&node->dir);
    texpr->discr = AP_TEXPR_NODE;
    texpr->val.node = node;
    break;
  default:
    assert(false);
  }
  *res = texpr;
}
value camlidl_apron_texpr0_of_expr(value _v_expr)
{
  CAMLparam1(_v_expr);
  CAMLlocal1(_v_res);
  ap_texpr0_t* res;

  camlidl_apron_texpr0_of_expr_ml2c(_v_expr,&res);
  _v_res = camlidl_apron_texpr0_ptr_c2ml(&res);
  CAMLreturn(_v_res);
}
")

import "coeff.idl";
import "dim.idl";
import "linexpr0.idl";

typedef [abstract,
	 ml2c(camlidl_apron_texpr0_ptr_ml2c),
	 c2ml(camlidl_apron_texpr0_ptr_c2ml)]
struct ap_texpr0_t* ap_texpr0_ptr;
typedef [mltype("t array"),
	 abstract,
	 ml2c(camlidl_apron_texpr0_array_t_ml2c),
	 c2ml(camlidl_apron_texpr0_array_t_c2ml)]
struct ap_texpr0_array_t ap_texpr0_array_t;

typedef [mltype("\n  | Neg\n  | Cast\n  | Sqrt (** *)\n  (** Unary operators *)"),
	 ml2c(camlidl_apron_texpr_unop_t_ml2c),
	 c2ml(camlidl_apron_texpr_unop_t_c2ml)]
struct ap_texpr_op_t ap_texpr_unop_t;

typedef [mltype("\n  | Add\n  | Sub\n  | Mul\n  | Div\n  | Mod (** *)\n  (** Binary operators *)"),
	 ml2c(camlidl_apron_texpr_binop_t_ml2c),
	 c2ml(camlidl_apron_texpr_binop_t_c2ml)]
struct ap_texpr_op_t ap_texpr_binop_t;

typedef [mltype("\n  | Real\n  | Int\n  | Single\n  | Double\n  | Extended\n  | Quad (** *)\n  (** Destination type for rounding *)"),
	 ml2c(camlidl_apron_texpr_rtype_t_ml2c),
	 c2ml(camlidl_apron_texpr_rtype_t_c2ml)]
struct ap_texpr_rtype_t ap_texpr_rtype_t;

typedef [mltype("\n  | Near\n  | Zero\n  | Up\n  | Down\n  | Rnd (** *)\n  (** Rounding direction *)"),
	 ml2c(camlidl_apron_texpr_rdir_t_ml2c),
	 c2ml(camlidl_apron_texpr_rdir_t_c2ml)]
struct ap_texpr_rdir_t ap_texpr_rdir_t;

quote(MLMLI,"
(** User type for tree expressions *)
type 'a gexpr =
  | Cst of Coeff.f Coeff.tt
  | DimVar of 'a
  | Unop of unop * 'a gexpr * typ * round
  | Binop of binop * 'a gexpr * 'a gexpr * typ * round
type expr = Dim.t gexpr
")

quote(MLMLI,"\n(** {2 Printing} *)\n")

quote(MLI,"
val print : (Dim.t -> string) -> Format.formatter -> t -> unit
  (** Print an abstract tree expression, using a function converting from dimensions to names *)
val array_print :
  ?first:(unit,Format.formatter,unit) format ->
  ?sep:(unit,Format.formatter,unit) format ->
  ?last:(unit,Format.formatter,unit) format ->
  (Dim.t -> string) -> Format.formatter -> t array -> unit
  (** Same for arrays *)
val string_of_unop  : unop  -> string
val string_of_binop : binop -> string
val string_of_typ   : typ   -> string
val string_of_round : round -> string
val print_unop  :  Format.formatter -> unop  -> unit
val print_binop :  Format.formatter -> binop -> unit
val print_typ   :  Format.formatter -> typ   -> unit
val print_round :  Format.formatter -> round -> unit
val print_expr : (Dim.t -> string) -> Format.formatter -> expr -> unit
  (** Print a tree expression, using a function converting from dimensions to names *)
")

quote(MLI,"
(** {2 Expressions} *)

(** {3 Constructors and Destructor} *)
")
ap_texpr0_ptr ap_texpr0_copy(ap_texpr0_ptr a);
ap_texpr0_ptr ap_texpr0_of_linexpr0(ap_linexpr0_t e)
quote(call,"_res = ap_texpr0_from_linexpr0(e);");

quote(MLMLI,"
external of_expr : expr -> t = \"camlidl_apron_texpr0_of_expr\"
external to_expr : t -> expr = \"camlidl_apron_texpr0_to_expr\"
  (** (The most efficient way to build/inspect a tree expression) *)
")

quote(MLI,"\n(** {4 Incremental constructors} *)\n")
ap_texpr0_ptr ap_texpr0_cst(ap_coeff_tg coeff);
ap_texpr0_ptr ap_texpr0_dim(ap_dim_t dim);
ap_texpr0_ptr ap_texpr0_unop(ap_texpr_unop_t op,
			     ap_texpr0_ptr expr,
			     ap_texpr_rtype_t type, ap_texpr_rdir_t dir)
quote(call,"_res = ap_texpr0_unop(op,ap_texpr0_copy(expr),type,dir);");
ap_texpr0_ptr ap_texpr0_binop(ap_texpr_binop_t op,
			      ap_texpr_rtype_t type, ap_texpr_rdir_t dir,
			      ap_texpr0_ptr exprA, ap_texpr0_ptr exprB)
quote(call,"_res = ap_texpr0_binop(op,ap_texpr0_copy(exprA),ap_texpr0_copy(exprB),type,dir);");


quote(MLI,"\n(** {3 Tests} *)\n")

unsigned int ap_texpr0_depth(ap_texpr0_ptr a);
unsigned int ap_texpr0_size(ap_texpr0_ptr a);
ap_dim_t ap_texpr0_max_dim(ap_texpr0_ptr a);
boolean ap_texpr0_has_dim(ap_texpr0_ptr a, ap_dim_t d);

quote(MLMLI,"external support : t -> int array = \"camlidl_apron_texpr0_support\"")
quote(C,"
value camlidl_apron_texpr0_support(value _v_a)
{
  ap_texpr0_ptr a; /*in*/
  ap_dim_t* tdim; /*out*/
  unsigned int size; /*out*/
  mlsize_t _c1;
  value _v2;
  value _vres;

  struct camlidl_ctx_struct _ctxs = { CAMLIDL_TRANSIENT, NULL };
  camlidl_ctx _ctx = &_ctxs;
  camlidl_apron_texpr0_ptr_ml2c(_v_a, &a);
  size = ap_texpr0_max_dim(a);
  tdim = camlidl_malloc(size * sizeof(ap_dim_t), _ctx);
  size = ap_texpr0_support(a,tdim);
  _vres = camlidl_alloc(size, 0);
  Begin_root(_vres)
    for (_c1 = 0; _c1 < size; _c1++) {
      _v2 = camlidl_c2ml_dim_ap_dim_t(&tdim[_c1], _ctx);
      modify(&Field(_vres, _c1), _v2);
    }
  End_roots()
  camlidl_free(_ctx);
  return _vres;
}
")
boolean ap_texpr0_is_interval_cst(ap_texpr0_ptr a);
boolean ap_texpr0_is_interval_linear(ap_texpr0_ptr a);
boolean ap_texpr0_is_interval_polynomial(ap_texpr0_ptr a);
boolean ap_texpr0_is_interval_polyfrac(ap_texpr0_ptr a);
boolean ap_texpr0_is_scalar(ap_texpr0_ptr a);

quote(MLMLI,"\n(** {3 Operations} *)\n")

ap_texpr0_ptr ap_texpr0_substitute(ap_texpr0_ptr a, ap_dim_t dim, ap_texpr0_ptr b);
ap_texpr0_ptr ap_texpr0_add_dimensions(ap_texpr0_ptr expr,
				       [ref]ap_dimchange_t* dimchange);
ap_texpr0_ptr ap_texpr0_permute_dimensions(ap_texpr0_ptr expr,
					   [ref]struct ap_dimperm_t* dimperm);
void ap_texpr0_substitute_with(ap_texpr0_ptr a, ap_dim_t dim, ap_texpr0_ptr b);
void ap_texpr0_add_dimensions_with(ap_texpr0_ptr expr,
				   [ref]ap_dimchange_t* dimchange);
void ap_texpr0_permute_dimensions_with(ap_texpr0_ptr expr,
				       [ref]struct ap_dimperm_t* dimperm);

quote(MLI,"
(** {2 Arrays} *)

(** {3 Constructors and destructors} *)
val array_make : int -> t array
val array_length : t array -> int
");

ap_texpr0_array_t ap_texpr0_array_of_linexpr0_array(ap_linexpr0_array_t e)
quote(call,"_res = ap_texpr0_array_from_linexpr0_array(e);");

quote(MLI,"
(** {3 Operations} *)
val array_add_dimensions : t array -> Dim.change -> t array
val array_permute_dimensions : t array -> Dim.perm -> t array
val array_add_dimensions_with : t array -> Dim.change -> unit
val array_permute_dimensions_with : t array -> Dim.perm -> unit
")


quote(ML,"
let string_of_unop = function
| Neg -> \"Neg\"
| Cast -> \"Cast\"
| Sqrt -> \"Sqrt\"
let string_of_binop = function
| Add -> \"Add\"
| Sub -> \"Sub\"
| Mul -> \"Mul\"
| Div -> \"Div\"
| Mod -> \"Mod\"
let string_of_typ = function
| Real -> \"Real\"
| Int -> \"Int\"
| Single -> \"Single\"
| Double -> \"Double\"
| Extended -> \"Extended\"
| Quad-> \"Quad\"
let string_of_round = function
| Near -> \"Near\"
| Zero -> \"Zero\"
| Up -> \"Up\"
| Down -> \"Down\"
| Rnd -> \"Rnd\"
let print_typ fmt x = Format.pp_print_string fmt (string_of_typ x)
let print_round fmt x = Format.pp_print_string fmt (string_of_round x)
let print_unop fmt x = Format.pp_print_string fmt (string_of_unop x)
let print_binop fmt x = Format.pp_print_string fmt (string_of_binop x)


let print_string_of_unop = function
  | Neg -> \"-\"
  | Cast -> \"cast\"
  | Sqrt -> \"sqrt\"
let print_string_of_binop = function
  | Add -> \"+\"
  | Sub -> \"-\"
  | Mul -> \"*\"
  | Div -> \"/\"
  | Mod -> \"%\"
let print_string_of_typ = function
  | Real -> \"\"
  | Int -> \"i\"
  | Single -> \"f\"
  | Double -> \"d\"
  | Extended -> \"l\"
  | Quad-> \"q\"
let print_string_of_round = function
  | Near -> \"n\"
  | Zero -> \"0\"
  | Up -> \"+oo\"
  | Down -> \"-oo\"
  | Rnd -> \"?\"
let print_sprint_unop op typ round =
  if op=Neg then
    Format.sprintf \"%s\" (print_string_of_unop op)
  else begin
    if typ=Real then
      Format.sprintf \"%s \" (print_string_of_unop op)
    else
      Format.sprintf \"%s_%s,%s \" (print_string_of_unop op)
	(print_string_of_typ typ) (print_string_of_round round)
  end
let print_sprint_binop op typ round =
  if typ=Real then
    Format.sprintf \"%s\" (print_string_of_binop op)
  else
    Format.sprintf \"%s_%s,%s\" (print_string_of_binop op)
	(print_string_of_typ typ) (print_string_of_round round)
let print_precedence_of_unop = function
  | Neg -> 3
  | Cast | Sqrt -> 4
let print_precedence_of_binop = function
  | Add | Sub -> 1
  | Mul | Div | Mod -> 2


let rec print_gexpr (string_of_a:'a -> string) fmt (expr:'a gexpr) =\n  \
  let precedence_of_expr = function
    | Cst _
    | DimVar _ -> 5
    | Unop(op,_,_,_) -> print_precedence_of_unop op
    | Binop(op,_,_,_,_) -> print_precedence_of_binop op
  in
  match expr with
  | Cst x -> Coeff.print fmt x
  | DimVar x -> Format.pp_print_string fmt (string_of_a x)
  | Unop(op,e,typ,round) ->
      let prec = print_precedence_of_unop op in
      let prec1 = precedence_of_expr e in
      let par = prec1<=prec in
      Format.fprintf fmt \"%s%s%a%s\"
	(print_sprint_unop op typ round)
	(if par then \"(\" else \"\")
	(print_gexpr string_of_a) e
	(if par then \")\" else \"\")
  | Binop(op,e1,e2,typ,round) ->
      let prec = print_precedence_of_binop op in
      let prec1 = precedence_of_expr e1 in
      let prec2 = precedence_of_expr e2 in
      let par1 = prec1<prec in
      let par2 = prec2<=prec in
      Format.fprintf fmt \"%s%a%s %s %s%a%s\"
	(if par1 then \"(\" else \"\")
	(print_gexpr string_of_a) e1
	(if par1 then \")\" else \"\")
	(print_sprint_binop op typ round)
	(if par2 then \"(\" else \"\")
	(print_gexpr string_of_a) e2
	(if par2 then \")\" else \"\")

let print_expr = print_gexpr
let print string_of_dim fmt t = print_expr string_of_dim fmt (to_expr t)
let array_print ?first ?sep ?last string_of_dim fmt tab =
  Common.array_print ?first ?sep ?last (print string_of_dim) fmt tab
let array_make length = Array.make length (cst (Coeff.init_set_int (Common.D(0))))
let array_length = Array.length
let array_add_dimensions x y = Array.map (fun x -> add_dimensions x y) x
let array_permute_dimensions x y = Array.map (fun x -> permute_dimensions x y) x
let array_add_dimensions_with x y = Array.iter (fun x -> add_dimensions_with x y) x
let array_permute_dimensions_with x y = Array.iter (fun x -> permute_dimensions_with x y) x
let rec map_gexpr f = function
| Cst x -> Cst x
| DimVar x -> DimVar(f x)
| Unop(op,e,typ,round) ->
    Unop(op,(map_gexpr f e),typ,round)
| Binop(op,e1,e2,typ,round) ->
    Binop(op,(map_gexpr f e1),(map_gexpr f e2),typ,round)
")

quote(MLI,"(** {2 Internal usage for level 1} *)")

quote(MLI,"
val print_sprint_unop : unop -> typ -> round -> string
val print_sprint_binop : binop -> typ -> round -> string
val print_precedence_of_unop : unop -> int
val print_precedence_of_binop : binop -> int
val print_gexpr : ('a -> string) -> Format.formatter -> 'a gexpr -> unit
val map_gexpr : ('a -> 'b) -> 'a gexpr -> 'b gexpr
")
