/* -*- mode: c -*- */

/* This file is part of the APRON library, released under LGPL license.
   Please read the COPYING file packaged in the distribution  */

quote(C, "\n\
#include \"apron_caml.h\"\n\
#include \"ap_linyyyXXX.h\"\n\
")

import "mpz.idl";
import "mpq.idl";
import "mpfr.idl";
import "num_internal.idl";
import "numXXX.idl";
import "boundXXX.idl";
import "eitvXXX.idl";

#define _AP_yyy_MARK_

#if !defined(_AP_expr_MARK_)
import "linexprXXX.idl";
#endif

typedef [abstract,c2ml(camlidl_apron_linyyyXXX_ptr_c2ml),ml2c(camlidl_apron_linyyyXXX_ptr_ml2c)] struct ap_linyyyXXX_struct* ap_linyyyXXX_ptr;
typedef [abstract,c2ml(camlidl_apron_linyyyXXX_array_ptr_c2ml),ml2c(camlidl_apron_linyyyXXX_array_ptr_ml2c)] struct ap_linyyyXXX_array_struct* ap_linyyyXXX_array_ptr;

#if defined(_AP_expr_MARK_)
quote(MLMLI,"(** (Interval) linear expressions *)\n\n")
#elif defined(_AP_cons_MARK_)
quote(MLMLI,"(** (Interval) linear constraints *)\n\n")
#elif defined(_AP_expr_MARK_)
quote(MLMLI,"(** Linear generators *)\n\n")
#endif

/* OUTOUTOUT is a reserved variable name ! (see Makefile and sedscript_c) */

quote(MLMLI,"\n(** {2 Single object} *)\n")

quote(MLI,"\n(** {3 Pretty printing} *)\n")
quote(MLI,"val print : Format.formatter -> 'a tt -> unit")

quote(MLMLI,"\n(** {3 Initialization and Assignement Functions} *)")

void ap_linyyyXXX_init([out]ap_linyyyXXX_ptr OUTOUTOUT, unsigned int size);
void ap_linyyyXXX_init_set([out]ap_linyyyXXX_ptr OUTOUTOUT, ap_linyyyXXX_ptr a);
void ap_linyyyXXX_set(ap_linyyyXXX_ptr res, ap_linyyyXXX_ptr a);
void ap_linyyyXXX_resize(ap_linyyyXXX_ptr a, unsigned int size);
void ap_linyyyXXX_resize_strict(ap_linyyyXXX_ptr a, unsigned int size);
void ap_linyyyXXX_minimize(ap_linyyyXXX_ptr e);
#if defined(_AP_cons_MARK_)
void ap_linconsXXX_set_bool(ap_linconsXXX_ptr lincons, boolean value);
#endif

quote(MLMLI,"\n(** {3 Tests and Simplifications} *)")

boolean ap_linyyyXXX_is_integer(ap_linyyyXXX_ptr a, unsigned int intdim);
boolean ap_linyyyXXX_is_real(ap_linyyyXXX_ptr a, unsigned int intdim);

boolean ap_linyyyXXX_is_linear(ap_linyyyXXX_ptr a);
boolean ap_linyyyXXX_is_quasilinear(ap_linyyyXXX_ptr a);
ap_linexpr_type_t ap_linyyyXXX_type(ap_linyyyXXX_ptr a);

void ap_linyyyXXX__supportinterval(ap_linyyyXXX_ptr a, [out,size_is(size)]ap_dim_t* tdim, [out]int size)
  quote(call,"
unsigned int effsize = ap_linyyyXXX_size(a);
tdim = malloc(effsize*sizeof(ap_dim_t));
size = ap_linyyyXXX_supportinterval(a,tdim);
")
  quote(dealloc,"free(tdim);");

quote(MLI,"val supportinterval : t -> int array")
quote(ML,"let supportinterval = fst (_supportinterval a)")

quote(MLMLI,"\n(** {3 Access} *)")

unsigned int ap_linyyyXXX_size(ap_linyyyXXX_ptr a);
void ap_linyyyXXX_get_cst(eitvXXX_ptrm eitv, ap_linyyyXXX_ptr a);
void ap_linyyyXXX_get_eitv0(eitvXXX_ptrm eitv, ap_linyyyXXX_ptr a, ap_dim_t dim);
void ap_linyyyXXX_get_eitv1(eitvXXX_ptrm eitv, ap_linyyyXXX_ptr a, ap_environment_ptr env, ap_var_ptr var)
  quote(call,"
bool error;
ap_linyyyXXX_get_eitv1(eitv, &error, a, env, var);
if (error){
  caml_invalid_argument(\"unknown variable in the environment\");
}
");

void ap_linyyyXXX_set_cst(ap_linyyyXXX_ptr a, eitvXXX_ptrg eitv);
void ap_linyyyXXX_set_eitv0(ap_linyyyXXX_ptr a, ap_dim_t dim, eitvXXX_ptrg eitv);
void ap_linyyyXXX_set_eitv1(ap_linyyyXXX_ptr a, ap_environment_ptr env, ap_var_ptr var, eitvXXX_ptrg eitv)
  quote(call,"
bool error;
ap_linyyyXXX_set_eitv1(a,&error,env,var,eitv);
if (error){
  caml_invalid_argument(\"unknown variable in the environment\");
}
");

/* Iterator (Macro): use:
   ap_linexprXXX_ForeachLinterm(ap_linexprXXX_ptr e, unsigned int i, ap_dim_t d, eitvXXX_ptr eitv){
     ..
   }
   where
   - e is the inspected expression (of type ap_linexprXXX_t)
   - i is the internal iterator (of type unsigned int or int)
   - dim is the dimension of one linear term (of type ap_dim_t)
   - peitv is a pointer to the corresponding interval (of type eitvXXX_ptr)

*/
/*
#define ap_linexprXXX_ForeachLinterm0(_p_e, _p_i, _p_d, _p_eitv)	\
  for ((_p_i)=0;							\
       (_p_i)<(_p_e)->effsize ?						\
	 (((_p_d) = (_p_e)->linterm[_p_i]->dim),			\
	  ((_p_eitv) = (_p_e)->linterm[_p_i]->eitv),			\
	  true) :                                                       \
	 false;								\
       (_p_i)++)
#define ap_linexprXXX_ForeachLinterm1(_p_e, _p_env, _p_i, _p_v, _p_eitv) \
  for ((_p_i)=0;							\
       (_p_i)<(_p_e)->effsize ?						\
	 (((_p_v) = ap_environment_var_of_dim((_p_e)->linterm[_p_i]->dim)), \
	  ((_p_eitv) = (_p_e)->linterm[_p_i]->eitv),			\
	  true) :                                                       \
	 false;								\
       (_p_i)++)
*/

/* ====================================================================== */
/* I.5. Change of dimensions and permutations */
/* ====================================================================== */

/* These two functions add dimensions to the expressions, following the
   semantics of dimchange (see the type definition of dimchange).  */
cinline
void ap_linyyyXXX_add_dimensions(ap_linyyyXXX_ptr res,
				ap_linyyyXXX_ptr a,
				ap_dimchange_t* dimchange);

/* These two functions apply the given permutation to the dimensions.
   The dimensions present in the generator should just be less
   than the size of the permutation. */
cinline
void ap_linyyyXXX_permute_dimensions(ap_linyyyXXX_ptr res,
				    ap_linyyyXXX_ptr a,
				    ap_dimperm_t* perm);
cinline
void ap_linyyyXXX_extend_environment(ap_linyyyXXX_ptr res,
				      boolean* perror,
				      ap_environment_t* nenv,
				      ap_linyyyXXX_ptr a,
				      ap_environment_t* env);

/* ====================================================================== */
/* I.6 Hashing, comparison */
/* ====================================================================== */

int ap_linyyyXXX_hash(ap_linyyyXXX_ptr a);
boolean ap_linyyyXXX_equal(ap_linyyyXXX_ptr a1,ap_linyyyXXX_ptr a2);

/* Lexicographic ordering, terminating by constant coefficients */
int ap_linyyyXXX_cmp(ap_linyyyXXX_ptr a1, ap_linyyyXXX_ptr a2);

/* ********************************************************************** */
/* II. ap_linyyyXXX_array_t */
/* ********************************************************************** */

/* ====================================================================== */
/* II.1 Constructor and Destructor */
/* ====================================================================== */

void ap_linyyyXXX_array_init(ap_linyyyXXX_array_t array, unsigned int size);
void ap_linyyyXXX_array_init_set(ap_linyyyXXX_array_t res, ap_linyyyXXX_array_t array);
void ap_linyyyXXX_array_set(ap_linyyyXXX_array_t res, ap_linyyyXXX_array_t array);
void ap_linyyyXXX_array_resize(ap_linyyyXXX_array_t array, unsigned int size);
void ap_linyyyXXX_array_minimize(ap_linyyyXXX_array_t array);
void ap_linyyyXXX_array_clear(ap_linyyyXXX_array_t array);

ap_linyyyXXX_array_ptr ap_linyyyXXX_array_alloc(unsigned int size);
ap_linyyyXXX_array_ptr ap_linyyyXXX_array_alloc_set(ap_linyyyXXX_array_t a);
void ap_linyyyXXX_array_free(ap_linyyyXXX_array_ptr array);

void ap_linyyyXXX_array_fprint(FILE* stream, ap_linyyyXXX_array_t array, char** name);
void ap_linyyyXXX_array_print(ap_linyyyXXX_array_t array, char** name);

/* ====================================================================== */
/* II.2 Tests and Simplifications */
/* ====================================================================== */

boolean ap_linyyyXXX_array_is_linear(ap_linyyyXXX_array_t array);
boolean ap_linyyyXXX_array_is_quasilinear(ap_linyyyXXX_array_t array);
ap_linexpr_type_t ap_linyyyXXX_array_type(ap_linyyyXXX_array_t array);

unsigned int ap_linyyyXXX_array_supportinterval(ap_linyyyXXX_array_t array, ap_dim_t* tdim, unsigned int maxdim1);
/* Fills the array tdim with the dimensions associated with intervals in the
   linear expression, in increasing order, and return the number of such
   dimensions.

   tdim is supposed to be of size at least the maximum dimension + 1 in the
   expression.

   For the parameter maxdim1: corresponds to the maximal possible dimension
   + 1 */

/* ====================================================================== */
/* II.4 Conversions */
/* ====================================================================== */

MACRO_MAINZ
boolean ap_linyyyXXX_array_set_linyyyZZZ_array(ap_linyyyXXX_array_t a, ap_linyyyZZZ_array_t b, num_internal_t intern);
boolean ap_linyyyZZZ_array_set_linyyyXXX_array(ap_linyyyZZZ_array_t a, ap_linyyyXXX_array_t b, num_internal_t intern);
ENDMACRO

/* ====================================================================== */
/* II.5 Change of dimensions and permutations */
/* ====================================================================== */

/* These two functions add dimensions to the expressions, following the
   semantics of dimchange (see the type definition of dimchange).  */
void ap_linyyyXXX_array_add_dimensions(ap_linyyyXXX_array_t res,
				      ap_linyyyXXX_array_t array,
				      ap_dimchange_t* dimchange);

/* These two functions apply the given permutation to the dimensions.
   The dimensions present in the generator should just be less
   than the size of the permutation. */
void ap_linyyyXXX_array_permute_dimensions(ap_linyyyXXX_array_t res,
					  ap_linyyyXXX_array_t array,
					  ap_dimperm_t* dimchange);
void ap_linyyyXXX_array_extend_environment(ap_linyyyXXX_array_t res,
					   boolean* perror,
					   ap_environment_t* nenv,
					   ap_linyyyXXX_array_t expr,
					   ap_environment_t* env);



#undef _AP_yyy_MARK_
