/* -*- mode: c -*- */

/* This file is part of the APRON library, released under LGPL license.
   Please read the COPYING file packaged in the distribution  */

quote(C, "#include \"apron_caml.h\"")

import "mpz.idl";
import "mpq.idl";
import "mpfr.idl";
import "common.idl";
import "numXXX.idl";
import "boundXXX.idl";
import "eitvXXX.idl";
import "dim.idl";
import "var.idl";
import "environment.idl";

#define _AP_linyyyXXX_MARK_

#if !defined(_AP_linexprXXX_MARK_)
import "linexprXXX.idl";
#endif

typedef [abstract,c2ml(camlidl_ap_linyyyXXX_ptr_c2ml),ml2c(camlidl_ap_linyyyXXX_ptr_ml2c)] struct ap_linyyyXXX_struct* ap_linyyyXXX_ptr;
typedef [abstract,c2ml(camlidl_ap_linyyyXXX_array_ptr_c2ml),ml2c(camlidl_ap_linyyyXXX_array_ptr_ml2c)] struct ap_linyyyXXX_array_struct* ap_linyyyXXX_array_ptr;

#if defined(_AP_linexprXXX_MARK_)
quote(MLMLI,"(** (Interval) linear expressions *)\n\n")
#elif defined(_AP_linconsXXX_MARK_)
quote(MLMLI,"(** (Interval) linear constraints *)\n\n")
#elif defined(_AP_linexprXXX_MARK_)
quote(MLMLI,"(** Linear generators *)\n\n")
#endif

quote(MLI,"\n\
(** {2 Linear expressions/constraints/generators} *)\n\
\n\
(** {3 Pretty printing} *)\n\
val print : (Dim.t -> string) -> Format.formatter -> t -> unit\n\
\n\
(** {3 Initialization and Assignement Functions} *)\n\
")
quote(MLMLI,"external _init : int -> t\t= \"camlidl_ap_linyyyXXX__init\"")
quote(MLI,"val init : ?size:int -> unit -> t")
quote(MLMLI,"external init_set : t -> t\t= \"camlidl_ap_linyyyXXX_init_set\"")
quote(MLI,"\n\
val of_list0 : ?size:int -> ?cst:'a EitvXXX.tt -> (Dim.t * 'b EitvXXX.tt) list -> t\n\
val of_array0 : ?size:int -> ?cst:'a EitvXXX.tt -> (Dim.t * 'b EitvXXX.tt) array -> t\n\
val of_list1 : ?size:int -> ?cst:'a EitvXXX.tt -> Environment.t -> (Var.t * 'b EitvXXX.tt) list -> t\n\
val of_array1 : ?size:int -> ?cst:'a EitvXXX.tt -> Environment.t -> (Var.t * 'b EitvXXX.tt) array -> t\n\
")
void ap_linyyyXXX_set(ap_linyyyXXX_ptr res, ap_linyyyXXX_ptr a);
void ap_linyyyXXX_resize(ap_linyyyXXX_ptr a, unsigned int size);
void ap_linyyyXXX_resize_strict(ap_linyyyXXX_ptr a, unsigned int size);
void ap_linyyyXXX_minimize(ap_linyyyXXX_ptr e);

quote(MLI,"\n(** {3 Tests and Simplifications} *)")

boolean ap_linyyyXXX_is_integer(ap_linyyyXXX_ptr a, unsigned int intdim);
boolean ap_linyyyXXX_is_real(ap_linyyyXXX_ptr a, unsigned int intdim);

boolean ap_linyyyXXX_is_linear(ap_linyyyXXX_ptr a);
boolean ap_linyyyXXX_is_quasilinear(ap_linyyyXXX_ptr a);
enum ap_exprtyp_t ap_linyyyXXX_typ(ap_linyyyXXX_ptr a)
  quote(call, "_res = ap_linyyyXXX_type(a);");

[size_is(size)]ap_dim_t* ap_linyyyXXX__supportinterval(ap_linyyyXXX_ptr a, [out]unsigned int size)
  quote(call,"\n\
unsigned int effsize = ap_linyyyXXX_size(a);\n\
_res = ap_malloc(effsize*sizeof(ap_dim_t));\n\
size = ap_linyyyXXX_supportinterval(a,_res);\n\
")
  quote(dealloc,"free(_res);");
quote(MLI,"val supportinterval : t -> Dim.t array")
quote(ML,"let supportinterval a = fst (_supportinterval a)")

quote(MLI,"\n(** {3 Access} *)")

unsigned int ap_linyyyXXX_size(ap_linyyyXXX_ptr a);
void ap_linyyyXXX_get_cst(eitvXXX_ptrm eitv, ap_linyyyXXX_ptr a);
void ap_linyyyXXX_get_eitv0(eitvXXX_ptrm eitv, ap_linyyyXXX_ptr a, ap_dim_t dim);
void ap_linyyyXXX_get_eitv1(eitvXXX_ptrm eitv, ap_linyyyXXX_ptr a, ap_environment_ptr env, ap_var_t var)
  quote(call,"\n\
bool error;\n\
ap_linyyyXXX_get_eitv1(eitv, &error, a, env, var);\n\
if (error){\n\
  caml_invalid_argument(\"unknown variable in the environment\");\n\
}\n\
");

quote(MLMLI,"\n\
external ap_linyyyXXX_iter0: ('a EitvXXX.tt -> Dim.t -> unit) -> t -> unit = \"camlidl_apron_linyyyXXX_iter0\"\n\
    (** Iters the function on the pairs coefficient/dimension of the linear expression/constraint/generator *)\n\
")

quote(C,"\n\
value camlidl_apron_linyyyXXX_iter0(value _v_closure, value _v_linyyy)\n\
{\n\
  CAMLparam2(_v_closure,_v_linyyy);\n\
  CAMLlocal2(_v_dim,_v_eitv);\n\
  size_t i;\n\
  ap_dim_t dim;\n\
  eitvXXX_ptr peitv1,peitv2;\n\
  eitvXXX_t eitv;\n\
  ap_linyyyXXX_ptr linyyy;\n\
\n\
 camlidl_ap_linyyyXXX_ptr_ml2c(_v_linyyy,&linyyy);\n\
 peitv2 = eitv;\n\
 ap_linyyyXXX_ForeachLinterm0(linyyy,i,dim,peitv1){\n\
    _v_dim = Val_int(dim);\n\
    eitvXXX_init_set(eitv,peitv1);\n\
    _v_eitv = camlidl_eitvXXX_ptr_c2ml(&peitv2);\n\
    callback2(_v_closure,_v_eitv,_v_dim);\n\
  }\n\
  CAMLreturn(Val_unit);\n\
}\n\
")

quote(MLI,"val iter1 : ('a EitvXXX.tt -> Var.t -> unit) -> t -> Environment.t -> unit")

void ap_linyyyXXX_set_cst(ap_linyyyXXX_ptr a, eitvXXX_ptrg eitv);
void ap_linyyyXXX_set_eitv0(ap_linyyyXXX_ptr a, ap_dim_t dim, eitvXXX_ptrg eitv);
void ap_linyyyXXX_set_eitv1(ap_linyyyXXX_ptr a, ap_environment_ptr env, ap_var_t var, eitvXXX_ptrg eitv)
  quote(call,"\n\
bool error;\n\
ap_linyyyXXX_set_eitv1(a,&error,env,var,eitv);\n\
if (error){\n\
  caml_invalid_argument(\"unknown variable in the environment\");\n\
}\n\
");

quote(MLI,"\n\
val set_list0 : t ->  ?cst:'a EitvXXX.tt -> (Dim.t * 'b EitvXXX.tt) list -> unit\n\
val set_array0 : t -> ?cst:'b EitvXXX.tt -> (Dim.t * 'b EitvXXX.tt) array -> unit\n\
val set_list1 : t -> Environment.t -> ?cst:'a EitvXXX.tt -> (Var.t * 'b EitvXXX.tt) list -> unit\n\
val set_array1 : t -> Environment.t -> ?cst:'a EitvXXX.tt -> (Var.t * 'b EitvXXX.tt) array -> unit\n\
")


quote(MLI,"\n(** {3 Change of dimension and permutation} *)")
void ap_linyyyXXX_add_dimensions(ap_linyyyXXX_ptr res,
				ap_linyyyXXX_ptr a,
				[ref]ap_dimchange_t* dimchange)
quote(dealloc,"ap_dimchange_clear(dimchange);");
void ap_linyyyXXX_permute_dimensions(ap_linyyyXXX_ptr res,
				    ap_linyyyXXX_ptr a,
				    [ref]ap_dimperm_t* perm)
quote(dealloc,"ap_dimperm_clear(perm);");
void ap_linyyyXXX__extend_environment(ap_linyyyXXX_ptr res,
				     ap_environment_ptr nenv,
				     ap_linyyyXXX_ptr a,
				     ap_environment_ptr env)
  quote(call,"\n\
bool error;\n\
ap_linyyyXXX_extend_environment(res,&error,nenv,a,env);\n\
if (error){\n\
  caml_invalid_argument(\"The new (first) environment is not a super-environment of the old (second) one as expected\");\n\
}\n\
");
quote(MLI,"val extend_environment: t -> newenv:Environment.t -> t -> oldenv:Environment.t -> unit")

quote(MLI,"\n(** {3 Hashing and comparison} *)")

int ap_linyyyXXX_hash(ap_linyyyXXX_ptr a);
boolean ap_linyyyXXX_equal(ap_linyyyXXX_ptr a1,ap_linyyyXXX_ptr a2);

/* Lexicographic ordering, terminating by constant coefficients */
int ap_linyyyXXX_cmp(ap_linyyyXXX_ptr a1, ap_linyyyXXX_ptr a2);

quote(MLI,"\n(** {2 Arrays} *)")

quote(MLI,"\n(** {3 Pretty printing} *)\n")
quote(MLI,"\n\
val array_print :\n\
  ?first:(unit, Format.formatter, unit) format ->\n\
  ?sep:(unit, Format.formatter, unit) format ->\n\
  ?last:(unit, Format.formatter, unit) format ->\n\
 (Dim.t -> string) -> Format.formatter -> earray -> unit\n\
")

quote(MLI,"\n(** {3 Initialization and Assignement Functions} *)")

quote(MLMLI,"external array_init : int -> earray\t= \"camlidl_ap_linyyyXXX_array_init\"")
quote(MLMLI,"external array_init_set : earray -> earray\t= \"camlidl_ap_linyyyXXX_array_init_set\"")
void ap_linyyyXXX_array_set(ap_linyyyXXX_array_ptr res, ap_linyyyXXX_array_ptr array);
void ap_linyyyXXX_array_resize(ap_linyyyXXX_array_ptr array, unsigned int size);
void ap_linyyyXXX_array_minimize(ap_linyyyXXX_array_ptr array);

quote(MLI,"\n(** {3 Tests and Simplifications} *)")

boolean ap_linyyyXXX_array_is_linear(ap_linyyyXXX_array_ptr array);
boolean ap_linyyyXXX_array_is_quasilinear(ap_linyyyXXX_array_ptr array);
enum ap_exprtyp_t ap_linyyyXXX_array_typ(ap_linyyyXXX_array_ptr array)
  quote(call, "_res = ap_linyyyXXX_array_type(array);");

[size_is(size)]ap_dim_t* ap_linyyyXXX_array_supportinterval(ap_linyyyXXX_array_ptr array, [out]unsigned int size)
  quote(call,"\n\
unsigned int i,maxdim;\n\
maxdim = 0;\n\
for (i=0; i<array->size; i++){\n\
  unsigned int effsize = ap_linyyyXXX_size(array->p[i]);\n\
  if (effsize>maxdim) maxdim = effsize;\n\
}\n\
_res = ap_malloc(maxdim*sizeof(ap_dim_t));\n\
size = ap_linyyyXXX_array_supportinterval(array,_res,maxdim);\n\
")
  quote(dealloc,"free(_res);");

quote(MLI,"\n(** {3 Access} *)")

int ap_linyyyXXX_array_length(ap_linyyyXXX_array_ptr array)
  quote(call,"_res = array->size;");
void ap_linyyyXXX_array_get_index(ap_linyyyXXX_ptr a, ap_linyyyXXX_array_ptr array, int i)
  quote(call, "\n\
if (i<0 || i>=(int)array->size) caml_invalid_argument(\"Out of bound array access\");\n\
ap_linyyyXXX_set(a,array->p[i]);\n\
");
void ap_linyyyXXX_array_set_index(ap_linyyyXXX_array_ptr array, int i, ap_linyyyXXX_ptr a)
  quote(call, "\n\
if (i<0 || i>=(int)array->size) caml_invalid_argument(\"Out of bound array access\");\n\
ap_linyyyXXX_set(array->p[i],a);\n\
");

quote(MLI,"\n(** {3 Change of dimension and permutation} *)")

void ap_linyyyXXX_array_add_dimensions(ap_linyyyXXX_array_ptr res,
				      ap_linyyyXXX_array_ptr array,
				       [ref]ap_dimchange_t* dimchange)
quote(dealloc,"ap_dimchange_clear(dimchange);");

void ap_linyyyXXX_array_permute_dimensions(ap_linyyyXXX_array_ptr res,
					  ap_linyyyXXX_array_ptr array,
					  [ref]ap_dimperm_t* perm)
quote(dealloc,"ap_dimperm_clear(perm);");
void ap_linyyyXXX__array_extend_environment(ap_linyyyXXX_array_ptr res,
					   ap_environment_ptr nenv,
					   ap_linyyyXXX_array_ptr a,
					   ap_environment_ptr env)
  quote(call,"\n\
bool error;\n\
ap_linyyyXXX_array_extend_environment(res,&error,nenv,a,env);\n\
if (error){\n\
  caml_invalid_argument(\"The new (first) environment is not a super-environment of the old (second) one as expected\");\n\
}\n\
");
quote(MLI,"val array_extend_environment: earray -> newenv:Environment.t -> earray -> oldenv:Environment.t -> unit")

/* ====================================================================== */
/* III. ML part */
/* ====================================================================== */

quote(ML,"\n\
let init ?(size=0) () = _init size\n\
let iter1 f a env =\n\
  iter0\n\
    (begin fun eitv dim ->\n\
      let var = Environment.var_of_dim env dim in\n\
      f eitv var\n\
    end)\n\
    a\n\
let set_list0 expr ?cst list =\n\
  List.iter\n\
    (fun (dim,eitv) -> set_eitv0 expr dim eitv)\n\
    list;\n\
  begin match cst with\n\
  | Some cst -> set_cst expr cst\n\
  | None -> ()\n\
  end;\n\
  ()\n\
let set_array0 expr ?cst tab =\n\
  Array.iter\n\
    (fun (dim,eitv) -> set_eitv0 expr dim eitv )\n\
    tab;\n\
  begin match cst with\n\
  | Some cst -> set_cst expr cst\n\
  | None -> ()\n\
  end;\n\
  ()\n\
\n\
let set_list1 expr env ?cst list =\n\
  List.iter\n\
    (fun (var,eitv) -> set_eitv1 expr env var eitv)\n\
    list;\n\
  begin match cst with\n\
  | Some cst -> set_cst expr cst\n\
  | None -> ()\n\
  end;\n\
  ()\n\
let set_array1 expr env ?cst tab =\n\
  Array.iter\n\
    (fun (var,eitv) -> set_eitv1 expr env var eitv )\n\
    tab;\n\
  begin match cst with\n\
  | Some cst -> set_cst expr cst\n\
  | None -> ()\n\
  end;\n\
  ()\n\
\n\
let of_list0 ?size ?cst list =\n\
  let a = init ~size:(match size with None -> List.length list | Some x -> x) () in\n\
  set_list0 a ?cst list;\n\
  a\n\
let of_array0 ?size ?cst tab =\n\
  let a = init ~size:(match size with None -> Array.length tab | Some x -> x) () in\n\
  set_array0 a ?cst tab;\n\
  a\n\
let of_list1 ?size ?cst env list =\n\
  let a = init ~size:(match size with None -> List.length list | Some x -> x) () in\n\
  set_list1 a env ?cst list;\n\
  a\n\
let of_array1 ?size ?cst env tab =\n\
  let a = init ~size:(match size with None -> Array.length tab | Some x -> x) () in\n\
  set_array1 a env ?cst tab;\n\
  a\n\
\n\
let printexpr assoc fmt expr =\n\
  Format.fprintf fmt \"@[<hov>\";\n\
  let first = ref true in\n\
  let print_eitv ~cst eitv =\n\
    if not !first then Format.fprintf fmt \"@,\";\n\
    if EitvXXX.is_point eitv then begin\n\
      let bound = BoundXXX.init () in\n\
      EitvXXX.get_sup bound eitv;\n\
      let sgn = BoundXXX.sgn bound in\n\
      if sgn>0 then begin\n\
	if not !first then Format.pp_print_string fmt \"+\";\n\
      end else begin\n\
	Format.pp_print_string fmt \"-\";\n\
	BoundXXX.neg bound bound;\n\
      end;\n\
      if cst || BoundXXX.cmp_int bound 1 <> 0 then\n\
	BoundXXX.print fmt bound;\n\
    end else begin\n\
      if not !first then Format.pp_print_string fmt \"+\";\n\
	EitvXXX.print fmt eitv\n\
    end;\n\
    ()\n\
  in\n\
  iter0\n\
    (begin fun eitv dim ->\n\
      if not (EitvXXX.is_zero eitv) then begin\n\
	print_eitv ~cst:false eitv;\n\
	Format.pp_print_string fmt (assoc dim);\n\
	first := false;\n\
      end;\n\
    end)\n\
    expr\n\
  ;\n\
  let eitv = EitvXXX.init() in\n\
  get_cst eitv expr;\n\
  if not (EitvXXX.is_zero eitv) then print_eitv ~cst:true eitv;\n\
    Format.fprintf fmt \"@]\";\n\
  ()\n\
let extend_environment res ~newenv old ~oldenv = _extend_environment res newenv old oldenv\n\
let array_extend_environment res ~newenv old ~oldenv = _array_extend_environment res newenv old oldenv\n\
")


#if !defined(_AP_linexprXXX_MARK_)
quote(MLI,"\n\
(** {2 Specific to constraints and generators} *)\n\
(** {3 Access} *)\n\
")
void ap_linyyyXXX_get_linexpr(ap_linexprXXX_ptr a, ap_linyyyXXX_ptr b)
  quote(call,"ap_linexprXXX_set(a,b->linexpr);");
enum ap_yyytyp_t ap_linyyyXXX_get_yyytyp(ap_linyyyXXX_ptr a)
  quote(call,"_res = a->yyytyp;");
void ap_linyyyXXX_set_linexpr(ap_linyyyXXX_ptr a, ap_linexprXXX_ptr b)
  quote(call,"ap_linexprXXX_set(a->linexpr,b);");
void ap_linyyyXXX_set_yyytyp(ap_linyyyXXX_ptr a, enum ap_yyytyp_t b)
  quote(call,"a->yyytyp = b;");
#endif

#if defined(_AP_linconsXXX_MARK_)
quote(MLI,"\n\
(** {2 Specific to constraints only} *)\n\
(** {3 Assignement} *)\n\
")
void ap_linconsXXX_set_bool(ap_linconsXXX_ptr lincons, boolean value);
quote(MLI,"\n\
(** {3 Access} *)\n\
")
void ap_linyyyXXX_get_mpq(mpq_ptrm a, ap_linyyyXXX_ptr b)
  quote(call,"mpq_set(a,b->mpq);");
void ap_linyyyXXX_set_mpq(ap_linyyyXXX_ptr a, mpq_ptrg b)
  quote(call,"mpq_set(a->mpq,b);");
quote(MLI,"\n\
(** {3 Constructor} *)\n\
val make : LinexprXXX.t -> Common.constyp -> 'a Mpq.tt option -> t\n\
")
quote(ML,"\n\
let make linexpr constyp ompq =\n\
  let res = init () in\n\
  set_linexpr res linexpr;\n\
  set_constyp res constyp;\n\
  begin match ompq with\n\
  | None -> ()\n\
  | Some mpq -> set_mpq res mpq\n\
  end;\n\
  res\n\
")
#endif

#if defined(_AP_lingenXXX_MARK_)
quote(MLI,"\n\
(** {2 Specific to generators only} *)\n\
(** {3 Constructor} *)\n\
val make : LinexprXXX.t -> Common.gentyp -> t\n\
")
quote(ML,"\n\
let make linexpr gentyp =\n\
  let res = init () in\n\
  set_linexpr res linexpr;\n\
  set_gentyp res gentyp;\n\
  res\n\
")
#endif

#if defined(_AP_linexprXXX_MARK_)
quote(ML,"let print = printexpr")
#elif defined(_AP_linconsXXX_MARK_)
quote(ML,"\n\
let print assoc fmt cons =\n\
  printexpr assoc fmt cons;\n\
  let constyp = get_constyp cons in\n\
  Format.pp_print_string fmt (Common.string_of_constyp constyp);\n\
  if constyp = Common.EQMOD then begin\n\
    let mpq = Mpq.init() in\n\
    get_mpq mpq cons;\n\
    Format.fprintf fmt \" mod %a\" Mpq.print mpq\n\
  end\n\
")
#elif defined(_AP_lingenXXX_MARK_)
quote(ML,"\n\
let print assoc fmt gen =\n\
  let gentyp = get_gentyp gen in\n\
  Format.fprintf fmt \"%s:%a\"\n\
    (Common.string_of_gentyp gentyp)\n\
    (printexpr assoc) gen\n\
")
#endif

quote(ML,"\n\
let array_print ?first ?sep ?last assoc fmt array =\n\
  let a = init () in\n\
  Common.earray_print ?first ?sep ?last\n\
    ~length:(array_length array)\n\
    ~print_index:(fun fmt index ->\n\
      array_get_index a array index;\n\
      print assoc fmt a)\n\
    fmt\n\
")

#undef _AP_yyy_MARK_
