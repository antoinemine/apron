/* -*- mode: c -*- */

/* ********************************************************************** */
/* apron_caml.c */
/* ********************************************************************** */

/* This file is part of the APRON Library, released under LGPL license.
   Please read the COPYING file packaged in the distribution  */

#include "apron_caml.h"
#include "caml/camlidlruntime.h"

/* ********************************************************************** */
/* dimensions */
/* ********************************************************************** */

extern void camlidl_ml2c_dim_struct_ap_dimension_t(value _v1, struct ap_dimension_t * _c2, struct camlidl_ctx_struct* _ctx);
extern value camlidl_c2ml_dim_struct_ap_dimension_t(struct ap_dimension_t * _c1, struct camlidl_ctx_struct* _ctx);

void camlidl_apron_dimchange_ml2c(
    const value v, ap_dimchange_t* dimchange,
    struct camlidl_ctx_struct* _ctx)
{
  ap_dimension_t dimension;
  size_t i;

  value vdim = Field(v,0);
  value vdimension = Field(v,1);
  camlidl_ml2c_dim_struct_ap_dimension_t(vdimension,&dimchange->dim,NULL);
  size_t size1 = ap_dimension_size(dimchange->dim);
  dimchange->p = camlidl_malloc(size1*sizeof(ap_dim_t),_ctx);
  ap_dimchange_init(dimchange,dimchange->dim);
  size_t size = Wosize_val(vdim);
  if (size != size1)
    caml_failwith("Invalid object of type Dim.dimchange: size of the array smaller than size of dimension");
  for (i=0;i<size;i++){
    value v = Field(vdim,i);
    dimchange->p[i] = Int_val(v);
  }
  return;
}

value camlidl_apron_dimchange_c2ml(ap_dimchange_t* dimchange)
{
  CAMLparam0();
  CAMLlocal3(v,vdimension,vdim);
  size_t i;

  size_t size = ap_dimension_size(dimchange->dim);
  vdimension = camlidl_c2ml_dim_struct_ap_dimension_t(&dimchange->dim, NULL);
  vdim = caml_alloc(size,0);
  for (i=0;i<size;i++){
    v = Val_int(dimchange->p[i]);
    Store_field(vdim,i,v);
  }
  v = caml_alloc_small(2,0);
  Field(v,0) = vdim;
  Field(v,1) = vdimension;
  ap_dimchange_free(dimchange);
  CAMLreturn(v);
}

/* ********************************************************************** */
/* variable */
/* ********************************************************************** */

apron_var_ptr ap_var_of_string(char* name)
{
  apron_var_ptr p = malloc(sizeof(apron_var_t));
  p->name = malloc((1+strlen(name))*sizeof(char));
  strcpy(p->name,name);
  p->count=1;
  return p;
}
int ap_var_compare(ap_var_t pp1, ap_var_t pp2)
{
  apron_var_ptr p1 = (apron_var_ptr)pp1;
  apron_var_ptr p2 = (apron_var_ptr)pp2;
  return (p1==p2) ? 0 : strcmp(p1->name,p2->name);
}
char* ap_var_to_string(ap_var_t pp)
{
  apron_var_ptr p = (apron_var_ptr)pp;
  size_t l;
  char* res;

  l = strlen(p->name)+1;
  res = malloc(l*sizeof(char));
  strcpy(res,p->name);
  return res;
}
int ap_var_hash(ap_var_t pp)
{
  apron_var_ptr p = (apron_var_ptr)pp;
  unsigned char* c;
  int res = 0;
  for (c=(unsigned char*)p->name; (*c)!=0; c++){
    res = res * 11 + (*c);
  }
  return res;
}
static inline
ap_var_t ap_var_copy(ap_var_t pp){
  apron_var_ptr p = (apron_var_ptr)pp;
  p->count++;
  return (ap_var_t)p;
}
static inline
void ap_var_free(ap_var_t pp){
  apron_var_ptr p = (apron_var_ptr)pp;
  if (p->count<=1){
    free(p->name);
    free(p);
  }
  else
    p->count--;
}

static
struct ap_var_operations_t
camlidl_apron_var_ptr_operations = {
  ap_var_compare,
  ap_var_hash,
  ap_var_copy,
  ap_var_free,
  ap_var_to_string
};
value camlidl_apron_var_set_operations(value v)
{
  CAMLparam1(v);
  ap_var_operations = &camlidl_apron_var_ptr_operations;
  CAMLreturn(Val_unit);
}

static void camlidl_apron_var_ptr_finalize(value v)
{
  apron_var_ptr e = *(apron_var_ptr *) Data_custom_val(v);
  ap_var_free(e);
  return;
}

static long camlidl_apron_var_ptr_hash(value v)
{
  CAMLparam1(v);
  apron_var_ptr e = *(apron_var_ptr *) Data_custom_val(v);
  int res = ap_var_hash(e);
  CAMLreturn(res);
}
static int camlidl_apron_var_ptr_compare(value v1, value v2)
{
  CAMLparam2(v1,v2);
  int res;
  apron_var_ptr e1 = *(apron_var_ptr *) Data_custom_val(v1);
  apron_var_ptr e2 = *(apron_var_ptr *) Data_custom_val(v2);
  res = ap_var_compare(e1,e2);
  CAMLreturn(res);
}

struct custom_operations camlidl_apron_custom_var_ptr = {
  "ap_var_ptr",
  camlidl_apron_var_ptr_finalize,
  camlidl_apron_var_ptr_compare,
  camlidl_apron_var_ptr_hash,
  custom_serialize_default,
  custom_deserialize_default
};

value camlidl_apron_var_ptr_c2ml(ap_var_t* p)
{
  value v = alloc_custom(&camlidl_apron_custom_var_ptr, sizeof(apron_var_ptr), 0,1);
  *((apron_var_ptr *) Data_custom_val(v)) = *p;
  return v;
}

/* ********************************************************************** */
/* environment */
/* ********************************************************************** */

static void camlidl_apron_environment_ptr_finalize(value v)
{
  ap_environment_t* e = *(ap_environment_ptr *) Data_custom_val(v);
  ap_environment_free(e);
  return;
}

static
long camlidl_apron_environment_ptr_hash(value v)
{
  CAMLparam1(v);
  ap_environment_t* e = *(ap_environment_ptr *) Data_custom_val(v);
  int res = ap_environment_hash(e);
  CAMLreturn(res);
}
static
int camlidl_apron_environment_ptr_compare(value v1, value v2)
{
  CAMLparam2(v1,v2);
  int res;
  ap_environment_t* env1 = *(ap_environment_ptr *) Data_custom_val(v1);
  ap_environment_t* env2 = *(ap_environment_ptr *) Data_custom_val(v2);
  res = ap_environment_compare(env1,env2);
  CAMLreturn(res);
}

struct custom_operations camlidl_apron_custom_environment_ptr = {
  "ap_environment_ptr",
  camlidl_apron_environment_ptr_finalize,
  camlidl_apron_environment_ptr_compare,
  camlidl_apron_environment_ptr_hash,
  custom_serialize_default,
  custom_deserialize_default
};

value camlidl_apron_environment_ptr_c2ml(ap_environment_ptr* p)
{
  value v;

   v = alloc_custom(&camlidl_apron_custom_environment_ptr, sizeof(ap_environment_ptr), 0,1);
  *((ap_environment_ptr *) Data_custom_val(v)) = *p;
  return v;
}

/* ********************************************************************** */
/* Numbers, bounds, intervals, linear expressions/constraints/generators */
/* ********************************************************************** */

MACRO_FOREACH TTT ("num","bound","eitv","ap_linexpr","ap_lincons","ap_lingen")
MACRO_FOREACH XXX @AllNumIdl
void camlidl_custom_TTTXXX_finalize(value val)
{
  TTTXXX_ptr a = *(TTTXXX_ptr*)(Data_custom_val(val));
  TTTXXX_clear(a);
  free(a);
}
int camlidl_custom_TTTXXX_compare(value val1, value val2)
{
  int res;
  TTTXXX_ptr a1;
  TTTXXX_ptr a2;

  a1 = *(TTTXXX_ptr*)(Data_custom_val(val1));
  a2 = *(TTTXXX_ptr*)(Data_custom_val(val2));
  res = TTTXXX_cmp(a1,a2);
  res = res > 0 ? 1 : res==0 ? 0 : -1;
  return res;
}
long camlidl_custom_TTTXXX_hash(value val)
{
  TTTXXX_ptr a = *(TTTXXX_ptr*)(Data_custom_val(val));
  return TTTXXX_hash(a);
}
void camlidl_custom_TTTXXX_serialize(
    value v, unsigned long* wsize_32, unsigned long* wsize_64
)
{
  TTTXXX_ptr a = *(TTTXXX_ptr*)(Data_custom_val(v));
  char* buf = malloc(TTTXXX_serialized_size(a));
  size_t count = TTTXXX_serialize(buf,a);
  caml_serialize_int_4((int32)count);
  caml_serialize_block_1(buf,(intnat)count);
  *wsize_32 = 4;
  *wsize_64 = 8;
  free(buf);
}
unsigned long camlidl_custom_TTTXXX_deserialize(void * dst)
{
  TTTXXX_ptr a = malloc(sizeof(TTTXXX_t));
  *(TTTXXX_ptr*)dst = a;
  int32 count = caml_deserialize_sint_4();
  char* buf = malloc(count);
  caml_deserialize_block_1(buf,count);
  TTTXXX_deserialize(a,buf);
  free(buf);
  return sizeof(a);
}
struct custom_operations camlidl_custom_TTTXXX = {
  "camlidl_apron_custom_TTTXXX",
  &camlidl_custom_TTTXXX_finalize,
  &camlidl_custom_TTTXXX_compare,
  &camlidl_custom_TTTXXX_hash,
  &camlidl_custom_TTTXXX_serialize,
  &camlidl_custom_TTTXXX_deserialize
};

value camlidl_TTTXXX_ptr_c2ml(TTTXXX_ptr* a)
{
  value val;
  TTTXXX_ptr p;

  p = malloc(sizeof(TTTXXX_t));
  *p = **a;
  val = alloc_custom(&camlidl_custom_TTTXXX, sizeof(TTTXXX_ptr), 0, 1);
  *(((TTTXXX_ptr*)(Data_custom_val(val)))) = p;
  return val;
}
ENDMACRO
ENDMACRO

MACRO_FOREACH TTT ("ap_linexpr","ap_lincons","ap_lingen")
MACRO_FOREACH XXX @AllNumIdl
void camlidl_custom_TTTXXX_array_finalize(value val)
{
  TTTXXX_array_ptr a = *(TTTXXX_array_ptr*)(Data_custom_val(val));
  TTTXXX_array_clear(a);
  free(a);
}
int camlidl_custom_TTTXXX_array_compare(value val1, value val2)
{
  int res;
  TTTXXX_array_ptr a1;
  TTTXXX_array_ptr a2;

  a1 = *(TTTXXX_array_ptr*)(Data_custom_val(val1));
  a2 = *(TTTXXX_array_ptr*)(Data_custom_val(val2));
  res = (int)a1->size - (int)a2->size;
  if (res==0){
    size_t i;
    for(i=0;i<a1->size;i++){
      res = TTTXXX_cmp(a1->p[i],a2->p[i]);
      if (res) break;
    }
  }
  res = res > 0 ? 1 : res==0 ? 0 : -1;
  return res;
}
void camlidl_custom_TTTXXX_array_serialize(
    value v, unsigned long* wsize_32, unsigned long* wsize_64
)
{
  TTTXXX_array_ptr a = *(TTTXXX_array_ptr*)(Data_custom_val(v));
  char* buf = malloc(TTTXXX_array_serialized_size(a));
  size_t count = TTTXXX_array_serialize(buf,a);
  caml_serialize_int_4((int32)count);
  caml_serialize_block_1(buf,(intnat)count);
  *wsize_32 = 4;
  *wsize_64 = 8;
  free(buf);
}
unsigned long camlidl_custom_TTTXXX_array_deserialize(void * dst)
{
  TTTXXX_array_ptr a = malloc(sizeof(TTTXXX_array_t));
  *(TTTXXX_array_ptr*)dst = a;
  int32 count = caml_deserialize_sint_4();
  char* buf = malloc(count);
  caml_deserialize_block_1(buf,count);
  TTTXXX_array_deserialize(a,buf);
  free(buf);
  return sizeof(a);
}
struct custom_operations camlidl_custom_TTTXXX_array = {
  "camlidl_apron_custom_TTTXXX_array",
  &camlidl_custom_TTTXXX_array_finalize,
  &camlidl_custom_TTTXXX_array_compare,
  custom_hash_default,
  &camlidl_custom_TTTXXX_array_serialize,
  &camlidl_custom_TTTXXX_array_deserialize
};

value camlidl_TTTXXX_array_ptr_c2ml(TTTXXX_array_ptr* a)
{
  value val;
  TTTXXX_array_ptr p;

  p = malloc(sizeof(TTTXXX_array_t));
  *p = **a;
  val = alloc_custom(&camlidl_custom_TTTXXX_array, sizeof(TTTXXX_array_ptr), 0, 1);
  *(((TTTXXX_array_ptr*)(Data_custom_val(val)))) = p;
  return val;
}
ENDMACRO
ENDMACRO

/* ********************************************************************** */
/* coefficients */
/* ********************************************************************** */

void camlidl_coeff_ptr_ml2c(value v, ap_coeff_t* pcoeff)
{
  ap_scalar_discr_t discr = Tag_val(v);
  ap_coeff_ptr coeff = *pcoeff;

  coeff->discr = discr;
  MACRO_SWITCH(discr) XXX
    camlidl_eitvXXX_ptr_ml2c(Field(v,0),&coeff->eitv.XXX);
  ENDMACRO;
}
value camlidl_coeff_ptr_c2ml(ap_coeff_t* pcoeff)
{
  CAMLparam0();
  CAMLlocal2(v,v2);
  ap_coeff_ptr coeff = *pcoeff;
  MACRO_SWITCH(coeff->discr) XXX
    v2 = camlidl_eitvXXX_ptr_c2ml(&coeff->eitv.XXX);
  ENDMACRO;
  v = alloc_small(1,coeff->discr);
  Field(v,0) = v2;
  CAMLreturn(v);
}

MACRO_FOREACH TTT ("expr","cons","gen")
void camlidl_linTTT0_ptr_ml2c(value v, ap_linTTT0_t* plinTTT0)
{
  ap_scalar_discr_t discr = Tag_val(v);
  ap_linTTT0_ptr linTTT0 = *plinTTT0;
  linTTT0->discr = discr;
  switch(discr){
  case AP_SCALAR_D:
    camlidl_ap_linTTTD_ptr_ml2c(Field(v,0),&linTTT0->linTTT.D);
    break;
  case AP_SCALAR_MPQ:
    camlidl_ap_linTTTMPQ_ptr_ml2c(Field(v,0),&linTTT0->linTTT.MPQ);
    break;
  case AP_SCALAR_MPFR:
    camlidl_ap_linTTTMPFR_ptr_ml2c(Field(v,0),&linTTT0->linTTT.MPFR);
    break;
  default: abort();
  }
}
value camlidl_linTTT0_ptr_c2ml(ap_linTTT0_t* plinTTT0)
{
  CAMLparam0();
  CAMLlocal2(v,v2);
  ap_linTTT0_ptr linTTT0 = *plinTTT0;
  switch(linTTT0->discr){
  case AP_SCALAR_D:
    v2 = camlidl_ap_linTTTD_ptr_c2ml(&linTTT0->linTTT.D);
    break;
  case AP_SCALAR_MPQ:
    v2 = camlidl_ap_linTTTMPQ_ptr_c2ml(&linTTT0->linTTT.MPQ);
    break;
  case AP_SCALAR_MPFR:
    v2 = camlidl_ap_linTTTMPFR_ptr_c2ml(&linTTT0->linTTT.MPFR);
    break;
  default: abort();
  }
  v = alloc_small(1,linTTT0->discr);
  Field(v,0) = v2;
  CAMLreturn(v);
}
void camlidl_linTTT0_array_ptr_ml2c(value v, ap_linTTT0_array_t* plinTTT0)
{
  ap_scalar_discr_t discr = Tag_val(v);
  ap_linTTT0_array_ptr linTTT0 = *plinTTT0;
  linTTT0->discr = discr;
  switch(discr){
  case AP_SCALAR_D:
    camlidl_ap_linTTTD_array_ptr_ml2c(Field(v,0),&linTTT0->linTTT_array.D);
    break;
  case AP_SCALAR_MPQ:
    camlidl_ap_linTTTMPQ_array_ptr_ml2c(Field(v,0),&linTTT0->linTTT_array.MPQ);
    break;
  case AP_SCALAR_MPFR:
    camlidl_ap_linTTTMPFR_array_ptr_ml2c(Field(v,0),&linTTT0->linTTT_array.MPFR);
    break;
  default: abort();
  }
}
value camlidl_linTTT0_array_ptr_c2ml(ap_linTTT0_array_t* plinTTT0)
{
  CAMLparam0();
  CAMLlocal2(v,v2);
  ap_linTTT0_array_ptr linTTT0 = *plinTTT0;
  switch(linTTT0->discr){
  case AP_SCALAR_D:
    v2 = camlidl_ap_linTTTD_array_ptr_c2ml(&linTTT0->linTTT_array.D);
    break;
  case AP_SCALAR_MPQ:
    v2 = camlidl_ap_linTTTMPQ_array_ptr_c2ml(&linTTT0->linTTT_array.MPQ);
    break;
  case AP_SCALAR_MPFR:
    v2 = camlidl_ap_linTTTMPFR_array_ptr_c2ml(&linTTT0->linTTT_array.MPFR);
    break;
  default: abort();
  }
  v = alloc_small(1,linTTT0->discr);
  Field(v,0) = v2;
  CAMLreturn(v);
}
ENDMACRO

/* ********************************************************************** */
/* texpr0 */
/* ********************************************************************** */

static
void camlidl_apron_texpr0_ptr_finalize(value v)
{
  ap_texpr0_t* p = *(ap_texpr0_ptr *)Data_custom_val(v);
  ap_texpr0_free(p);
}

static
long camlidl_apron_texpr0_ptr_hash(value v)
{
  ap_texpr0_t* p = *(ap_texpr0_ptr *)Data_custom_val(v);
  return ap_texpr0_hash(p);
}
static
int camlidl_apron_texpr0_ptr_compare(value v1, value v2)
{
  ap_texpr0_t* p1 = *(ap_texpr0_ptr *) Data_custom_val(v1);
  ap_texpr0_t* p2 = *(ap_texpr0_ptr *) Data_custom_val(v2);
  return ap_texpr0_equal(p1,p2) ? 0 : (p1<p2 ? (-1) : 1);
}

struct custom_operations camlidl_apron_custom_texpr0_ptr = {
  "camlidl_apron_custom_texpr0",
  camlidl_apron_texpr0_ptr_finalize,
  camlidl_apron_texpr0_ptr_compare,
  camlidl_apron_texpr0_ptr_hash,
  custom_serialize_default,
  custom_deserialize_default
};

/* ********************************************************************** */
/* tcons0 */
/* ********************************************************************** */

void camlidl_apron_tcons0_t_ml2c(value v, ap_tcons0_t* p)
{
  camlidl_apron_texpr0_ptr_ml2c(Field(v,0),&p->texpr0);
  p->constyp = camlidl_ml2c_common_enum_constyp(Field(v,1));
  mpq_ptr ptr = p->mpq;
  camlidl_mpq_ptr_ml2c(Field(v,2),&ptr);
}
value camlidl_apron_tcons0_t_c2ml(ap_tcons0_t* p)
{
  CAMLparam0();
  CAMLlocal4(v0,v1,v2,v);
  v0 = camlidl_apron_texpr0_ptr_c2ml(&p->texpr0);
  v1 = camlidl_c2ml_common_enum_constyp(p->constyp);
  mpq_ptr ptr = p->mpq;
  v2 = camlidl_mpq_ptr_c2ml(&ptr);
  v = alloc_small(3,0);
  Field(v,0) = v0;
  Field(v,1) = v1;
  Field(v,2) = v2;
  free(p);
  CAMLreturn(v);
}

/* ********************************************************************** */
/* manager */
/* ********************************************************************** */

static
void camlidl_apron_manager_ptr_finalize(value v)
{
  ap_manager_ptr p = *(ap_manager_ptr *) Data_custom_val(v);
  ap_manager_free(p);
}

static
int camlidl_apron_manager_ptr_compare(value v1, value v2)
{
  CAMLparam2(v1,v2);
  int res;
  ap_manager_ptr p1 = *(ap_manager_ptr *) Data_custom_val(v1);
  ap_manager_ptr p2 = *(ap_manager_ptr *) Data_custom_val(v2);
  res = (p1==p2 || p1->library==p2->library) ? 0 : ((p1<p2) ? (-1) : 1);
  CAMLreturn(res);
}

struct custom_operations camlidl_apron_custom_manager_ptr = {
  "apman",
  camlidl_apron_manager_ptr_finalize,
  camlidl_apron_manager_ptr_compare,
  custom_hash_default,
  custom_serialize_default,
  custom_deserialize_default
};

void camlidl_apron_manager_check_exception(struct ap_manager_t* man, void* _ctx)
{
  value* p = caml_named_value("apron exception");
  if(p==NULL){
    fprintf(stderr,"mlapronidl: error: line <let _ = Callback.register ...> of manager.ml has not been executed: this is not normal\n");
    abort();
  }
  value v = camlidl_c2ml_manager_struct_ap_exclog_t(man->result.exclog,NULL);
  caml_raise_with_arg(*p,v);
}

/* ********************************************************************** */
/* abstract0 */
/* ********************************************************************** */

mlsize_t camlidl_apron_heap = 1 << 20;

static
void camlidl_apron_abstract0_ptr_finalize(value v)
{
  ap_abstract0_ptr* p = (ap_abstract0_ptr *) Data_custom_val(v);
  ap_abstract0_t* a = *p;
  ap_abstract0_free(a->man,a);
}
static
long camlidl_apron_abstract0_ptr_hash(value v)
{
  ap_abstract0_ptr* p = (ap_abstract0_ptr *) Data_custom_val(v);
  ap_abstract0_t* a = *p;
  long res = ap_abstract0_hash(a->man,a);
  if (a->man->result.exn!=AP_EXC_NONE) camlidl_apron_manager_check_exception(a->man,NULL);
  return res;
}
static
int camlidl_apron_abstract0_ptr_compare(value v1, value v2)
{
  ap_abstract0_ptr* p1 = (ap_abstract0_ptr *) Data_custom_val(v1);
  ap_abstract0_ptr* p2 = (ap_abstract0_ptr *) Data_custom_val(v2);
  ap_abstract0_t* a1 = *p1;
  ap_abstract0_t* a2 = *p2;
  ap_dimension_t dim1,dim2;
  int res;
  if (v1==v2 || p1==p2 || a1==a2)
    res=0;
  else {
    dim1 = ap_abstract0_dimension(a1->man,a1);
    dim2 = ap_abstract0_dimension(a2->man,a2);
    res = dim1.intd-dim2.intd;
    if (!res){
      res = dim1.reald-dim2.reald;
      if (!res){
	if (ap_abstract0_is_eq(a1->man,a1,a2))
	  res=0;
	else
	  res = a1 > a2 ? 1 : (-1);
	if (a1->man->result.exn!=AP_EXC_NONE) camlidl_apron_manager_check_exception(a1->man,NULL);
      }
    }
  }
  return res;
}

/* global manager used for deserialization */
static ap_manager_ptr deserialize_man = NULL;

void ap_manager_set_deserialize(ap_manager_ptr man)
{
  deserialize_man = man;
}

ap_manager_ptr ap_manager_get_deserialize(void)
{
  return deserialize_man;
}

static
void camlidl_apron_abstract0_serialize(value v, unsigned long * w32, unsigned long * w64)
{
  ap_abstract0_ptr* p = (ap_abstract0_ptr *) Data_custom_val(v);
  ap_abstract0_t* a = *p;
  ap_membuf_t buf = ap_abstract0_serialize_raw(a->man,a);
  serialize_int_8(buf.size);
  serialize_block_1(buf.ptr,buf.size);
  *w32 = 4;
  *w64 = 8;
}

static
unsigned long camlidl_apron_abstract0_deserialize(void * dst)
{
  if (deserialize_man) {
    size_t size = deserialize_uint_8(), realsize;
    void* data;
    data = malloc(size);
    assert(data);
    deserialize_block_1(data,size);
    *((ap_abstract0_ptr*)dst) =
      ap_abstract0_deserialize_raw(deserialize_man,data,&realsize);
    free(data);
  }
  else caml_failwith("you must call Apron.Manager.set_deserialize before deserializing abstract elements.");
  return sizeof(ap_abstract0_ptr);
}

struct custom_operations camlidl_apron_custom_abstract0_ptr = {
  "apa0",
  camlidl_apron_abstract0_ptr_finalize,
  camlidl_apron_abstract0_ptr_compare,
  camlidl_apron_abstract0_ptr_hash,
  camlidl_apron_abstract0_serialize,
  camlidl_apron_abstract0_deserialize
};

/* ********************************************************************** */
/* linyyy1, tzzz1 */
/* ********************************************************************** */

MACRO_FOREACH TTT ("linexpr","lincons","lingen","texpr")
MACRO_FOREACH AAA ("","_array")
value camlidl_TTT1AAA_ptr_c2ml(ap_TTT1AAA_t* p)
{
  CAMLparam0();
  CAMLlocal3(v0,v1,v);
  ap_TTT1AAA_ptr pp = *p;
  v0 = camlidl_TTT0AAA_ptr_c2ml(&(pp->TTT0AAA));
  v1 = camlidl_apron_environment_ptr_c2ml(&(pp->env));
  v = alloc_small(2,0);
  Field(v,0) = v0;
  Field(v,1) = v1;
  CAMLreturn(v);
}
ENDMACRO
ENDMACRO

/* ********************************************************************** */
/* init */
/* ********************************************************************** */
value camlidl_apron_init(value dummy)
{
  register_custom_operations(&camlidl_apron_custom_abstract0_ptr);
  return Val_unit;
}
