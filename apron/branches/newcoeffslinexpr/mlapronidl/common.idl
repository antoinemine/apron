/* -*- mode: c -*- */

/* This file is part of the APRON library, released under LGPL license.
   Please read the COPYING file packaged in the distribution  */

quote(C, "\n\
#include \"apron_caml.h\"\n\
#include \"num_types.h\"\n\
#include \"ap_lin_types.h\"\n\
")

typedef [abstract,c2ml(camlidl_apron_num_internal_ptr_c2ml_dummy),ml2c(camlidl_apron_num_internal_ptr_ml2c)] struct num_internal_struct* num_internal_ptr;

enum num_discr_t {
  NUM_Il, NUM_Ill, NUM_MPZ,
  NUM_Rl, NUM_Rll, NUM_MPQ,
  NUM_D, NUM_Dl, NUM_MPFR
};

enum ap_exprtyp_t {
  AP_LINEXPR_INTLINEAR,
  AP_LINEXPR_QUASILINEAR,
  AP_LINEXPR_LINEAR
};
enum ap_constyp_t {
  AP_CONS_EQ,    /* equality constraint */
  AP_CONS_SUPEQ, /* >= constraint */
  AP_CONS_SUP,   /* > constraint */
  AP_CONS_EQMOD, /* congruence equality constraint */
  AP_CONS_DISEQ  /* disequality constraint */
};
enum ap_gentyp_t {
  AP_GEN_LINE,   /* Bidirectional ray (real coefficient) */
  AP_GEN_RAY,    /* Ray (positive real coefficient) */
  AP_GEN_VERTEX, /* Vertex ("barycenter" coefficient) */
  AP_GEN_LINEMOD,/* Bidirectionnal integer ray (integer coefficient) */
  AP_GEN_RAYMOD  /* Integer ray (positive integer coefficient) */
};

enum tbool_t {
  tbool_false,
  tbool_true,
  tbool_top
};
 
quote(MLMLI,"\n\
type ('a,'b,'c) t =\n\
| D of 'a\n\
| MPQ of 'b\n\
| MPFR of 'c\n\
type discr = (unit,unit,unit) t\n\
type 'a val1 = {\n\
  mutable val0: 'a;\n\
  mutable env: Environment.t;\n\
}\n\
\n\
type numIll\n\
type numRll\n\
type numMPZ\n\
type numMPQ\n\
type numD\n\
type numMPFR\n\
")

quote(MLMLI,"external num_internal_alloc : unit -> num_internal = \"camlidl_apron_num_internal_alloc\"")
quote(C,"\n\
value camlidl_apron_num_internal_alloc(value vunit)\n\
{\n\
  ap_manager_t* man = ap_manager_alloc(\"dummy\",\"dummy\",NULL,NULL);\n\
  man->count--;\n\
  value vres = camlidl_apron_num_internal_ptr_c2ml(man->num,man);\n\
  return vres;\n\
}\n\
")

quote(MLI,"\n\
val string_of_exprtyp : exprtyp -> string\n\
val string_of_constyp : constyp -> string\n\
val string_of_gentyp : gentyp -> string\n\
val discr : ('a,'b,'c) t -> discr\n\
val array_print :\n\
  ?first:(unit,Format.formatter,unit) format ->\n\
  ?sep:(unit,Format.formatter,unit) format ->\n\
  ?last:(unit,Format.formatter,unit) format ->\n\
  (Format.formatter -> 'a -> unit) ->\n\
  Format.formatter -> 'a array -> unit\n\
val earray_print :\n\
  ?first:(unit,Format.formatter,unit) format ->\n\
  ?sep:(unit,Format.formatter,unit) format ->\n\
  ?last:(unit,Format.formatter,unit) format ->\n\
  length:int ->\n\
  print_index:(Format.formatter -> int -> unit) ->\n\
  Format.formatter -> unit\n\
val make_val1 : 'a -> Environment.t -> 'a val1\n\
val check_val1 : 'a val1 -> 'b val1 -> unit\n\
val check_val1_add : 'a val1 -> 'b val1 -> ('b -> Dim.change -> 'b) -> 'b\n\
val map_discr :\n\
  ('a -> 'b) ->\n\
  ('c -> 'd) -> ('e -> 'f) -> ('a, 'c, 'e) t -> ('b, 'd, 'f) t\n\
val map_discr_arg :\n\
  ('a -> 'b -> 'c) ->\n\
  ('d -> 'b -> 'e) ->\n\
  ('f -> 'b -> 'g) -> ('a, 'd, 'f) t -> 'b -> ('c, 'e, 'g) t\n\
val map_discr_arg2 :\n\
  ('a -> 'b -> 'c -> 'd) ->\n\
  ('e -> 'b -> 'c -> 'f) ->\n\
  ('g -> 'b -> 'c -> 'h) -> ('a, 'e, 'g) t -> 'b -> 'c -> ('d, 'f, 'h) t\n\
val map_discr0_arg :\n\
  ('b -> 'c) ->\n\
  ('b -> 'e) ->\n\
  ('b -> 'g) -> ('a, 'd, 'f) t -> 'b -> ('c, 'e, 'g) t\n\
val mapsame_discr2 :\n\
  ('a -> 'b -> 'c) ->\n\
  ('e -> 'f -> 'c) ->\n\
  ('g -> 'h -> 'c) -> ('a, 'e, 'g) t -> ('b, 'f, 'h) t -> 'c\n\
val mapsame_discr2_arg :\n\
  ('a -> 'b -> 'c -> 'd) ->\n\
  ('e -> 'f -> 'c -> 'd) ->\n\
  ('g -> 'h -> 'c -> 'd) -> ('a, 'e, 'g) t -> ('b, 'f, 'h) t -> 'c -> 'd\n\
val apply_discr :\n\
  ('a -> 'b) -> ('c -> 'b) -> ('d -> 'b) -> ('a, 'c, 'd) t -> 'b\n\
val apply_arg_discr :\n\
  ('a -> 'b -> 'c) ->\n\
  ('a -> 'd -> 'c) -> ('a -> 'e -> 'c) -> 'a -> ('b, 'd, 'e) t -> 'c\n\
val apply_arg2_discr :\n\
  ('a -> 'b -> 'c -> 'd) ->\n\
  ('a -> 'b -> 'e -> 'd) ->\n\
  ('a -> 'b -> 'f -> 'd) -> 'a -> 'b -> ('c, 'e, 'f) t -> 'd\n\
val apply_discr_arg :\n\
  ('a -> 'b -> 'c) ->\n\
  ('d -> 'b -> 'c) -> ('e -> 'b -> 'c) -> ('a, 'd, 'e) t -> 'b -> 'c\n\
val apply_discr_arg2 :\n\
  ('a -> 'b -> 'c -> 'd) ->\n\
  ('e -> 'b -> 'c -> 'd) ->\n\
  ('f -> 'b -> 'c -> 'd) -> ('a, 'e, 'f) t -> 'b -> 'c -> 'd\n\
val apply_arg_discr_arg :\n\
  ('a -> 'b -> 'c -> 'd) ->\n\
  ('a -> 'e -> 'c -> 'd) ->\n\
  ('a -> 'f -> 'c -> 'd) -> 'a -> ('b, 'e, 'f) t -> 'c -> 'd\n\
")
quote(ML,"\n\
let string_of_exprtyp = function\n\
| INTLINEAR -> \"INTLINEAR\"\n\
| QUASILINEAR -> \"QUASILINEAR\"\n\
| LINEAR -> \"LINEAR\"\n\
let  string_of_constyp = function\n\
| EQ -> \"=\"\n\
| SUPEQ -> \">=\"\n\
| SUP -> \">\"\n\
| EQMOD -> \"=\"\n\
| DISEQ -> \"<>\"\n\
let  string_of_gentyp = function\n\
| LINE -> \"LINE\"\n\
| RAY -> \"RAY\"\n\
| VERTEX -> \"VTX\"\n\
| LINEMOD -> \"LINEMOD\"\n\
| RAYMOD -> \"RAYMOD\"\n\
let discr x =\n\
  match x with\n\
  | D _ -> D()\n\
  | MPQ _ -> MPQ()\n\
  | MPFR _ -> MPFR()\n\
let array_print\n\
  ?(first=(\"[|@[\":(unit,Format.formatter,unit) format))\n\
  ?(sep = (\";@ \":(unit,Format.formatter,unit) format))\n\
  ?(last = (\"@]|]\":(unit,Format.formatter,unit) format))\n\
  (print_elt: (Format.formatter -> 'a -> unit))\n\
  (fmt:Format.formatter)\n\
  (tab:'a array)\n\
  : unit\n\
  =\n\
  Format.fprintf fmt first;\n\
  Array.iteri\n\
    (fun i elt ->\n\
      if i>0 then Format.fprintf fmt sep;\n\
      print_elt fmt elt\n\
    )\n\
    tab;\n\
  Format.fprintf fmt last\n\
let earray_print\n\
  ?(first=(\"[|@[\":(unit,Format.formatter,unit) format))\n\
  ?(sep = (\";@ \":(unit,Format.formatter,unit) format))\n\
  ?(last = (\"@]|]\":(unit,Format.formatter,unit) format))\n\
  ~(length:int)\n\
  ~(print_index: Format.formatter -> int -> unit)\n\
  (fmt:Format.formatter)\n\
  : unit\n\
  =\n\
  Format.fprintf fmt first;\n\
  for i=0 to length-1 do\n\
    if i>0 then Format.fprintf fmt sep;\n\
    print_index fmt i\n\
  done;\n\
  Format.fprintf fmt last\n\
let make_val1 x env = { val0 = x; env = env }\n\
let check_val1 x y =\n\
  if x.env!=y.env && not (Environment.equal x.env y.env) then\n\
    raise (Invalid_argument \"The two values of level 1 are not based on the same environment\")\n\
let check_val1_add x y add =\n\
  if x.env==y.env || Environment.equal x.env y.env then\n\
    y.val0\n\
  else\n\
    try\n\
      let dimchange = Environment.dimchange x.env y.env in\n\
      add y.val0 dimchange\n\
    with Failure _ ->\n\
      raise (Invalid_argument \"The environment of the first value of level 1 is not a superenvironment of the environment of the second value of level1\")\n\
let map_discr d mpq mpfr discr =\n\
  match discr with\n\
  | D x -> D(d x)\n\
  | MPQ x -> MPQ(mpq x)\n\
  | MPFR x -> MPFR(mpfr x)\n\
let map_discr_arg d mpq mpfr discr arg =\n\
  match discr with\n\
  | D x -> D(d x arg)\n\
  | MPQ x -> MPQ(mpq x arg)\n\
  | MPFR x -> MPFR(mpfr x arg)\n\
let map_discr_arg2 d mpq mpfr discr arg1 arg2 =\n\
  match discr with\n\
  | D x -> D(d x arg1 arg2)\n\
  | MPQ x -> MPQ(mpq x arg1 arg2)\n\
  | MPFR x -> MPFR(mpfr x arg1 arg2)\n\
let map_discr0_arg d mpq mpfr discr arg =\n\
  match discr with\n\
  | D x -> D(d arg)\n\
  | MPQ x -> MPQ(mpq arg)\n\
  | MPFR x -> MPFR(mpfr arg)\n\
let mapsame_discr2 d mpq mpfr discr1 discr2 =\n\
  match discr1,discr2 with\n\
  | (D x1),(D x2) -> d x1 x2\n\
  | (MPQ x1),(MPQ x2) -> mpq x1 x2\n\
  | (MPFR x1),(MPFR x2) -> mpfr x1 x2\n\
  | _ -> raise (Invalid_argument \"The two argument sould have the same constructor (D, MPQ, or MPFR)\")\n\
let mapsame_discr2_arg d mpq mpfr discr1 discr2 arg =\n\
  match discr1,discr2 with\n\
  | (D x1),(D x2) -> d x1 x2 arg\n\
  | (MPQ x1),(MPQ x2) -> mpq x1 x2 arg\n\
  | (MPFR x1),(MPFR x2) -> mpfr x1 x2 arg\n\
  | _ -> raise (Invalid_argument \"The two argument sould have the same constructor (D, MPQ, or MPFR)\")\n\
let apply_discr d mpq mpfr discr =\n\
  match discr with\n\
  | D x -> d x\n\
  | MPQ x -> mpq x\n\
  | MPFR x -> mpfr x\n\
let apply_arg_discr d mpq mpfr arg discr =\n\
  match discr with\n\
  | D x -> d arg x\n\
  | MPQ x -> mpq arg x\n\
  | MPFR x -> mpfr arg x\n\
let apply_arg2_discr d mpq mpfr arg1 arg2 discr =\n\
  match discr with\n\
  | D x -> d arg1 arg2 x\n\
  | MPQ x -> mpq arg1 arg2 x\n\
  | MPFR x -> mpfr arg1 arg2 x\n\
let apply_discr_arg d mpq mpfr discr arg =\n\
  match discr with\n\
  | D x -> d x arg\n\
  | MPQ x -> mpq x arg\n\
  | MPFR x -> mpfr x arg\n\
let apply_discr_arg2 d mpq mpfr discr arg1 arg2 =\n\
  match discr with\n\
  | D x -> d x arg1 arg2\n\
  | MPQ x -> mpq x arg1 arg2\n\
  | MPFR x -> mpfr x arg1 arg2\n\
let apply_arg_discr_arg d mpq mpfr arg1 discr arg2 =\n\
  match discr with\n\
  | D x -> d arg1 x arg2\n\
  | MPQ x -> mpq arg1 x arg2\n\
  | MPFR x -> mpfr arg1 x arg2\n\
")
