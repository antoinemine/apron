/* -*- mode: c -*- */

/* This file is part of the APRON library, released under LGPL license.
   Please read the COPYING file packaged in the distribution  */

quote(C, "\n\
#include \"apron_caml.h\"\n\
#include \"num_types.h\"\n\
#include \"ap_lin_types.h\"\n\
")

typedef [abstract,c2ml(camlidl_num_internal_ptr_c2ml),ml2c(camlidl_num_internal_ptr_ml2c)] struct num_internal_struct* num_internal_ptr;

enum ap_exprtyp_t {
  AP_LINEXPR_INTLINEAR,
  AP_LINEXPR_QUASILINEAR,
  AP_LINEXPR_LINEAR
};
enum ap_constyp_t {
  AP_CONS_EQ,    /* equality constraint */
  AP_CONS_SUPEQ, /* >= constraint */
  AP_CONS_SUP,   /* > constraint */
  AP_CONS_EQMOD, /* congruence equality constraint */
  AP_CONS_DISEQ  /* disequality constraint */
};
enum ap_gentyp_t {
  AP_GEN_LINE,   /* Bidirectional ray (real coefficient) */
  AP_GEN_RAY,    /* Ray (positive real coefficient) */
  AP_GEN_VERTEX, /* Vertex ("barycenter" coefficient) */
  AP_GEN_LINEMOD,/* Bidirectionnal integer ray (integer coefficient) */
  AP_GEN_RAYMOD  /* Integer ray (positive integer coefficient) */
};

quote(MLMLI,"
type ('a,'b,'c) t =
| D of 'a
| MPQ of 'b
| MPFR of 'c
type discr = (unit,unit,unit) t
type 'a val1 = {
  mutable val0: 'a;
  mutable env: Environment.t;
}
")

quote(MLI,"
val string_of_exprtyp : exprtyp -> string
val string_of_constyp : constyp -> string
val string_of_gentyp : gentyp -> string
val discr : ('a,'b,'c) t -> discr
val array_print :
  ?first:(unit,Format.formatter,unit) format ->
  ?sep:(unit,Format.formatter,unit) format ->
  ?last:(unit,Format.formatter,unit) format ->
  (Format.formatter -> 'a -> unit) ->
  Format.formatter -> 'a array -> unit
val earray_print :
  ?first:(unit,Format.formatter,unit) format ->
  ?sep:(unit,Format.formatter,unit) format ->
  ?last:(unit,Format.formatter,unit) format ->
  length:int ->
  print_index:(Format.formatter -> int -> unit) ->
  Format.formatter -> unit
val make_val1 : 'a -> Environment.t -> 'a val1
val map_discr :
  ('a -> 'b) ->
  ('c -> 'd) -> ('e -> 'f) -> ('a, 'c, 'e) t -> ('b, 'd, 'f) t
val map_discr0_arg :
  ('b -> 'c) ->
  ('b -> 'e) ->
  ('b -> 'g) -> ('a, 'd, 'f) t -> 'b -> ('c, 'e, 'g) t
val mapsame_discr2_arg :
  ('a -> 'b -> 'c -> 'd) ->
  ('e -> 'f -> 'c -> 'd) ->
  ('g -> 'h -> 'c -> 'd) -> ('a, 'e, 'g) t -> ('b, 'f, 'h) t -> 'c -> 'd
val apply_discr :
  ('a -> 'b) -> ('c -> 'b) -> ('d -> 'b) -> ('a, 'c, 'd) t -> 'b
val apply_arg_discr :
  ('a -> 'b -> 'c) ->
  ('a -> 'd -> 'c) -> ('a -> 'e -> 'c) -> 'a -> ('b, 'd, 'e) t -> 'c
val apply_arg2_discr :
  ('a -> 'b -> 'c -> 'd) ->
  ('a -> 'b -> 'e -> 'd) ->
  ('a -> 'b -> 'f -> 'd) -> 'a -> 'b -> ('c, 'e, 'f) t -> 'd
val apply_discr_arg :
  ('a -> 'b -> 'c) ->
  ('d -> 'b -> 'c) -> ('e -> 'b -> 'c) -> ('a, 'd, 'e) t -> 'b -> 'c
val apply_discr_arg2 :
  ('a -> 'b -> 'c -> 'd) ->
  ('e -> 'b -> 'c -> 'd) ->
  ('f -> 'b -> 'c -> 'd) -> ('a, 'e, 'f) t -> 'b -> 'c -> 'd
val apply_arg_discr_arg :
  ('a -> 'b -> 'c -> 'd) ->
  ('a -> 'e -> 'c -> 'd) ->
  ('a -> 'f -> 'c -> 'd) -> 'a -> ('b, 'e, 'f) t -> 'c -> 'd
")
quote(ML,"
let string_of_exprtyp = function
| INTLINEAR -> \"INTLINEAR\"
| QUASILINEAR -> \"QUASILINEAR\"
| LINEAR -> \"LINEAR\"
let  string_of_constyp = function
| EQ -> \"=\"
| SUPEQ -> \">=\"
| SUP -> \">\"
| EQMOD -> \"=\"
| DISEQ -> \"<>\"
let  string_of_gentyp = function
| LINE -> \"LINE\"
| RAY -> \"RAY\"
| VERTEX -> \"VTX\"
| LINEMOD -> \"LINEMOD\"
| RAYMOD -> \"RAYMOD\"
let discr x =
  match x with
  | D _ -> D()
  | MPQ _ -> MPQ()
  | MPFR _ -> MPFR()
let array_print
  ?(first=(\"[|@[\":(unit,Format.formatter,unit) format))
  ?(sep = (\";@ \":(unit,Format.formatter,unit) format))
  ?(last = (\"@]|]\":(unit,Format.formatter,unit) format))
  (print_elt: (Format.formatter -> 'a -> unit))
  (fmt:Format.formatter)
  (tab:'a array)
  : unit
  =
  Format.fprintf fmt first;
  Array.iteri
    (fun i elt ->
      if i>0 then Format.fprintf fmt sep;
      print_elt fmt elt
    )
    tab;
  Format.fprintf fmt last
let earray_print
  ?(first=(\"[|@[\":(unit,Format.formatter,unit) format))
  ?(sep = (\";@ \":(unit,Format.formatter,unit) format))
  ?(last = (\"@]|]\":(unit,Format.formatter,unit) format))
  ~(length:int)
  ~(print_index: Format.formatter -> int -> unit)
  (fmt:Format.formatter)
  : unit
  =
  Format.fprintf fmt first;
  for i=0 to length-1 do
    if i>0 then Format.fprintf fmt sep;
    print_index fmt i
  done;
  Format.fprintf fmt last
let make_val1 x env = { val0 = x; env = env }
let map_discr d mpq mpfr discr =
  match discr with
  | D x -> D(d x)
  | MPQ x -> MPQ(mpq x)
  | MPFR x -> MPFR(mpfr x)
let map_discr0_arg d mpq mpfr discr arg =
  match discr with
  | D x -> D(d arg)
  | MPQ x -> MPQ(mpq arg)
  | MPFR x -> MPFR(mpfr arg)
let mapsame_discr2_arg d mpq mpfr discr1 discr2 arg =
  match discr1,discr2 with
  | (D x1),(D x2) -> d x1 x2 arg
  | (MPQ x1),(MPQ x2) -> mpq x1 x2 arg
  | (MPFR x1),(MPFR x2) -> mpfr x1 x2 arg
  | _ -> raise (Invalid_argument \"The two argument sould have the same constructor (D, MPQ, or MPFR)\")
let apply_discr d mpq mpfr discr =
  match discr with
  | D x -> d x
  | MPQ x -> mpq x
  | MPFR x -> mpfr x
let apply_arg_discr d mpq mpfr arg discr =
  match discr with
  | D x -> d arg x
  | MPQ x -> mpq arg x
  | MPFR x -> mpfr arg x
let apply_arg2_discr d mpq mpfr arg1 arg2 discr =
  match discr with
  | D x -> d arg1 arg2 x
  | MPQ x -> mpq arg1 arg2 x
  | MPFR x -> mpfr arg1 arg2 x
let apply_discr_arg d mpq mpfr discr arg =
  match discr with
  | D x -> d x arg
  | MPQ x -> mpq x arg
  | MPFR x -> mpfr x arg
let apply_discr_arg2 d mpq mpfr discr arg1 arg2 =
  match discr with
  | D x -> d x arg1 arg2
  | MPQ x -> mpq x arg1 arg2
  | MPFR x -> mpfr x arg1 arg2
let apply_arg_discr_arg d mpq mpfr arg1 discr arg2 =
  match discr with
  | D x -> d arg1 x arg2
  | MPQ x -> mpq arg1 x arg2
  | MPFR x -> mpfr arg1 x arg2
")
