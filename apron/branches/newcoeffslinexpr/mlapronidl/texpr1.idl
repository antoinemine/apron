/* -*- mode: c -*- */

quote(MLI,"(** APRON tree expressions of level 1 *)")

quote(C, "#include \"apron_caml.h\"")

import "texpr0.idl";

typedef [\
    abstract,\
    c2ml(camlidl_texpr1_t_c2ml),\
    ml2c(camlidl_texpr1_t_ml2c),\
    mltype("Texpr0.t Common.val1")\
] struct ap_texpr1_t ap_texpr1_t;
typedef [\
    abstract,\
    c2ml(camlidl_texpr1_array_t_c2ml),\
    ml2c(camlidl_texpr1_array_t_ml2c),\
    mltype("Texpr0.t array Common.val1")\
] struct ap_texpr1_array_t ap_texpr1_array_t;

quote(MLMLI,"\n\
(** Unary operators *) \n\
type unop = Texpr0.unop = \n\
  | Neg\n\
  | Cast\n\
  | Sqrt\n\
\n\
(** Binary operators *) \n\
type binop = Texpr0.binop = \n\
  | Add\n\
  | Sub\n\
  | Mul\n\
  | Div\n\
  | Mod\n\
\n\
(** Destination type for rounding *) \n\
type typ = Texpr0.typ = \n\
  | Real\n\
  | Int\n\
  | Single\n\
  | Double\n\
  | Extended\n\
  | Quad\n\
\n\
(** Rounding direction *) \n\
type round = Texpr0.round = \n\
  | Near\n\
  | Zero\n\
  | Up\n\
  | Down\n\
  | Rnd\n\
\n\
(** User type for tree expressions *) \n\
type 'a gexpr = 'a Texpr0.gexpr =\n\
  | Cst of Coeff.f Coeff.tt \n\
  | DimVar of 'a \n\
  | Unop of unop * 'a gexpr * typ * round \n\
  | Binop of binop * 'a gexpr * 'a gexpr * typ * round \n\
type expr = Var.t gexpr\n\
")


quote(MLI,"\n\
(** {2 Printing} *)\n

val string_of_unop  : unop  -> string\n\
val string_of_binop : binop -> string\n\
val string_of_typ   : typ   -> string\n\
val string_of_round : round -> string\n\
val print_unop  :  Format.formatter -> unop  -> unit\n\
val print_binop :  Format.formatter -> binop -> unit\n\
val print_typ   :  Format.formatter -> typ   -> unit\n\
val print_round :  Format.formatter -> round -> unit\n\
val print_expr : Format.formatter -> expr -> unit\n\
  (** Print a tree expression *)\n\
val print : Format.formatter -> t -> unit\n\
  (** Print an abstract tree expression *)\n\
\n\
(** {2 Expressions} *)\n\
\n\
(** {3 Constructors and Destructor} *)\n\
\n\
(** General constructor (actually the most efficient) *)\n\
val of_expr : Environment.t -> expr -> t\n\
val to_expr : t -> expr\n\
val copy : t -> t\n\
val of_linexpr1 : Linexpr1.t -> t\n\
\n\
(** {4 Incremental constructors} *)\n\
")

[ref]struct ap_texpr1_t* ap_texpr1_cst(ap_environment_ptr env, ap_coeff_tg coeff);
[ref]struct ap_texpr1_t* ap_texpr1_var(ap_environment_ptr env, ap_var_t var);
[ref]struct ap_texpr1_t* ap_texpr1_unop(ap_texpr_unop_t op,
				 [ref]struct ap_texpr1_t* expr,
				 ap_texpr_rtype_t type, ap_texpr_rdir_t dir)
quote(call,"_res = ap_texpr1_unop(op,ap_texpr1_copy(expr),type,dir);");
[ref]struct ap_texpr1_t* ap_texpr1_binop(ap_texpr_binop_t op,
				  [ref]struct ap_texpr1_t* exprA, [ref]struct ap_texpr1_t* exprB,
				  ap_texpr_rtype_t type, ap_texpr_rdir_t dir)
quote(call,"_res = ap_texpr1_binop(op,ap_texpr1_copy(exprA),ap_texpr1_copy(exprB),type,dir);");

quote(MLI,"\n\
(** {3 Tests} *)\n\
\n\
val is_interval_cst : t -> bool \n\
val is_interval_linear : t -> bool \n\
val is_interval_polynomial : t -> bool \n\
val is_interval_polyfrac : t -> bool \n\
val is_scalar : t -> bool \n\
\n\
(** {3 Operations} *)\n\
(** Change the environment of the expression for a super-environement. Raise [Failure] if it is not the case *)\
")
[ref]struct ap_texpr1_t* ap_texpr1_extend_environment([ref]struct ap_texpr1_t* texpr,
						      ap_environment_ptr env)
     quote(call,"\n\
{\n\
  bool b;\n\
  _res = ap_texpr1_extend_environment(texpr,env);\n\
  if (!_res) caml_invalid_argument(\"Texpr1.extend_environment: new environment is not a superenvironment\");\n\
}\n\
")
;
quote(MLI,"(** Side-effet version of the previous function *)")
void ap_texpr1_extend_environment_with([ref]struct ap_texpr1_t* texpr,
				       ap_environment_ptr env)
     quote(call,"\n\
  Begin_roots2(_v_texpr,_v_env);\n\
  if (texpr->env!=env){ \n\
    bool b;\n\
    ap_environment_copy(texpr->env); /* to protect it */ \n\
    b = ap_texpr1_extend_environment_with(texpr,env);\n\
    if (b){ \n\
      ap_environment_free(texpr->env); \n\
      caml_failwith(\"Texpr1.extend_environment_with: new environment is not a superenvironment\");\n\
    }\n\
    Store_field(_v_texpr,1,_v_env);\n\
    ap_environment_free(env);\n\
  }\n\
  End_roots()\n\
");

quote(MLI,"\n\
(** {2 Arrays} *)\n\
\n\
(** {3 Constructors and Destructor} *)\n\
val array_make : int -> earray\n\
val array_size : earray -> int\n\
val array_of_lincons1_array : Lincons1.earray -> earray\n\
\n\
(** {3 Access} *)y\n\
val array_get_index : earray -> int -> ty\n\
val array_set_index : earray -> int -> t -> unity\n\
\n\
(** {3 Operations} *)\n\
val array_extend_environment : earray -> env -> earray\n\
val array_extend_environment_with : earray -> env -> unit\n\
")

quote(ML,"\n\
let string_of_unop = Texpr0.string_of_unop\n\
let string_of_binop = Texpr0.string_of_binop\n\
let string_of_typ = Texpr0.string_of_typ\n\
let string_of_round = Texpr0.string_of_round\n\
let print_unop = Texpr0.print_unop\n\
let print_binop = Texpr0.print_binop\n\
let print_typ = Texpr0.print_typ\n\
let print_round = Texpr0.print_round\n\
let print_expr fmt (expr:expr) =\n\
  Texpr0.print_gexpr Var.to_string fmt expr\n\
let print fmt expr =\n\
  Texpr0.print\n\
   (Environment.string_of_dim expr.Common.env)\n\
   fmt expr.Common.val0\n\
let rec expr0_of_expr1 env expr =\n\
  Texpr0.map_gexpr (Environment.dim_of_var env) expr\n\
let texpr0_of_expr env (expr:expr) =\n\
  Texpr0.of_expr (expr0_of_expr1 env expr)\n\
let of_expr env expr : t = Common.make_val1 (texpr0_of_expr env expr) env\n\
let rec expr1_of_expr0 env expr =\n\
  Texpr0.map_gexpr (Environment.var_of_dim env) expr\n\
let to_expr texpr1 =\n\
  let expr0 = Texpr0.to_expr texpr1.Common.val0 in\n\
  expr1_of_expr0 texpr1.Common.env expr0\n\
let copy e = Common.make_val1 (Texpr0.copy e.Common.val0) e.Common.env\n\
let of_linexpr1 e = Common.make_val1 (Texpr0.of_linexpr0 e.Common.val0) e.Common.env\n\
let is_interval_cst (x:t) = Texpr0.is_interval_cst x.Common.val0 \n\
let is_interval_linear (x:t) = Texpr0.is_interval_linear x.Common.val0 \n\
let is_interval_polynomial (x:t) = Texpr0.is_interval_polynomial x.Common.val0 \n\
let is_interval_polyfrac (x:t) = Texpr0.is_interval_polyfrac x.Common.val0 \n\
let is_scalar (x:t) = Texpr0.is_scalar x.Common.val0 \n\
\n\
let array_print ?first ?sep ?last fmt array =\n\
  Texpr0.array_print ?first ?sep ?last (Environment.string_of_dim array.Common.env) array.Common.val0\n\
let array_make length env : Texpr0.t array Common.val1 =\n\
  Common.make_val1 (Array.make length (Texpr0.cst 0)) env\n\
let array_size array = Array.length array.Common.val0\n\
let array_copy array = Common.make_val1 (Array.map Texpr0.copy array.Common.val0) array.Common.env\n\
let array_of_lincons1_array array = Common.make_val1 Tcons0.array_of_lincons0_array array.Common.val0) array.Common.env\n\
let array_get_index array index = Common.make_val1 array.Common.val0.(index) array.Common.env\n\
let array_set_index array index x =\n\
  if (array.Common.env<>x.Common.env)  then raise (Invalid_argument (\"Apron.Texpr1.array_set_index: the environments of the arguments should be the same\"));\n\
  array.Common.val0.(index) <- x.Common.val0\n\
let extend_environment array env =\n\
  let change = Environment.dimchange array.Common.env env in\n\
  Common.make_val1 (Texpr0.array_add_dimensions array.Common.val0 change) env\n\
")
