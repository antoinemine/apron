/* -*- mode: c -*- */

PERLEVAL @BoxNum = split(" ",$ENV{BOX_NUMTYPES})

/* This file is part of the APRON Library, released under LGPL license.  Please
   read the COPYING file packaged in the distribution */

quote(C,"#include \"box.h\"")
quote(C,"#include \"apron_caml.h\"")

import "manager.idl";

struct box_option_t {
  unsigned int kmax;
};

quote(MLMLI,"(** Intervals abstract domain *)\n")

quote(MLMLI,"\n\
type 'a t\n\
  (** Type of boxes, where ['a] is one of the [Common.numXXX] types\n\
      above and indicates the underlying number representation.\n\
\n\
      Boxes constrains each dimension/variable [x_i] to belong to an interval\n\
      [I_i].\n\
\n\
      Abstract values which are boxes have the type ['a t Apron.AbstractX.t].\n\
\n\
      Managers allocated for boxes have the type ['a t Apron.manager.t].\n\
  *)\n\
")

quote(MLI,"(** {2 Create a Box manager} *)")

quote(C,"\n\
value camlidl_box_manager_alloc(value _v_num_discr)\n\
{\n\
  ap_manager_t* man = box_manager_alloc(Int_val(_v_num_discr));\n\
  if (man==NULL){\n\
    caml_failwith(\"Num type not available\");\n\
  }\n\
  ap_exc_t i;\n\
  for (i=1; i<AP_EXC_SIZE; i++){\n\
    ap_manager_set_abort_if_exception(man,i,false);\n\
  }\n\
  value v = camlidl_apron_manager_ptr_c2ml(&man);\n\
  return v;\n\
}\n\
")
quote(MLMLI,"\
external manager_alloc : 'a Common.num_type -> 'a t Manager.t = \"camlidl_box_manager_alloc_num\"\
")

[ref]struct box_option_t* box_manager_get_option(ap_manager_ptr man)
quote(call,"_res = box_manager_option_ref(man);");
void box_manager_set_option(ap_manager_ptr man, struct box_option_t opt)
quote(call,"{ box_option_t* ref = box_manager_option_ref(man); *ref = opt; }");

quote(MLI,"\n\
(** {2 Type conversions} *)\n\
\n\
val manager_is_box : 'a Manager.t -> bool\n\
  (** Return [true] iff the argument manager is a box manager *)\n\
val manager_is_box_num_type : 'a Manager.t -> 'b Common.num_type -> bool\n\
  (** Return [true] iff the argument manager is a box manager with the given underlyng num type *)\n\
\n\
val manager_of_box : 'a t Manager.t -> 'b Manager.t\n\
  (** Makes a box manager generic *)\n\
\n\
val manager_to_box : 'a Manager.t -> 'b t Manager.t\n\
val manager_to_box_num_type : 'a Manager.t -> 'b Common.num_type -> 'b t Manager.t\n\
  (** Instanciate the type of a box manager.\n\
      Raises [Failure] if the argument manager is not a right manager *)\n\
")

MACRO_FOREACH NNN ("0","1")
quote(MLI,"\n\
module AbstractNNN : sig\n\
  val is_box : 'a AbstractNNN.t -> bool\n\
  val is_box_num_type : 'a AbstractNNN.t -> 'b Common.num_type -> bool\n\
    (** Return [true] iff the argument manager is a box manager *)\n\
\n\
  val of_box : 'a t AbstractNNN.t -> 'b AbstractNNN.t\n\
    (** Makes a box manager generic *)\n\
\n\
  val to_box : 'a AbstractNNN.t -> 'b t AbstractNNN.t\n\
  val to_box_num_type : 'a AbstractNNN.t -> 'b Common.num_type -> 'b t AbstractNNN.t\n\
    (** Instanciate the type of a box abstract value.\n\
	Raises [Failure] if the argument abstract value is not of the right type *)\n\
end\n\
")
ENDMACRO


quote(ML,"\n\
let regexp_box = Str.regexp \"box\"\n\
let manager_is_box man =\n\
  let str = Manager.get_library man in\n\
  Str.string_match regexp_box str 0\n\
let manager_of_box : 'a t Manager.t -> 'b Manager.t = Obj.magic\n\
let manager_to_box (man:'a Manager.t) : 'b t Manager.t =\n\
  if manager_is_box man then\n\
    Obj.magic man\n\
  else\n\
    failwith \"Box.to_box: the argument manager is not a Box manager\"\n\
let regexp_num_type num_type = Str.regexp (\"box.*num\"^(Common.string_of_num_type num_type))\n\
let manager_is_box_num_type man num_type=\n\
  let str = Manager.get_library man in\n\
  Str.string_match (regexp_num_type num_type) str 0\n\
let manager_to_box_num_type man num_type=\n\
  if manager_is_box_num_type man num_type then\n\
    Obj.magic man\n\
  else\n\
    raise (Failure \"Box.manager_box_to_num_type: the argument manager is not a Box manager, nor not a Box manager with the given num type\")\n\
")

MACRO_FOREACH NNN ("0","1")
quote(ML,"\n\
module AbstractNNN = struct\n\
  let is_box abs =\n\
    manager_is_box (AbstractNNN.manager abs)\n\
  let of_box = Obj.magic\n\
  let to_box abs =\n\
    if is_box abs then\n\
      Obj.magic abs\n\
    else\n\
      raise (Failure \"Box.Abstract0.to_box: the argument value is not a Box value\")\n\
  let is_box_num_type abs num_type=\n\
    manager_is_box_num_type (AbstractNNN.manager abs) num_type\n\
  let to_box_num_type abs num_type=\n\
    if is_box_num_type abs num_type then\n\
      Obj.magic abs\n\
    else\n\
      raise (Failure \"Box.AbstractNNN.to_box_num_type: the argument value is not a Box value, nor a Box value with the given num type\")\n\
end\n\
")
ENDMACRO
