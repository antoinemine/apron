/* -*- mode: c -*- */

quote(C,"#include \"ap_global0.h\"")
quote(C,"#include \"apron_caml.h\"")
quote(C,"#include \"ap_pkgrid.h\"")
quote(C,"#include \"ap_disjpk.h\"")

import "manager.idl";
import "abstract0.idl";

quote(MLMLI,"(** Disjunctions of NewPolka polyhedra *)")

quote(MLMLI,"
type 'a t
")

ap_manager_ptr ap_disjpk_manager_alloc(ap_manager_ptr manpk)
quote(call,"
_res = ap_disjpk_manager_alloc(manpk);
if (_res==NULL) caml_failwith(\"DisjPk.manager_alloc\");
{ ap_exc_t i;
for (i=1; i<AP_EXC_SIZE; i++){
ap_manager_set_abort_if_exception(_res,i,false);
}}
");

struct ap_lincons0_array_t ap_disjpk_to_lincons_set(ap_manager_ptr man, ap_abstract0_ptr a)
     quote(dealloc,"free(_res.p); I0_CHECK_EXC(man)");

quote(MLI,"(** Decompose an abstract value *)")

[size_is(size)] ap_abstract0_ptr* ap_disjpk__decompose(ap_manager_ptr manager, ap_abstract0_ptr abs, [out]int size)
quote(call,"
{
  ap_disjunction_internal_t* intern = manager->internal;
  ap_manager_t* man = intern->manager;
  int i;

  void** tabvoid = ap_disjunction_decompose(manager,false,(ap_disjunction_t*)abs->value,(size_t*)&size);
  ap_abstract0_ptr* tababs0 = malloc(size*sizeof(ap_abstract0_ptr));
  for (i=0; i<size; i++){
    tababs0[i] = malloc(sizeof(ap_abstract0_t));
    tababs0[i]->man = ap_manager_copy(man);
    tababs0[i]->value = tabvoid[i];
  }
  free(tabvoid);
  _res = tababs0;
}
")
quote(dealloc,"free(_res);");

quote(ML,"let decompose man abs = fst(_decompose man abs)")
quote(MLI,"val decompose : 'a t Apron.Manager.t -> 'a t Apron.Abstract0.t -> 'a Apron.Abstract0.t array")

ap_abstract0_ptr ap_disjpk_compose(ap_manager_ptr manager, [size_is(size)] ap_abstract0_ptr* tabs, int size)
quote(call,"
{
  int i;
  if (size==0){
    caml_invalid_argument(\"Array of size 0\");
  }
  ap_disjunction_internal_t* intern = manager->internal;
  ap_manager_t* man = intern->manager;

  void** tabvoid = malloc(size*sizeof(void*));
  for (i=0; i<size; i++) tabvoid[i] = tabs[i]->value;

  ap_disjunction_t* disj = ap_disjunction_compose(manager, false, tabvoid, (size_t)size);

  free(tabvoid);
  _res = malloc(sizeof(ap_abstract0_t));
  _res->man = ap_manager_copy(manager);
  _res->value = disj;
}
");
